import { Enum, GetEnum, FixedSizeBinary, Binary, SS58String, FixedSizeArray, ResultPayload, TxCallData, HexString } from "polkadot-api";
type AnonymousEnum<T extends {}> = T & {
    __anonymous: true;
};
type MyTuple<T> = [T, ...T[]];
type SeparateUndefined<T> = undefined extends T ? undefined | Exclude<T, undefined> : T;
type Anonymize<T> = SeparateUndefined<T extends FixedSizeBinary<infer L> ? number extends L ? Binary : FixedSizeBinary<L> : T extends string | number | bigint | boolean | void | undefined | null | symbol | Uint8Array | Enum<any> ? T : T extends AnonymousEnum<infer V> ? Enum<V> : T extends MyTuple<any> ? {
    [K in keyof T]: T[K];
} : T extends [] ? [] : T extends FixedSizeArray<infer L, infer T> ? number extends L ? Array<T> : FixedSizeArray<L, T> : {
    [K in keyof T & string]: T[K];
}>;
export type I5sesotjlssv2d = {
    "nonce": number;
    "consumers": number;
    "providers": number;
    "sufficients": number;
    "data": Anonymize<I1q8tnt1cluu5j>;
};
export type I1q8tnt1cluu5j = {
    "free": bigint;
    "reserved": bigint;
    "frozen": bigint;
    "flags": bigint;
};
export type Iffmde3ekjedi9 = {
    "normal": Anonymize<I4q39t5hn830vp>;
    "operational": Anonymize<I4q39t5hn830vp>;
    "mandatory": Anonymize<I4q39t5hn830vp>;
};
export type I4q39t5hn830vp = {
    "ref_time": bigint;
    "proof_size": bigint;
};
export type I4mddgoa69c0a2 = Array<DigestItem>;
export type DigestItem = Enum<{
    "PreRuntime": Anonymize<I82jm9g7pufuel>;
    "Consensus": Anonymize<I82jm9g7pufuel>;
    "Seal": Anonymize<I82jm9g7pufuel>;
    "Other": Binary;
    "RuntimeEnvironmentUpdated": undefined;
}>;
export declare const DigestItem: GetEnum<DigestItem>;
export type I82jm9g7pufuel = [FixedSizeBinary<4>, Binary];
export type I4teul8scvp5sj = Array<{
    "phase": Phase;
    "event": Anonymize<I6argrunpb283o>;
    "topics": Anonymize<Ic5m5lp1oioo8r>;
}>;
export type Phase = Enum<{
    "ApplyExtrinsic": number;
    "Finalization": undefined;
    "Initialization": undefined;
}>;
export declare const Phase: GetEnum<Phase>;
export type I6argrunpb283o = AnonymousEnum<{
    "System": Anonymize<I4bhl9k4st098q>;
    "Scheduler": Anonymize<I4o7o5getfhvm5>;
    "Preimage": PreimageEvent;
    "Indices": Anonymize<I2pejk6do5vg4t>;
    "Balances": Anonymize<Iao8h4hv7atnq3>;
    "TransactionPayment": TransactionPaymentEvent;
    "Staking": Anonymize<I8n4qjnlkvth8n>;
    "Offences": OffencesEvent;
    "Session": Anonymize<I4co4bgsti676q>;
    "Grandpa": GrandpaEvent;
    "Treasury": Anonymize<Ia1b9fjuj0ob0b>;
    "ConvictionVoting": Anonymize<I7tvgbf73o5td4>;
    "Referenda": Anonymize<Idfraa3b4eu018>;
    "Whitelist": Anonymize<Ibes6fmdev02fd>;
    "Claims": CommonClaimsEvent;
    "Vesting": VestingEvent;
    "Utility": Anonymize<I82huppsu6dfkt>;
    "Proxy": Anonymize<Ie8893ig1oqadp>;
    "Multisig": Anonymize<I1m5e04eop0qlq>;
    "Bounties": BountiesEvent;
    "ChildBounties": ChildBountiesEvent;
    "ElectionProviderMultiPhase": ElectionProviderMultiPhaseEvent;
    "VoterList": BagsListEvent;
    "NominationPools": Anonymize<Id0dkgikq71n9h>;
    "FastUnstake": Anonymize<Iaq2o5035hc46c>;
    "DelegatedStaking": Anonymize<I1nq1se98idofq>;
    "ParaInclusion": Anonymize<If7iaaqrjurpqf>;
    "Paras": ParachainsParasEvent;
    "Hrmp": ParachainsHrmpEvent;
    "ParasDisputes": ParachainsDisputesEvent;
    "OnDemand": Anonymize<I8vt07l5vp6sb8>;
    "Registrar": CommonParasRegistrarEvent;
    "Slots": CommonSlotsEvent;
    "Auctions": CommonAuctionsEvent;
    "Crowdloan": Anonymize<Iaoudv69ujgdup>;
    "Coretime": PolkadotRuntimeParachainsCoretimeEvent;
    "StateTrieMigration": Anonymize<I61dksvl51aujo>;
    "XcmPallet": Anonymize<Id2l439q7pe8kr>;
    "MessageQueue": Anonymize<I13vul90391uuv>;
    "AssetRate": Anonymize<I1dcjapt414ijf>;
}>;
export type I4bhl9k4st098q = AnonymousEnum<{
    /**
     * An extrinsic completed successfully.
     */
    "ExtrinsicSuccess": Anonymize<Ia82mnkmeo2rhc>;
    /**
     * An extrinsic failed.
     */
    "ExtrinsicFailed": Anonymize<I5p9p029bsn77j>;
    /**
     * `:code` was updated.
     */
    "CodeUpdated": undefined;
    /**
     * A new account was created.
     */
    "NewAccount": Anonymize<Icbccs0ug47ilf>;
    /**
     * An account was reaped.
     */
    "KilledAccount": Anonymize<Icbccs0ug47ilf>;
    /**
     * On on-chain remark happened.
     */
    "Remarked": Anonymize<I855j4i3kr8ko1>;
    /**
     * An upgrade was authorized.
     */
    "UpgradeAuthorized": Anonymize<Ibgl04rn6nbfm6>;
    /**
     * An invalid authorized upgrade was rejected while trying to apply it.
     */
    "RejectedInvalidAuthorizedUpgrade": Anonymize<I7hp0ibc3qanbd>;
}>;
export type Ia82mnkmeo2rhc = {
    "dispatch_info": Anonymize<Ic9s8f85vjtncc>;
};
export type Ic9s8f85vjtncc = {
    "weight": Anonymize<I4q39t5hn830vp>;
    "class": DispatchClass;
    "pays_fee": Anonymize<Iehg04bj71rkd>;
};
export type DispatchClass = Enum<{
    "Normal": undefined;
    "Operational": undefined;
    "Mandatory": undefined;
}>;
export declare const DispatchClass: GetEnum<DispatchClass>;
export type Iehg04bj71rkd = AnonymousEnum<{
    "Yes": undefined;
    "No": undefined;
}>;
export type I5p9p029bsn77j = {
    "dispatch_error": Anonymize<I3rv535b81c0ac>;
    "dispatch_info": Anonymize<Ic9s8f85vjtncc>;
};
export type I3rv535b81c0ac = AnonymousEnum<{
    "Other": undefined;
    "CannotLookup": undefined;
    "BadOrigin": undefined;
    "Module": Enum<{
        "System": Anonymize<I5o0s7c8q1cc9b>;
        "Scheduler": Anonymize<If7oa8fprnilo5>;
        "Preimage": Anonymize<I4cfhml1prt4lu>;
        "Babe": Anonymize<Ib6q602k6o213a>;
        "Timestamp": undefined;
        "Indices": Anonymize<Icq1825fru3di2>;
        "Balances": Anonymize<Idj13i7adlomht>;
        "TransactionPayment": undefined;
        "Authorship": undefined;
        "Staking": Anonymize<Ileu8a8k5fbnr>;
        "Offences": undefined;
        "Historical": undefined;
        "Session": Anonymize<I1e07dgbaqd1sq>;
        "Grandpa": Anonymize<I7q8i0pp1gkas6>;
        "AuthorityDiscovery": undefined;
        "Treasury": Anonymize<I36uss0m9fpcsf>;
        "ConvictionVoting": Anonymize<Idfa8k8ikssbsf>;
        "Referenda": Anonymize<I84u4ul208g742>;
        "Origins": undefined;
        "Whitelist": Anonymize<I15nctscutpbeh>;
        "Claims": Anonymize<Ijh2jbbqvb176>;
        "Vesting": Anonymize<Icof2acl69lq3c>;
        "Utility": Anonymize<I8dt2g2hcrgh36>;
        "Proxy": Anonymize<Iuvt54ei4cehc>;
        "Multisig": Anonymize<Ia76qmhhg4jvb9>;
        "Bounties": Anonymize<Ibfvjqqblobf53>;
        "ChildBounties": Anonymize<I4u5ou5u3tthff>;
        "ElectionProviderMultiPhase": Anonymize<Idb84kfjd998sl>;
        "VoterList": Anonymize<Ic35l5bgiij29p>;
        "NominationPools": Anonymize<Iuudu4kursojc>;
        "FastUnstake": Anonymize<Iau9bur8dc3bec>;
        "DelegatedStaking": Anonymize<Iaogv3iimefnis>;
        "ParachainsOrigin": undefined;
        "Configuration": Anonymize<In1jctfv299lm>;
        "ParasShared": undefined;
        "ParaInclusion": Anonymize<I4rrcn97hglfls>;
        "ParaInherent": Anonymize<I2g8k20rpkqcs4>;
        "ParaScheduler": undefined;
        "Paras": Anonymize<Ieo97unb4d08rl>;
        "Initializer": undefined;
        "Dmp": undefined;
        "Hrmp": Anonymize<Ibns95nfmm92df>;
        "ParaSessionInfo": undefined;
        "ParasDisputes": Anonymize<Iakburbqot4g58>;
        "ParasSlashing": Anonymize<I1v70p1j0r2q1j>;
        "OnDemand": Anonymize<I48hdahgqa1mcd>;
        "CoretimeAssignmentProvider": Anonymize<I2mjnb5vgujeqj>;
        "Registrar": Anonymize<I97vkspnd0b8bh>;
        "Slots": Anonymize<Iers095sa65pbg>;
        "Auctions": Anonymize<I4kgo47o2v3701>;
        "Crowdloan": Anonymize<I9o6l1c4r4qc3s>;
        "Coretime": Anonymize<Ifju0orssp9h7o>;
        "StateTrieMigration": Anonymize<I96objte63brjr>;
        "XcmPallet": Anonymize<I6dl09bpoqheqk>;
        "MessageQueue": Anonymize<I5iupade5ag2dp>;
        "AssetRate": Anonymize<I3qgd61cgli6cp>;
        "Beefy": Anonymize<Iflve6qd33ah68>;
        "Mmr": undefined;
        "BeefyMmrLeaf": undefined;
    }>;
    "ConsumerRemaining": undefined;
    "NoProviders": undefined;
    "TooManyConsumers": undefined;
    "Token": TokenError;
    "Arithmetic": ArithmeticError;
    "Transactional": TransactionalError;
    "Exhausted": undefined;
    "Corruption": undefined;
    "Unavailable": undefined;
    "RootNotAllowed": undefined;
    "Trie": Anonymize<Idh4cj79bvroj8>;
}>;
export type I5o0s7c8q1cc9b = AnonymousEnum<{
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     */
    "InvalidSpecName": undefined;
    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     */
    "SpecVersionNeedsToIncrease": undefined;
    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     */
    "FailedToExtractRuntimeVersion": undefined;
    /**
     * Suicide called when the account has non-default composite data.
     */
    "NonDefaultComposite": undefined;
    /**
     * There is a non-zero reference count preventing the account from being purged.
     */
    "NonZeroRefCount": undefined;
    /**
     * The origin filter prevent the call to be dispatched.
     */
    "CallFiltered": undefined;
    /**
     * A multi-block migration is ongoing and prevents the current code from being replaced.
     */
    "MultiBlockMigrationsOngoing": undefined;
    /**
     * No upgrade authorized.
     */
    "NothingAuthorized": undefined;
    /**
     * The submitted code is not authorized.
     */
    "Unauthorized": undefined;
}>;
export type If7oa8fprnilo5 = AnonymousEnum<{
    /**
     * Failed to schedule a call
     */
    "FailedToSchedule": undefined;
    /**
     * Cannot find the scheduled call.
     */
    "NotFound": undefined;
    /**
     * Given target block number is in the past.
     */
    "TargetBlockNumberInPast": undefined;
    /**
     * Reschedule failed because it does not change scheduled time.
     */
    "RescheduleNoChange": undefined;
    /**
     * Attempt to use a non-named function on a named task.
     */
    "Named": undefined;
}>;
export type I4cfhml1prt4lu = AnonymousEnum<{
    /**
     * Preimage is too large to store on-chain.
     */
    "TooBig": undefined;
    /**
     * Preimage has already been noted on-chain.
     */
    "AlreadyNoted": undefined;
    /**
     * The user is not authorized to perform this action.
     */
    "NotAuthorized": undefined;
    /**
     * The preimage cannot be removed since it has not yet been noted.
     */
    "NotNoted": undefined;
    /**
     * A preimage may not be removed when there are outstanding requests.
     */
    "Requested": undefined;
    /**
     * The preimage request cannot be removed since no outstanding requests exist.
     */
    "NotRequested": undefined;
    /**
     * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
     */
    "TooMany": undefined;
    /**
     * Too few hashes were requested to be upgraded (i.e. zero).
     */
    "TooFew": undefined;
}>;
export type Ib6q602k6o213a = AnonymousEnum<{
    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     */
    "InvalidEquivocationProof": undefined;
    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     */
    "InvalidKeyOwnershipProof": undefined;
    /**
     * A given equivocation report is valid but already previously reported.
     */
    "DuplicateOffenceReport": undefined;
    /**
     * Submitted configuration is invalid.
     */
    "InvalidConfiguration": undefined;
}>;
export type Icq1825fru3di2 = AnonymousEnum<{
    /**
     * The index was not already assigned.
     */
    "NotAssigned": undefined;
    /**
     * The index is assigned to another account.
     */
    "NotOwner": undefined;
    /**
     * The index was not available.
     */
    "InUse": undefined;
    /**
     * The source and destination accounts are identical.
     */
    "NotTransfer": undefined;
    /**
     * The index is permanent and may not be freed/changed.
     */
    "Permanent": undefined;
}>;
export type Idj13i7adlomht = AnonymousEnum<{
    /**
     * Vesting balance too high to send value.
     */
    "VestingBalance": undefined;
    /**
     * Account liquidity restrictions prevent withdrawal.
     */
    "LiquidityRestrictions": undefined;
    /**
     * Balance too low to send value.
     */
    "InsufficientBalance": undefined;
    /**
     * Value too low to create account due to existential deposit.
     */
    "ExistentialDeposit": undefined;
    /**
     * Transfer/payment would kill account.
     */
    "Expendability": undefined;
    /**
     * A vesting schedule already exists for this account.
     */
    "ExistingVestingSchedule": undefined;
    /**
     * Beneficiary account must pre-exist.
     */
    "DeadAccount": undefined;
    /**
     * Number of named reserves exceed `MaxReserves`.
     */
    "TooManyReserves": undefined;
    /**
     * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
     */
    "TooManyHolds": undefined;
    /**
     * Number of freezes exceed `MaxFreezes`.
     */
    "TooManyFreezes": undefined;
    /**
     * The issuance cannot be modified since it is already deactivated.
     */
    "IssuanceDeactivated": undefined;
    /**
     * The delta cannot be zero.
     */
    "DeltaZero": undefined;
}>;
export type Ileu8a8k5fbnr = AnonymousEnum<{
    /**
     * Not a controller account.
     */
    "NotController": undefined;
    /**
     * Not a stash account.
     */
    "NotStash": undefined;
    /**
     * Stash is already bonded.
     */
    "AlreadyBonded": undefined;
    /**
     * Controller is already paired.
     */
    "AlreadyPaired": undefined;
    /**
     * Targets cannot be empty.
     */
    "EmptyTargets": undefined;
    /**
     * Duplicate index.
     */
    "DuplicateIndex": undefined;
    /**
     * Slash record index out of bounds.
     */
    "InvalidSlashIndex": undefined;
    /**
     * Cannot have a validator or nominator role, with value less than the minimum defined by
     * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
     * intention, `chill` first to remove one's role as validator/nominator.
     */
    "InsufficientBond": undefined;
    /**
     * Can not schedule more unlock chunks.
     */
    "NoMoreChunks": undefined;
    /**
     * Can not rebond without unlocking chunks.
     */
    "NoUnlockChunk": undefined;
    /**
     * Attempting to target a stash that still has funds.
     */
    "FundedTarget": undefined;
    /**
     * Invalid era to reward.
     */
    "InvalidEraToReward": undefined;
    /**
     * Invalid number of nominations.
     */
    "InvalidNumberOfNominations": undefined;
    /**
     * Items are not sorted and unique.
     */
    "NotSortedAndUnique": undefined;
    /**
     * Rewards for this era have already been claimed for this validator.
     */
    "AlreadyClaimed": undefined;
    /**
     * No nominators exist on this page.
     */
    "InvalidPage": undefined;
    /**
     * Incorrect previous history depth input provided.
     */
    "IncorrectHistoryDepth": undefined;
    /**
     * Incorrect number of slashing spans provided.
     */
    "IncorrectSlashingSpans": undefined;
    /**
     * Internal state has become somehow corrupted and the operation cannot continue.
     */
    "BadState": undefined;
    /**
     * Too many nomination targets supplied.
     */
    "TooManyTargets": undefined;
    /**
     * A nomination target was supplied that was blocked or otherwise not a validator.
     */
    "BadTarget": undefined;
    /**
     * The user has enough bond and thus cannot be chilled forcefully by an external person.
     */
    "CannotChillOther": undefined;
    /**
     * There are too many nominators in the system. Governance needs to adjust the staking
     * settings to keep things safe for the runtime.
     */
    "TooManyNominators": undefined;
    /**
     * There are too many validator candidates in the system. Governance needs to adjust the
     * staking settings to keep things safe for the runtime.
     */
    "TooManyValidators": undefined;
    /**
     * Commission is too low. Must be at least `MinCommission`.
     */
    "CommissionTooLow": undefined;
    /**
     * Some bound is not met.
     */
    "BoundNotMet": undefined;
    /**
     * Used when attempting to use deprecated controller account logic.
     */
    "ControllerDeprecated": undefined;
    /**
     * Cannot reset a ledger.
     */
    "CannotRestoreLedger": undefined;
    /**
     * Provided reward destination is not allowed.
     */
    "RewardDestinationRestricted": undefined;
    /**
     * Not enough funds available to withdraw.
     */
    "NotEnoughFunds": undefined;
    /**
     * Operation not allowed for virtual stakers.
     */
    "VirtualStakerNotAllowed": undefined;
    /**
     * Stash could not be reaped as other pallet might depend on it.
     */
    "CannotReapStash": undefined;
    /**
     * The stake of this account is already migrated to `Fungible` holds.
     */
    "AlreadyMigrated": undefined;
    /**
     * Account is restricted from participation in staking. This may happen if the account is
     * staking in another way already, such as via pool.
     */
    "Restricted": undefined;
}>;
export type I1e07dgbaqd1sq = AnonymousEnum<{
    /**
     * Invalid ownership proof.
     */
    "InvalidProof": undefined;
    /**
     * No associated validator ID for account.
     */
    "NoAssociatedValidatorId": undefined;
    /**
     * Registered duplicate key.
     */
    "DuplicatedKey": undefined;
    /**
     * No keys are associated with this account.
     */
    "NoKeys": undefined;
    /**
     * Key setting account is not live, so it's impossible to associate keys.
     */
    "NoAccount": undefined;
}>;
export type I7q8i0pp1gkas6 = AnonymousEnum<{
    /**
     * Attempt to signal GRANDPA pause when the authority set isn't live
     * (either paused or already pending pause).
     */
    "PauseFailed": undefined;
    /**
     * Attempt to signal GRANDPA resume when the authority set isn't paused
     * (either live or already pending resume).
     */
    "ResumeFailed": undefined;
    /**
     * Attempt to signal GRANDPA change with one already pending.
     */
    "ChangePending": undefined;
    /**
     * Cannot signal forced change so soon after last.
     */
    "TooSoon": undefined;
    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     */
    "InvalidKeyOwnershipProof": undefined;
    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     */
    "InvalidEquivocationProof": undefined;
    /**
     * A given equivocation report is valid but already previously reported.
     */
    "DuplicateOffenceReport": undefined;
}>;
export type I36uss0m9fpcsf = AnonymousEnum<{
    /**
     * No proposal, bounty or spend at that index.
     */
    "InvalidIndex": undefined;
    /**
     * Too many approvals in the queue.
     */
    "TooManyApprovals": undefined;
    /**
     * The spend origin is valid but the amount it is allowed to spend is lower than the
     * amount to be spent.
     */
    "InsufficientPermission": undefined;
    /**
     * Proposal has not been approved.
     */
    "ProposalNotApproved": undefined;
    /**
     * The balance of the asset kind is not convertible to the balance of the native asset.
     */
    "FailedToConvertBalance": undefined;
    /**
     * The spend has expired and cannot be claimed.
     */
    "SpendExpired": undefined;
    /**
     * The spend is not yet eligible for payout.
     */
    "EarlyPayout": undefined;
    /**
     * The payment has already been attempted.
     */
    "AlreadyAttempted": undefined;
    /**
     * There was some issue with the mechanism of payment.
     */
    "PayoutError": undefined;
    /**
     * The payout was not yet attempted/claimed.
     */
    "NotAttempted": undefined;
    /**
     * The payment has neither failed nor succeeded yet.
     */
    "Inconclusive": undefined;
}>;
export type Idfa8k8ikssbsf = AnonymousEnum<{
    /**
     * Poll is not ongoing.
     */
    "NotOngoing": undefined;
    /**
     * The given account did not vote on the poll.
     */
    "NotVoter": undefined;
    /**
     * The actor has no permission to conduct the action.
     */
    "NoPermission": undefined;
    /**
     * The actor has no permission to conduct the action right now but will do in the future.
     */
    "NoPermissionYet": undefined;
    /**
     * The account is already delegating.
     */
    "AlreadyDelegating": undefined;
    /**
     * The account currently has votes attached to it and the operation cannot succeed until
     * these are removed through `remove_vote`.
     */
    "AlreadyVoting": undefined;
    /**
     * Too high a balance was provided that the account cannot afford.
     */
    "InsufficientFunds": undefined;
    /**
     * The account is not currently delegating.
     */
    "NotDelegating": undefined;
    /**
     * Delegation to oneself makes no sense.
     */
    "Nonsense": undefined;
    /**
     * Maximum number of votes reached.
     */
    "MaxVotesReached": undefined;
    /**
     * The class must be supplied since it is not easily determinable from the state.
     */
    "ClassNeeded": undefined;
    /**
     * The class ID supplied is invalid.
     */
    "BadClass": undefined;
}>;
export type I84u4ul208g742 = AnonymousEnum<{
    /**
     * Referendum is not ongoing.
     */
    "NotOngoing": undefined;
    /**
     * Referendum's decision deposit is already paid.
     */
    "HasDeposit": undefined;
    /**
     * The track identifier given was invalid.
     */
    "BadTrack": undefined;
    /**
     * There are already a full complement of referenda in progress for this track.
     */
    "Full": undefined;
    /**
     * The queue of the track is empty.
     */
    "QueueEmpty": undefined;
    /**
     * The referendum index provided is invalid in this context.
     */
    "BadReferendum": undefined;
    /**
     * There was nothing to do in the advancement.
     */
    "NothingToDo": undefined;
    /**
     * No track exists for the proposal origin.
     */
    "NoTrack": undefined;
    /**
     * Any deposit cannot be refunded until after the decision is over.
     */
    "Unfinished": undefined;
    /**
     * The deposit refunder is not the depositor.
     */
    "NoPermission": undefined;
    /**
     * The deposit cannot be refunded since none was made.
     */
    "NoDeposit": undefined;
    /**
     * The referendum status is invalid for this operation.
     */
    "BadStatus": undefined;
    /**
     * The preimage does not exist.
     */
    "PreimageNotExist": undefined;
    /**
     * The preimage is stored with a different length than the one provided.
     */
    "PreimageStoredWithDifferentLength": undefined;
}>;
export type I15nctscutpbeh = AnonymousEnum<{
    /**
     * The preimage of the call hash could not be loaded.
     */
    "UnavailablePreImage": undefined;
    /**
     * The call could not be decoded.
     */
    "UndecodableCall": undefined;
    /**
     * The weight of the decoded call was higher than the witness.
     */
    "InvalidCallWeightWitness": undefined;
    /**
     * The call was not whitelisted.
     */
    "CallIsNotWhitelisted": undefined;
    /**
     * The call was already whitelisted; No-Op.
     */
    "CallAlreadyWhitelisted": undefined;
}>;
export type Ijh2jbbqvb176 = AnonymousEnum<{
    /**
     * Invalid Ethereum signature.
     */
    "InvalidEthereumSignature": undefined;
    /**
     * Ethereum address has no claim.
     */
    "SignerHasNoClaim": undefined;
    /**
     * Account ID sending transaction has no claim.
     */
    "SenderHasNoClaim": undefined;
    /**
     * There's not enough in the pot to pay out some unvested amount. Generally implies a
     * logic error.
     */
    "PotUnderflow": undefined;
    /**
     * A needed statement was not included.
     */
    "InvalidStatement": undefined;
    /**
     * The account already has a vested balance.
     */
    "VestedBalanceExists": undefined;
}>;
export type Icof2acl69lq3c = AnonymousEnum<{
    /**
     * The account given is not vesting.
     */
    "NotVesting": undefined;
    /**
     * The account already has `MaxVestingSchedules` count of schedules and thus
     * cannot add another one. Consider merging existing schedules in order to add another.
     */
    "AtMaxVestingSchedules": undefined;
    /**
     * Amount being transferred is too low to create a vesting schedule.
     */
    "AmountLow": undefined;
    /**
     * An index was out of bounds of the vesting schedules.
     */
    "ScheduleIndexOutOfBounds": undefined;
    /**
     * Failed to create a new schedule because some parameter was invalid.
     */
    "InvalidScheduleParams": undefined;
}>;
export type I8dt2g2hcrgh36 = AnonymousEnum<{
    /**
     * Too many calls batched.
     */
    "TooManyCalls": undefined;
}>;
export type Iuvt54ei4cehc = AnonymousEnum<{
    /**
     * There are too many proxies registered or too many announcements pending.
     */
    "TooMany": undefined;
    /**
     * Proxy registration not found.
     */
    "NotFound": undefined;
    /**
     * Sender is not a proxy of the account to be proxied.
     */
    "NotProxy": undefined;
    /**
     * A call which is incompatible with the proxy type's filter was attempted.
     */
    "Unproxyable": undefined;
    /**
     * Account is already a proxy.
     */
    "Duplicate": undefined;
    /**
     * Call may not be made by proxy because it may escalate its privileges.
     */
    "NoPermission": undefined;
    /**
     * Announcement, if made at all, was made too recently.
     */
    "Unannounced": undefined;
    /**
     * Cannot add self as proxy.
     */
    "NoSelfProxy": undefined;
}>;
export type Ia76qmhhg4jvb9 = AnonymousEnum<{
    /**
     * Threshold must be 2 or greater.
     */
    "MinimumThreshold": undefined;
    /**
     * Call is already approved by this signatory.
     */
    "AlreadyApproved": undefined;
    /**
     * Call doesn't need any (more) approvals.
     */
    "NoApprovalsNeeded": undefined;
    /**
     * There are too few signatories in the list.
     */
    "TooFewSignatories": undefined;
    /**
     * There are too many signatories in the list.
     */
    "TooManySignatories": undefined;
    /**
     * The signatories were provided out of order; they should be ordered.
     */
    "SignatoriesOutOfOrder": undefined;
    /**
     * The sender was contained in the other signatories; it shouldn't be.
     */
    "SenderInSignatories": undefined;
    /**
     * Multisig operation not found in storage.
     */
    "NotFound": undefined;
    /**
     * Only the account that originally created the multisig is able to cancel it or update
     * its deposits.
     */
    "NotOwner": undefined;
    /**
     * No timepoint was given, yet the multisig operation is already underway.
     */
    "NoTimepoint": undefined;
    /**
     * A different timepoint was given to the multisig operation that is underway.
     */
    "WrongTimepoint": undefined;
    /**
     * A timepoint was given, yet no multisig operation is underway.
     */
    "UnexpectedTimepoint": undefined;
    /**
     * The maximum weight information provided was too low.
     */
    "MaxWeightTooLow": undefined;
    /**
     * The data to be stored is already stored.
     */
    "AlreadyStored": undefined;
}>;
export type Ibfvjqqblobf53 = AnonymousEnum<{
    /**
     * Proposer's balance is too low.
     */
    "InsufficientProposersBalance": undefined;
    /**
     * No proposal or bounty at that index.
     */
    "InvalidIndex": undefined;
    /**
     * The reason given is just too big.
     */
    "ReasonTooBig": undefined;
    /**
     * The bounty status is unexpected.
     */
    "UnexpectedStatus": undefined;
    /**
     * Require bounty curator.
     */
    "RequireCurator": undefined;
    /**
     * Invalid bounty value.
     */
    "InvalidValue": undefined;
    /**
     * Invalid bounty fee.
     */
    "InvalidFee": undefined;
    /**
     * A bounty payout is pending.
     * To cancel the bounty, you must unassign and slash the curator.
     */
    "PendingPayout": undefined;
    /**
     * The bounties cannot be claimed/closed because it's still in the countdown period.
     */
    "Premature": undefined;
    /**
     * The bounty cannot be closed because it has active child bounties.
     */
    "HasActiveChildBounty": undefined;
    /**
     * Too many approvals are already queued.
     */
    "TooManyQueued": undefined;
}>;
export type I4u5ou5u3tthff = AnonymousEnum<{
    /**
     * The parent bounty is not in active state.
     */
    "ParentBountyNotActive": undefined;
    /**
     * The bounty balance is not enough to add new child-bounty.
     */
    "InsufficientBountyBalance": undefined;
    /**
     * Number of child bounties exceeds limit `MaxActiveChildBountyCount`.
     */
    "TooManyChildBounties": undefined;
}>;
export type Idb84kfjd998sl = AnonymousEnum<{
    /**
     * Submission was too early.
     */
    "PreDispatchEarlySubmission": undefined;
    /**
     * Wrong number of winners presented.
     */
    "PreDispatchWrongWinnerCount": undefined;
    /**
     * Submission was too weak, score-wise.
     */
    "PreDispatchWeakSubmission": undefined;
    /**
     * The queue was full, and the solution was not better than any of the existing ones.
     */
    "SignedQueueFull": undefined;
    /**
     * The origin failed to pay the deposit.
     */
    "SignedCannotPayDeposit": undefined;
    /**
     * Witness data to dispatchable is invalid.
     */
    "SignedInvalidWitness": undefined;
    /**
     * The signed submission consumes too much weight
     */
    "SignedTooMuchWeight": undefined;
    /**
     * OCW submitted solution for wrong round
     */
    "OcwCallWrongEra": undefined;
    /**
     * Snapshot metadata should exist but didn't.
     */
    "MissingSnapshotMetadata": undefined;
    /**
     * `Self::insert_submission` returned an invalid index.
     */
    "InvalidSubmissionIndex": undefined;
    /**
     * The call is not allowed at this point.
     */
    "CallNotAllowed": undefined;
    /**
     * The fallback failed
     */
    "FallbackFailed": undefined;
    /**
     * Some bound not met
     */
    "BoundNotMet": undefined;
    /**
     * Submitted solution has too many winners
     */
    "TooManyWinners": undefined;
    /**
     * Submission was prepared for a different round.
     */
    "PreDispatchDifferentRound": undefined;
}>;
export type Ic35l5bgiij29p = AnonymousEnum<{
    /**
     * A error in the list interface implementation.
     */
    "List": BagsListListListError;
}>;
export type BagsListListListError = Enum<{
    "Duplicate": undefined;
    "NotHeavier": undefined;
    "NotInSameBag": undefined;
    "NodeNotFound": undefined;
}>;
export declare const BagsListListListError: GetEnum<BagsListListListError>;
export type Iuudu4kursojc = AnonymousEnum<{
    /**
     * A (bonded) pool id does not exist.
     */
    "PoolNotFound": undefined;
    /**
     * An account is not a member.
     */
    "PoolMemberNotFound": undefined;
    /**
     * A reward pool does not exist. In all cases this is a system logic error.
     */
    "RewardPoolNotFound": undefined;
    /**
     * A sub pool does not exist.
     */
    "SubPoolsNotFound": undefined;
    /**
     * An account is already delegating in another pool. An account may only belong to one
     * pool at a time.
     */
    "AccountBelongsToOtherPool": undefined;
    /**
     * The member is fully unbonded (and thus cannot access the bonded and reward pool
     * anymore to, for example, collect rewards).
     */
    "FullyUnbonding": undefined;
    /**
     * The member cannot unbond further chunks due to reaching the limit.
     */
    "MaxUnbondingLimit": undefined;
    /**
     * None of the funds can be withdrawn yet because the bonding duration has not passed.
     */
    "CannotWithdrawAny": undefined;
    /**
     * The amount does not meet the minimum bond to either join or create a pool.
     *
     * The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The
     * caller does not have nominating permissions for the pool. Members can never unbond to a
     * value below `MinJoinBond`.
     */
    "MinimumBondNotMet": undefined;
    /**
     * The transaction could not be executed due to overflow risk for the pool.
     */
    "OverflowRisk": undefined;
    /**
     * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
     * other members to be permissionlessly unbonded.
     */
    "NotDestroying": undefined;
    /**
     * The caller does not have nominating permissions for the pool.
     */
    "NotNominator": undefined;
    /**
     * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
     */
    "NotKickerOrDestroying": undefined;
    /**
     * The pool is not open to join
     */
    "NotOpen": undefined;
    /**
     * The system is maxed out on pools.
     */
    "MaxPools": undefined;
    /**
     * Too many members in the pool or system.
     */
    "MaxPoolMembers": undefined;
    /**
     * The pools state cannot be changed.
     */
    "CanNotChangeState": undefined;
    /**
     * The caller does not have adequate permissions.
     */
    "DoesNotHavePermission": undefined;
    /**
     * Metadata exceeds [`Config::MaxMetadataLen`]
     */
    "MetadataExceedsMaxLen": undefined;
    /**
     * Some error occurred that should never happen. This should be reported to the
     * maintainers.
     */
    "Defensive": Anonymize<Ie2db4l6126rkt>;
    /**
     * Partial unbonding now allowed permissionlessly.
     */
    "PartialUnbondNotAllowedPermissionlessly": undefined;
    /**
     * The pool's max commission cannot be set higher than the existing value.
     */
    "MaxCommissionRestricted": undefined;
    /**
     * The supplied commission exceeds the max allowed commission.
     */
    "CommissionExceedsMaximum": undefined;
    /**
     * The supplied commission exceeds global maximum commission.
     */
    "CommissionExceedsGlobalMaximum": undefined;
    /**
     * Not enough blocks have surpassed since the last commission update.
     */
    "CommissionChangeThrottled": undefined;
    /**
     * The submitted changes to commission change rate are not allowed.
     */
    "CommissionChangeRateNotAllowed": undefined;
    /**
     * There is no pending commission to claim.
     */
    "NoPendingCommission": undefined;
    /**
     * No commission current has been set.
     */
    "NoCommissionCurrentSet": undefined;
    /**
     * Pool id currently in use.
     */
    "PoolIdInUse": undefined;
    /**
     * Pool id provided is not correct/usable.
     */
    "InvalidPoolId": undefined;
    /**
     * Bonding extra is restricted to the exact pending reward amount.
     */
    "BondExtraRestricted": undefined;
    /**
     * No imbalance in the ED deposit for the pool.
     */
    "NothingToAdjust": undefined;
    /**
     * No slash pending that can be applied to the member.
     */
    "NothingToSlash": undefined;
    /**
     * The slash amount is too low to be applied.
     */
    "SlashTooLow": undefined;
    /**
     * The pool or member delegation has already migrated to delegate stake.
     */
    "AlreadyMigrated": undefined;
    /**
     * The pool or member delegation has not migrated yet to delegate stake.
     */
    "NotMigrated": undefined;
    /**
     * This call is not allowed in the current state of the pallet.
     */
    "NotSupported": undefined;
    /**
     * Account is restricted from participation in pools. This may happen if the account is
     * staking in another way already.
     */
    "Restricted": undefined;
}>;
export type Ie2db4l6126rkt = AnonymousEnum<{
    "NotEnoughSpaceInUnbondPool": undefined;
    "PoolNotFound": undefined;
    "RewardPoolNotFound": undefined;
    "SubPoolsNotFound": undefined;
    "BondedStashKilledPrematurely": undefined;
    "DelegationUnsupported": undefined;
    "SlashNotApplied": undefined;
}>;
export type Iau9bur8dc3bec = AnonymousEnum<{
    /**
     * The provided Controller account was not found.
     *
     * This means that the given account is not bonded.
     */
    "NotController": undefined;
    /**
     * The bonded account has already been queued.
     */
    "AlreadyQueued": undefined;
    /**
     * The bonded account has active unlocking chunks.
     */
    "NotFullyBonded": undefined;
    /**
     * The provided un-staker is not in the `Queue`.
     */
    "NotQueued": undefined;
    /**
     * The provided un-staker is already in Head, and cannot deregister.
     */
    "AlreadyHead": undefined;
    /**
     * The call is not allowed at this point because the pallet is not active.
     */
    "CallNotAllowed": undefined;
}>;
export type Iaogv3iimefnis = AnonymousEnum<{
    /**
     * The account cannot perform this operation.
     */
    "NotAllowed": undefined;
    /**
     * An existing staker cannot perform this action.
     */
    "AlreadyStaking": undefined;
    /**
     * Reward Destination cannot be same as `Agent` account.
     */
    "InvalidRewardDestination": undefined;
    /**
     * Delegation conditions are not met.
     *
     * Possible issues are
     * 1) Cannot delegate to self,
     * 2) Cannot delegate to multiple delegates.
     */
    "InvalidDelegation": undefined;
    /**
     * The account does not have enough funds to perform the operation.
     */
    "NotEnoughFunds": undefined;
    /**
     * Not an existing `Agent` account.
     */
    "NotAgent": undefined;
    /**
     * Not a Delegator account.
     */
    "NotDelegator": undefined;
    /**
     * Some corruption in internal state.
     */
    "BadState": undefined;
    /**
     * Unapplied pending slash restricts operation on `Agent`.
     */
    "UnappliedSlash": undefined;
    /**
     * `Agent` has no pending slash to be applied.
     */
    "NothingToSlash": undefined;
    /**
     * Failed to withdraw amount from Core Staking.
     */
    "WithdrawFailed": undefined;
    /**
     * Operation not supported by this pallet.
     */
    "NotSupported": undefined;
}>;
export type In1jctfv299lm = AnonymousEnum<{
    /**
     * The new value for a configuration parameter is invalid.
     */
    "InvalidNewValue": undefined;
}>;
export type I4rrcn97hglfls = AnonymousEnum<{
    /**
     * Validator index out of bounds.
     */
    "ValidatorIndexOutOfBounds": undefined;
    /**
     * Candidate submitted but para not scheduled.
     */
    "UnscheduledCandidate": undefined;
    /**
     * Head data exceeds the configured maximum.
     */
    "HeadDataTooLarge": undefined;
    /**
     * Code upgrade prematurely.
     */
    "PrematureCodeUpgrade": undefined;
    /**
     * Output code is too large
     */
    "NewCodeTooLarge": undefined;
    /**
     * The candidate's relay-parent was not allowed. Either it was
     * not recent enough or it didn't advance based on the last parachain block.
     */
    "DisallowedRelayParent": undefined;
    /**
     * Failed to compute group index for the core: either it's out of bounds
     * or the relay parent doesn't belong to the current session.
     */
    "InvalidAssignment": undefined;
    /**
     * Invalid group index in core assignment.
     */
    "InvalidGroupIndex": undefined;
    /**
     * Insufficient (non-majority) backing.
     */
    "InsufficientBacking": undefined;
    /**
     * Invalid (bad signature, unknown validator, etc.) backing.
     */
    "InvalidBacking": undefined;
    /**
     * The validation data hash does not match expected.
     */
    "ValidationDataHashMismatch": undefined;
    /**
     * The downward message queue is not processed correctly.
     */
    "IncorrectDownwardMessageHandling": undefined;
    /**
     * At least one upward message sent does not pass the acceptance criteria.
     */
    "InvalidUpwardMessages": undefined;
    /**
     * The candidate didn't follow the rules of HRMP watermark advancement.
     */
    "HrmpWatermarkMishandling": undefined;
    /**
     * The HRMP messages sent by the candidate is not valid.
     */
    "InvalidOutboundHrmp": undefined;
    /**
     * The validation code hash of the candidate is not valid.
     */
    "InvalidValidationCodeHash": undefined;
    /**
     * The `para_head` hash in the candidate descriptor doesn't match the hash of the actual
     * para head in the commitments.
     */
    "ParaHeadMismatch": undefined;
}>;
export type I2g8k20rpkqcs4 = AnonymousEnum<{
    /**
     * Inclusion inherent called more than once per block.
     */
    "TooManyInclusionInherents": undefined;
    /**
     * The hash of the submitted parent header doesn't correspond to the saved block hash of
     * the parent.
     */
    "InvalidParentHeader": undefined;
    /**
     * Inherent data was filtered during execution. This should have only been done
     * during creation.
     */
    "InherentDataFilteredDuringExecution": undefined;
    /**
     * Too many candidates supplied.
     */
    "UnscheduledCandidate": undefined;
}>;
export type Ieo97unb4d08rl = AnonymousEnum<{
    /**
     * Para is not registered in our system.
     */
    "NotRegistered": undefined;
    /**
     * Para cannot be onboarded because it is already tracked by our system.
     */
    "CannotOnboard": undefined;
    /**
     * Para cannot be offboarded at this time.
     */
    "CannotOffboard": undefined;
    /**
     * Para cannot be upgraded to a lease holding parachain.
     */
    "CannotUpgrade": undefined;
    /**
     * Para cannot be downgraded to an on-demand parachain.
     */
    "CannotDowngrade": undefined;
    /**
     * The statement for PVF pre-checking is stale.
     */
    "PvfCheckStatementStale": undefined;
    /**
     * The statement for PVF pre-checking is for a future session.
     */
    "PvfCheckStatementFuture": undefined;
    /**
     * Claimed validator index is out of bounds.
     */
    "PvfCheckValidatorIndexOutOfBounds": undefined;
    /**
     * The signature for the PVF pre-checking is invalid.
     */
    "PvfCheckInvalidSignature": undefined;
    /**
     * The given validator already has cast a vote.
     */
    "PvfCheckDoubleVote": undefined;
    /**
     * The given PVF does not exist at the moment of process a vote.
     */
    "PvfCheckSubjectInvalid": undefined;
    /**
     * Parachain cannot currently schedule a code upgrade.
     */
    "CannotUpgradeCode": undefined;
    /**
     * Invalid validation code size.
     */
    "InvalidCode": undefined;
}>;
export type Ibns95nfmm92df = AnonymousEnum<{
    /**
     * The sender tried to open a channel to themselves.
     */
    "OpenHrmpChannelToSelf": undefined;
    /**
     * The recipient is not a valid para.
     */
    "OpenHrmpChannelInvalidRecipient": undefined;
    /**
     * The requested capacity is zero.
     */
    "OpenHrmpChannelZeroCapacity": undefined;
    /**
     * The requested capacity exceeds the global limit.
     */
    "OpenHrmpChannelCapacityExceedsLimit": undefined;
    /**
     * The requested maximum message size is 0.
     */
    "OpenHrmpChannelZeroMessageSize": undefined;
    /**
     * The open request requested the message size that exceeds the global limit.
     */
    "OpenHrmpChannelMessageSizeExceedsLimit": undefined;
    /**
     * The channel already exists
     */
    "OpenHrmpChannelAlreadyExists": undefined;
    /**
     * There is already a request to open the same channel.
     */
    "OpenHrmpChannelAlreadyRequested": undefined;
    /**
     * The sender already has the maximum number of allowed outbound channels.
     */
    "OpenHrmpChannelLimitExceeded": undefined;
    /**
     * The channel from the sender to the origin doesn't exist.
     */
    "AcceptHrmpChannelDoesntExist": undefined;
    /**
     * The channel is already confirmed.
     */
    "AcceptHrmpChannelAlreadyConfirmed": undefined;
    /**
     * The recipient already has the maximum number of allowed inbound channels.
     */
    "AcceptHrmpChannelLimitExceeded": undefined;
    /**
     * The origin tries to close a channel where it is neither the sender nor the recipient.
     */
    "CloseHrmpChannelUnauthorized": undefined;
    /**
     * The channel to be closed doesn't exist.
     */
    "CloseHrmpChannelDoesntExist": undefined;
    /**
     * The channel close request is already requested.
     */
    "CloseHrmpChannelAlreadyUnderway": undefined;
    /**
     * Canceling is requested by neither the sender nor recipient of the open channel request.
     */
    "CancelHrmpOpenChannelUnauthorized": undefined;
    /**
     * The open request doesn't exist.
     */
    "OpenHrmpChannelDoesntExist": undefined;
    /**
     * Cannot cancel an HRMP open channel request because it is already confirmed.
     */
    "OpenHrmpChannelAlreadyConfirmed": undefined;
    /**
     * The provided witness data is wrong.
     */
    "WrongWitness": undefined;
    /**
     * The channel between these two chains cannot be authorized.
     */
    "ChannelCreationNotAuthorized": undefined;
}>;
export type Iakburbqot4g58 = AnonymousEnum<{
    /**
     * Duplicate dispute statement sets provided.
     */
    "DuplicateDisputeStatementSets": undefined;
    /**
     * Ancient dispute statement provided.
     */
    "AncientDisputeStatement": undefined;
    /**
     * Validator index on statement is out of bounds for session.
     */
    "ValidatorIndexOutOfBounds": undefined;
    /**
     * Invalid signature on statement.
     */
    "InvalidSignature": undefined;
    /**
     * Validator vote submitted more than once to dispute.
     */
    "DuplicateStatement": undefined;
    /**
     * A dispute where there are only votes on one side.
     */
    "SingleSidedDispute": undefined;
    /**
     * A dispute vote from a malicious backer.
     */
    "MaliciousBacker": undefined;
    /**
     * No backing votes were provides along dispute statements.
     */
    "MissingBackingVotes": undefined;
    /**
     * Unconfirmed dispute statement sets provided.
     */
    "UnconfirmedDispute": undefined;
}>;
export type I1v70p1j0r2q1j = AnonymousEnum<{
    /**
     * The key ownership proof is invalid.
     */
    "InvalidKeyOwnershipProof": undefined;
    /**
     * The session index is too old or invalid.
     */
    "InvalidSessionIndex": undefined;
    /**
     * The candidate hash is invalid.
     */
    "InvalidCandidateHash": undefined;
    /**
     * There is no pending slash for the given validator index and time
     * slot.
     */
    "InvalidValidatorIndex": undefined;
    /**
     * The validator index does not match the validator id.
     */
    "ValidatorIndexIdMismatch": undefined;
    /**
     * The given slashing report is valid but already previously reported.
     */
    "DuplicateSlashingReport": undefined;
}>;
export type I48hdahgqa1mcd = AnonymousEnum<{
    /**
     * The order queue is full, `place_order` will not continue.
     */
    "QueueFull": undefined;
    /**
     * The current spot price is higher than the max amount specified in the `place_order`
     * call, making it invalid.
     */
    "SpotPriceHigherThanMaxAmount": undefined;
    /**
     * The account doesn't have enough credits to purchase on-demand coretime.
     */
    "InsufficientCredits": undefined;
}>;
export type I2mjnb5vgujeqj = AnonymousEnum<{
    "AssignmentsEmpty": undefined;
    /**
     * assign_core is only allowed to append new assignments at the end of already existing
     * ones or update the last entry.
     */
    "DisallowedInsert": undefined;
}>;
export type I97vkspnd0b8bh = AnonymousEnum<{
    /**
     * The ID is not registered.
     */
    "NotRegistered": undefined;
    /**
     * The ID is already registered.
     */
    "AlreadyRegistered": undefined;
    /**
     * The caller is not the owner of this Id.
     */
    "NotOwner": undefined;
    /**
     * Invalid para code size.
     */
    "CodeTooLarge": undefined;
    /**
     * Invalid para head data size.
     */
    "HeadDataTooLarge": undefined;
    /**
     * Para is not a Parachain.
     */
    "NotParachain": undefined;
    /**
     * Para is not a Parathread (on-demand parachain).
     */
    "NotParathread": undefined;
    /**
     * Cannot deregister para
     */
    "CannotDeregister": undefined;
    /**
     * Cannot schedule downgrade of lease holding parachain to on-demand parachain
     */
    "CannotDowngrade": undefined;
    /**
     * Cannot schedule upgrade of on-demand parachain to lease holding parachain
     */
    "CannotUpgrade": undefined;
    /**
     * Para is locked from manipulation by the manager. Must use parachain or relay chain
     * governance.
     */
    "ParaLocked": undefined;
    /**
     * The ID given for registration has not been reserved.
     */
    "NotReserved": undefined;
    /**
     * The validation code is invalid.
     */
    "InvalidCode": undefined;
    /**
     * Cannot perform a parachain slot / lifecycle swap. Check that the state of both paras
     * are correct for the swap to work.
     */
    "CannotSwap": undefined;
}>;
export type Iers095sa65pbg = AnonymousEnum<{
    /**
     * The parachain ID is not onboarding.
     */
    "ParaNotOnboarding": undefined;
    /**
     * There was an error with the lease.
     */
    "LeaseError": undefined;
}>;
export type I4kgo47o2v3701 = AnonymousEnum<{
    /**
     * This auction is already in progress.
     */
    "AuctionInProgress": undefined;
    /**
     * The lease period is in the past.
     */
    "LeasePeriodInPast": undefined;
    /**
     * Para is not registered
     */
    "ParaNotRegistered": undefined;
    /**
     * Not a current auction.
     */
    "NotCurrentAuction": undefined;
    /**
     * Not an auction.
     */
    "NotAuction": undefined;
    /**
     * Auction has already ended.
     */
    "AuctionEnded": undefined;
    /**
     * The para is already leased out for part of this range.
     */
    "AlreadyLeasedOut": undefined;
}>;
export type I9o6l1c4r4qc3s = AnonymousEnum<{
    /**
     * The current lease period is more than the first lease period.
     */
    "FirstPeriodInPast": undefined;
    /**
     * The first lease period needs to at least be less than 3 `max_value`.
     */
    "FirstPeriodTooFarInFuture": undefined;
    /**
     * Last lease period must be greater than first lease period.
     */
    "LastPeriodBeforeFirstPeriod": undefined;
    /**
     * The last lease period cannot be more than 3 periods after the first period.
     */
    "LastPeriodTooFarInFuture": undefined;
    /**
     * The campaign ends before the current block number. The end must be in the future.
     */
    "CannotEndInPast": undefined;
    /**
     * The end date for this crowdloan is not sensible.
     */
    "EndTooFarInFuture": undefined;
    /**
     * There was an overflow.
     */
    "Overflow": undefined;
    /**
     * The contribution was below the minimum, `MinContribution`.
     */
    "ContributionTooSmall": undefined;
    /**
     * Invalid fund index.
     */
    "InvalidParaId": undefined;
    /**
     * Contributions exceed maximum amount.
     */
    "CapExceeded": undefined;
    /**
     * The contribution period has already ended.
     */
    "ContributionPeriodOver": undefined;
    /**
     * The origin of this call is invalid.
     */
    "InvalidOrigin": undefined;
    /**
     * This crowdloan does not correspond to a parachain.
     */
    "NotParachain": undefined;
    /**
     * This parachain lease is still active and retirement cannot yet begin.
     */
    "LeaseActive": undefined;
    /**
     * This parachain's bid or lease is still active and withdraw cannot yet begin.
     */
    "BidOrLeaseActive": undefined;
    /**
     * The crowdloan has not yet ended.
     */
    "FundNotEnded": undefined;
    /**
     * There are no contributions stored in this crowdloan.
     */
    "NoContributions": undefined;
    /**
     * The crowdloan is not ready to dissolve. Potentially still has a slot or in retirement
     * period.
     */
    "NotReadyToDissolve": undefined;
    /**
     * Invalid signature.
     */
    "InvalidSignature": undefined;
    /**
     * The provided memo is too large.
     */
    "MemoTooLarge": undefined;
    /**
     * The fund is already in `NewRaise`
     */
    "AlreadyInNewRaise": undefined;
    /**
     * No contributions allowed during the VRF delay
     */
    "VrfDelayInProgress": undefined;
    /**
     * A lease period has not started yet, due to an offset in the starting block.
     */
    "NoLeasePeriod": undefined;
}>;
export type Ifju0orssp9h7o = AnonymousEnum<{
    /**
     * The paraid making the call is not the coretime brokerage system parachain.
     */
    "NotBroker": undefined;
    /**
     * Requested revenue information `when` parameter was in the future from the current
     * block height.
     */
    "RequestedFutureRevenue": undefined;
    /**
     * Failed to transfer assets to the coretime chain
     */
    "AssetTransferFailed": undefined;
}>;
export type I96objte63brjr = AnonymousEnum<{
    /**
     * Max signed limits not respected.
     */
    "MaxSignedLimits": undefined;
    /**
     * A key was longer than the configured maximum.
     *
     * This means that the migration halted at the current [`Progress`] and
     * can be resumed with a larger [`crate::Config::MaxKeyLen`] value.
     * Retrying with the same [`crate::Config::MaxKeyLen`] value will not work.
     * The value should only be increased to avoid a storage migration for the currently
     * stored [`crate::Progress::LastKey`].
     */
    "KeyTooLong": undefined;
    /**
     * submitter does not have enough funds.
     */
    "NotEnoughFunds": undefined;
    /**
     * Bad witness data provided.
     */
    "BadWitness": undefined;
    /**
     * Signed migration is not allowed because the maximum limit is not set yet.
     */
    "SignedMigrationNotAllowed": undefined;
    /**
     * Bad child root provided.
     */
    "BadChildRoot": undefined;
}>;
export type I6dl09bpoqheqk = AnonymousEnum<{
    /**
     * The desired destination was unreachable, generally because there is a no way of routing
     * to it.
     */
    "Unreachable": undefined;
    /**
     * There was some other issue (i.e. not to do with routing) in sending the message.
     * Perhaps a lack of space for buffering the message.
     */
    "SendFailure": undefined;
    /**
     * The message execution fails the filter.
     */
    "Filtered": undefined;
    /**
     * The message's weight could not be determined.
     */
    "UnweighableMessage": undefined;
    /**
     * The destination `Location` provided cannot be inverted.
     */
    "DestinationNotInvertible": undefined;
    /**
     * The assets to be sent are empty.
     */
    "Empty": undefined;
    /**
     * Could not re-anchor the assets to declare the fees for the destination chain.
     */
    "CannotReanchor": undefined;
    /**
     * Too many assets have been attempted for transfer.
     */
    "TooManyAssets": undefined;
    /**
     * Origin is invalid for sending.
     */
    "InvalidOrigin": undefined;
    /**
     * The version of the `Versioned` value used is not able to be interpreted.
     */
    "BadVersion": undefined;
    /**
     * The given location could not be used (e.g. because it cannot be expressed in the
     * desired version of XCM).
     */
    "BadLocation": undefined;
    /**
     * The referenced subscription could not be found.
     */
    "NoSubscription": undefined;
    /**
     * The location is invalid since it already has a subscription from us.
     */
    "AlreadySubscribed": undefined;
    /**
     * Could not check-out the assets for teleportation to the destination chain.
     */
    "CannotCheckOutTeleport": undefined;
    /**
     * The owner does not own (all) of the asset that they wish to do the operation on.
     */
    "LowBalance": undefined;
    /**
     * The asset owner has too many locks on the asset.
     */
    "TooManyLocks": undefined;
    /**
     * The given account is not an identifiable sovereign account for any location.
     */
    "AccountNotSovereign": undefined;
    /**
     * The operation required fees to be paid which the initiator could not meet.
     */
    "FeesNotMet": undefined;
    /**
     * A remote lock with the corresponding data could not be found.
     */
    "LockNotFound": undefined;
    /**
     * The unlock operation cannot succeed because there are still consumers of the lock.
     */
    "InUse": undefined;
    /**
     * Invalid asset, reserve chain could not be determined for it.
     */
    "InvalidAssetUnknownReserve": undefined;
    /**
     * Invalid asset, do not support remote asset reserves with different fees reserves.
     */
    "InvalidAssetUnsupportedReserve": undefined;
    /**
     * Too many assets with different reserve locations have been attempted for transfer.
     */
    "TooManyReserves": undefined;
    /**
     * Local XCM execution incomplete.
     */
    "LocalExecutionIncomplete": undefined;
    /**
     * Too many locations authorized to alias origin.
     */
    "TooManyAuthorizedAliases": undefined;
    /**
     * Expiry block number is in the past.
     */
    "ExpiresInPast": undefined;
    /**
     * The alias to remove authorization for was not found.
     */
    "AliasNotFound": undefined;
}>;
export type I5iupade5ag2dp = AnonymousEnum<{
    /**
     * Page is not reapable because it has items remaining to be processed and is not old
     * enough.
     */
    "NotReapable": undefined;
    /**
     * Page to be reaped does not exist.
     */
    "NoPage": undefined;
    /**
     * The referenced message could not be found.
     */
    "NoMessage": undefined;
    /**
     * The message was already processed and cannot be processed again.
     */
    "AlreadyProcessed": undefined;
    /**
     * The message is queued for future execution.
     */
    "Queued": undefined;
    /**
     * There is temporarily not enough weight to continue servicing messages.
     */
    "InsufficientWeight": undefined;
    /**
     * This message is temporarily unprocessable.
     *
     * Such errors are expected, but not guaranteed, to resolve themselves eventually through
     * retrying.
     */
    "TemporarilyUnprocessable": undefined;
    /**
     * The queue is paused and no message can be executed from it.
     *
     * This can change at any time and may resolve in the future by re-trying.
     */
    "QueuePaused": undefined;
    /**
     * Another call is in progress and needs to finish before this call can happen.
     */
    "RecursiveDisallowed": undefined;
}>;
export type I3qgd61cgli6cp = AnonymousEnum<{
    /**
     * The given asset ID is unknown.
     */
    "UnknownAssetKind": undefined;
    /**
     * The given asset ID already has an assigned conversion rate and cannot be re-created.
     */
    "AlreadyExists": undefined;
    /**
     * Overflow ocurred when calculating the inverse rate.
     */
    "Overflow": undefined;
}>;
export type Iflve6qd33ah68 = AnonymousEnum<{
    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     */
    "InvalidKeyOwnershipProof": undefined;
    /**
     * A double voting proof provided as part of an equivocation report is invalid.
     */
    "InvalidDoubleVotingProof": undefined;
    /**
     * A fork voting proof provided as part of an equivocation report is invalid.
     */
    "InvalidForkVotingProof": undefined;
    /**
     * A future block voting proof provided as part of an equivocation report is invalid.
     */
    "InvalidFutureBlockVotingProof": undefined;
    /**
     * The session of the equivocation proof is invalid
     */
    "InvalidEquivocationProofSession": undefined;
    /**
     * A given equivocation report is valid but already previously reported.
     */
    "DuplicateOffenceReport": undefined;
    /**
     * Submitted configuration is invalid.
     */
    "InvalidConfiguration": undefined;
}>;
export type TokenError = Enum<{
    "FundsUnavailable": undefined;
    "OnlyProvider": undefined;
    "BelowMinimum": undefined;
    "CannotCreate": undefined;
    "UnknownAsset": undefined;
    "Frozen": undefined;
    "Unsupported": undefined;
    "CannotCreateHold": undefined;
    "NotExpendable": undefined;
    "Blocked": undefined;
}>;
export declare const TokenError: GetEnum<TokenError>;
export type ArithmeticError = Enum<{
    "Underflow": undefined;
    "Overflow": undefined;
    "DivisionByZero": undefined;
}>;
export declare const ArithmeticError: GetEnum<ArithmeticError>;
export type TransactionalError = Enum<{
    "LimitReached": undefined;
    "NoLayer": undefined;
}>;
export declare const TransactionalError: GetEnum<TransactionalError>;
export type Idh4cj79bvroj8 = AnonymousEnum<{
    "InvalidStateRoot": undefined;
    "IncompleteDatabase": undefined;
    "ValueAtIncompleteKey": undefined;
    "DecoderError": undefined;
    "InvalidHash": undefined;
    "DuplicateKey": undefined;
    "ExtraneousNode": undefined;
    "ExtraneousValue": undefined;
    "ExtraneousHashReference": undefined;
    "InvalidChildReference": undefined;
    "ValueMismatch": undefined;
    "IncompleteProof": undefined;
    "RootMismatch": undefined;
    "DecodeError": undefined;
}>;
export type Icbccs0ug47ilf = {
    "account": SS58String;
};
export type I855j4i3kr8ko1 = {
    "sender": SS58String;
    "hash": FixedSizeBinary<32>;
};
export type Ibgl04rn6nbfm6 = {
    "code_hash": FixedSizeBinary<32>;
    "check_version": boolean;
};
export type I7hp0ibc3qanbd = {
    "code_hash": FixedSizeBinary<32>;
    "error": Anonymize<I3rv535b81c0ac>;
};
export type I4o7o5getfhvm5 = AnonymousEnum<{
    /**
     * Scheduled some task.
     */
    "Scheduled": Anonymize<I5n4sebgkfr760>;
    /**
     * Canceled some task.
     */
    "Canceled": Anonymize<I5n4sebgkfr760>;
    /**
     * Dispatched some task.
     */
    "Dispatched": Anonymize<Ifql10h3d3vccc>;
    /**
     * Set a retry configuration for some task.
     */
    "RetrySet": Anonymize<Ia3c82eadg79bj>;
    /**
     * Cancel a retry configuration for some task.
     */
    "RetryCancelled": Anonymize<Ienusoeb625ftq>;
    /**
     * The call for the provided hash was not found so the task has been aborted.
     */
    "CallUnavailable": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task was unable to be renewed since the agenda is full at that block.
     */
    "PeriodicFailed": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task was unable to be retried since the agenda is full at that block or there
     * was not enough weight to reschedule it.
     */
    "RetryFailed": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task can never be executed since it is overweight.
     */
    "PermanentlyOverweight": Anonymize<Ienusoeb625ftq>;
    /**
     * Agenda is incomplete from `when`.
     */
    "AgendaIncomplete": Anonymize<Ibtsa3docbr9el>;
}>;
export type I5n4sebgkfr760 = {
    "when": number;
    "index": number;
};
export type Ifql10h3d3vccc = {
    "task": Anonymize<I9jd27rnpm8ttv>;
    "id"?: Anonymize<I4s6vifaf8k998>;
    "result": Anonymize<I7jgmvdrn822de>;
};
export type I9jd27rnpm8ttv = FixedSizeArray<2, number>;
export type I4s6vifaf8k998 = (FixedSizeBinary<32>) | undefined;
export type I7jgmvdrn822de = ResultPayload<undefined, Anonymize<I3rv535b81c0ac>>;
export type Ia3c82eadg79bj = {
    "task": Anonymize<I9jd27rnpm8ttv>;
    "id"?: Anonymize<I4s6vifaf8k998>;
    "period": number;
    "retries": number;
};
export type Ienusoeb625ftq = {
    "task": Anonymize<I9jd27rnpm8ttv>;
    "id"?: Anonymize<I4s6vifaf8k998>;
};
export type Ibtsa3docbr9el = {
    "when": number;
};
export type PreimageEvent = Enum<{
    /**
     * A preimage has been noted.
     */
    "Noted": Anonymize<I1jm8m1rh9e20v>;
    /**
     * A preimage has been requested.
     */
    "Requested": Anonymize<I1jm8m1rh9e20v>;
    /**
     * A preimage has ben cleared.
     */
    "Cleared": Anonymize<I1jm8m1rh9e20v>;
}>;
export declare const PreimageEvent: GetEnum<PreimageEvent>;
export type I1jm8m1rh9e20v = {
    "hash": FixedSizeBinary<32>;
};
export type I2pejk6do5vg4t = AnonymousEnum<{
    /**
     * A account index was assigned.
     */
    "IndexAssigned": Anonymize<Ia1u3jll6a06ae>;
    /**
     * A account index has been freed up (unassigned).
     */
    "IndexFreed": Anonymize<I666bl2fqjkejo>;
    /**
     * A account index has been frozen to its current account ID.
     */
    "IndexFrozen": Anonymize<Ia1u3jll6a06ae>;
    /**
     * A deposit to reserve an index has been poked/reconsidered.
     */
    "DepositPoked": Anonymize<Ic9g5lvl9iddc5>;
}>;
export type Ia1u3jll6a06ae = {
    "who": SS58String;
    "index": number;
};
export type I666bl2fqjkejo = {
    "index": number;
};
export type Ic9g5lvl9iddc5 = {
    "who": SS58String;
    "index": number;
    "old_deposit": bigint;
    "new_deposit": bigint;
};
export type Iao8h4hv7atnq3 = AnonymousEnum<{
    /**
     * An account was created with some free balance.
     */
    "Endowed": Anonymize<Icv68aq8841478>;
    /**
     * An account was removed whose balance was non-zero but below ExistentialDeposit,
     * resulting in an outright loss.
     */
    "DustLost": Anonymize<Ic262ibdoec56a>;
    /**
     * Transfer succeeded.
     */
    "Transfer": Anonymize<Iflcfm9b6nlmdd>;
    /**
     * A balance was set by root.
     */
    "BalanceSet": Anonymize<Ijrsf4mnp3eka>;
    /**
     * Some balance was reserved (moved from free to reserved).
     */
    "Reserved": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * Some balance was unreserved (moved from reserved to free).
     */
    "Unreserved": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * Some balance was moved from the reserve of the first account to the second account.
     * Final argument indicates the destination balance type.
     */
    "ReserveRepatriated": Anonymize<I8tjvj9uq4b7hi>;
    /**
     * Some amount was deposited (e.g. for transaction fees).
     */
    "Deposit": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * Some amount was withdrawn from the account (e.g. for transaction fees).
     */
    "Withdraw": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * Some amount was removed from the account (e.g. for misbehavior).
     */
    "Slashed": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * Some amount was minted into an account.
     */
    "Minted": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * Some amount was burned from an account.
     */
    "Burned": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * Some amount was suspended from an account (it can be restored later).
     */
    "Suspended": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * Some amount was restored into an account.
     */
    "Restored": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * An account was upgraded.
     */
    "Upgraded": Anonymize<I4cbvqmqadhrea>;
    /**
     * Total issuance was increased by `amount`, creating a credit to be balanced.
     */
    "Issued": Anonymize<I3qt1hgg4djhgb>;
    /**
     * Total issuance was decreased by `amount`, creating a debt to be balanced.
     */
    "Rescinded": Anonymize<I3qt1hgg4djhgb>;
    /**
     * Some balance was locked.
     */
    "Locked": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * Some balance was unlocked.
     */
    "Unlocked": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * Some balance was frozen.
     */
    "Frozen": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * Some balance was thawed.
     */
    "Thawed": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * The `TotalIssuance` was forcefully changed.
     */
    "TotalIssuanceForced": Anonymize<I4fooe9dun9o0t>;
}>;
export type Icv68aq8841478 = {
    "account": SS58String;
    "free_balance": bigint;
};
export type Ic262ibdoec56a = {
    "account": SS58String;
    "amount": bigint;
};
export type Iflcfm9b6nlmdd = {
    "from": SS58String;
    "to": SS58String;
    "amount": bigint;
};
export type Ijrsf4mnp3eka = {
    "who": SS58String;
    "free": bigint;
};
export type Id5fm4p8lj5qgi = {
    "who": SS58String;
    "amount": bigint;
};
export type I8tjvj9uq4b7hi = {
    "from": SS58String;
    "to": SS58String;
    "amount": bigint;
    "destination_status": BalanceStatus;
};
export type BalanceStatus = Enum<{
    "Free": undefined;
    "Reserved": undefined;
}>;
export declare const BalanceStatus: GetEnum<BalanceStatus>;
export type I4cbvqmqadhrea = {
    "who": SS58String;
};
export type I3qt1hgg4djhgb = {
    "amount": bigint;
};
export type I4fooe9dun9o0t = {
    "old": bigint;
    "new": bigint;
};
export type TransactionPaymentEvent = Enum<{
    /**
     * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
     * has been paid by `who`.
     */
    "TransactionFeePaid": Anonymize<Ier2cke86dqbr2>;
}>;
export declare const TransactionPaymentEvent: GetEnum<TransactionPaymentEvent>;
export type Ier2cke86dqbr2 = {
    "who": SS58String;
    "actual_fee": bigint;
    "tip": bigint;
};
export type I8n4qjnlkvth8n = AnonymousEnum<{
    /**
     * The era payout has been set; the first balance is the validator-payout; the second is
     * the remainder from the maximum amount of reward.
     */
    "EraPaid": Anonymize<I1au3fq4n84nv3>;
    /**
     * The nominator has been rewarded by this amount to this destination.
     */
    "Rewarded": Anonymize<Iejaj7m7qka9tr>;
    /**
     * A staker (validator or nominator) has been slashed by the given amount.
     */
    "Slashed": Anonymize<Idnak900lt5lm8>;
    /**
     * A slash for the given validator, for the given percentage of their stake, at the given
     * era as been reported.
     */
    "SlashReported": Anonymize<I27n7lbd66730p>;
    /**
     * An old slashing report from a prior era was discarded because it could
     * not be processed.
     */
    "OldSlashingReportDiscarded": Anonymize<I2hq50pu2kdjpo>;
    /**
     * A new set of stakers was elected.
     */
    "StakersElected": undefined;
    /**
     * An account has bonded this amount. \[stash, amount\]
     *
     * NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
     * it will not be emitted for staking rewards when they are added to stake.
     */
    "Bonded": Anonymize<Ifk8eme5o7mukf>;
    /**
     * An account has unbonded this amount.
     */
    "Unbonded": Anonymize<Ifk8eme5o7mukf>;
    /**
     * An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
     * from the unlocking queue.
     */
    "Withdrawn": Anonymize<Ifk8eme5o7mukf>;
    /**
     * A nominator has been kicked from a validator.
     */
    "Kicked": Anonymize<Iau4cgm6ih61cf>;
    /**
     * The election failed. No new era is planned.
     */
    "StakingElectionFailed": undefined;
    /**
     * An account has stopped participating as either a validator or nominator.
     */
    "Chilled": Anonymize<Idl3umm12u5pa>;
    /**
     * A Page of stakers rewards are getting paid. `next` is `None` if all pages are claimed.
     */
    "PayoutStarted": Anonymize<Ith132hqfb27q>;
    /**
     * A validator has set their preferences.
     */
    "ValidatorPrefsSet": Anonymize<Ic19as7nbst738>;
    /**
     * Voters size limit reached.
     */
    "SnapshotVotersSizeExceeded": Anonymize<I54umskavgc9du>;
    /**
     * Targets size limit reached.
     */
    "SnapshotTargetsSizeExceeded": Anonymize<I54umskavgc9du>;
    /**
     * A new force era mode was set.
     */
    "ForceEra": Anonymize<I2ip7o9e2tc5sf>;
    /**
     * Report of a controller batch deprecation.
     */
    "ControllerBatchDeprecated": Anonymize<I5egvk6hadac5h>;
    /**
     * Staking balance migrated from locks to holds, with any balance that could not be held
     * is force withdrawn.
     */
    "CurrencyMigrated": Anonymize<I1td4upnup9gqv>;
}>;
export type I1au3fq4n84nv3 = {
    "era_index": number;
    "validator_payout": bigint;
    "remainder": bigint;
};
export type Iejaj7m7qka9tr = {
    "stash": SS58String;
    "dest": StakingRewardDestination;
    "amount": bigint;
};
export type StakingRewardDestination = Enum<{
    "Staked": undefined;
    "Stash": undefined;
    "Controller": undefined;
    "Account": SS58String;
    "None": undefined;
}>;
export declare const StakingRewardDestination: GetEnum<StakingRewardDestination>;
export type Idnak900lt5lm8 = {
    "staker": SS58String;
    "amount": bigint;
};
export type I27n7lbd66730p = {
    "validator": SS58String;
    "fraction": number;
    "slash_era": number;
};
export type I2hq50pu2kdjpo = {
    "session_index": number;
};
export type Ifk8eme5o7mukf = {
    "stash": SS58String;
    "amount": bigint;
};
export type Iau4cgm6ih61cf = {
    "nominator": SS58String;
    "stash": SS58String;
};
export type Idl3umm12u5pa = {
    "stash": SS58String;
};
export type Ith132hqfb27q = {
    "era_index": number;
    "validator_stash": SS58String;
    "page": number;
    "next"?: Anonymize<I4arjljr6dpflb>;
};
export type I4arjljr6dpflb = (number) | undefined;
export type Ic19as7nbst738 = {
    "stash": SS58String;
    "prefs": Anonymize<I9o7ssi9vmhmgr>;
};
export type I9o7ssi9vmhmgr = {
    "commission": number;
    "blocked": boolean;
};
export type I54umskavgc9du = {
    "size": number;
};
export type I2ip7o9e2tc5sf = {
    "mode": StakingForcing;
};
export type StakingForcing = Enum<{
    "NotForcing": undefined;
    "ForceNew": undefined;
    "ForceNone": undefined;
    "ForceAlways": undefined;
}>;
export declare const StakingForcing: GetEnum<StakingForcing>;
export type I5egvk6hadac5h = {
    "failures": number;
};
export type I1td4upnup9gqv = {
    "stash": SS58String;
    "force_withdraw": bigint;
};
export type OffencesEvent = Enum<{
    /**
     * There is an offence reported of the given `kind` happened at the `session_index` and
     * (kind-specific) time slot. This event is not deposited for duplicate slashes.
     * \[kind, timeslot\].
     */
    "Offence": Anonymize<Iempvdlhc5ih6g>;
}>;
export declare const OffencesEvent: GetEnum<OffencesEvent>;
export type Iempvdlhc5ih6g = {
    "kind": FixedSizeBinary<16>;
    "timeslot": Binary;
};
export type I4co4bgsti676q = AnonymousEnum<{
    /**
     * New session has happened. Note that the argument is the session index, not the
     * block number as the type might suggest.
     */
    "NewSession": Anonymize<I2hq50pu2kdjpo>;
    /**
     * Validator has been disabled.
     */
    "ValidatorDisabled": Anonymize<I9acqruh7322g2>;
    /**
     * Validator has been re-enabled.
     */
    "ValidatorReenabled": Anonymize<I9acqruh7322g2>;
}>;
export type I9acqruh7322g2 = {
    "validator": SS58String;
};
export type GrandpaEvent = Enum<{
    /**
     * New authority set has been applied.
     */
    "NewAuthorities": Anonymize<I5768ac424h061>;
    /**
     * Current authority set has been paused.
     */
    "Paused": undefined;
    /**
     * Current authority set has been resumed.
     */
    "Resumed": undefined;
}>;
export declare const GrandpaEvent: GetEnum<GrandpaEvent>;
export type I5768ac424h061 = {
    "authority_set": Anonymize<I3geksg000c171>;
};
export type I3geksg000c171 = Array<[FixedSizeBinary<32>, bigint]>;
export type Ia1b9fjuj0ob0b = AnonymousEnum<{
    /**
     * We have ended a spend period and will now allocate funds.
     */
    "Spending": Anonymize<I8iksqi3eani0a>;
    /**
     * Some funds have been allocated.
     */
    "Awarded": Anonymize<I16enopmju1p0q>;
    /**
     * Some of our funds have been burnt.
     */
    "Burnt": Anonymize<I43kq8qudg7pq9>;
    /**
     * Spending has finished; this is the amount that rolls over until next spend.
     */
    "Rollover": Anonymize<I76riseemre533>;
    /**
     * Some funds have been deposited.
     */
    "Deposit": Anonymize<Ie5v6njpckr05b>;
    /**
     * A new spend proposal has been approved.
     */
    "SpendApproved": Anonymize<I38bmcrmh852rk>;
    /**
     * The inactive funds of the pallet have been updated.
     */
    "UpdatedInactive": Anonymize<I4hcillge8de5f>;
    /**
     * A new asset spend proposal has been approved.
     */
    "AssetSpendApproved": Anonymize<I2cftk5tgrglaa>;
    /**
     * An approved spend was voided.
     */
    "AssetSpendVoided": Anonymize<I666bl2fqjkejo>;
    /**
     * A payment happened.
     */
    "Paid": Anonymize<Iek7v4hrgnq6iv>;
    /**
     * A payment failed and can be retried.
     */
    "PaymentFailed": Anonymize<Iek7v4hrgnq6iv>;
    /**
     * A spend was processed and removed from the storage. It might have been successfully
     * paid or it may have expired.
     */
    "SpendProcessed": Anonymize<I666bl2fqjkejo>;
}>;
export type I8iksqi3eani0a = {
    "budget_remaining": bigint;
};
export type I16enopmju1p0q = {
    "proposal_index": number;
    "award": bigint;
    "account": SS58String;
};
export type I43kq8qudg7pq9 = {
    "burnt_funds": bigint;
};
export type I76riseemre533 = {
    "rollover_balance": bigint;
};
export type Ie5v6njpckr05b = {
    "value": bigint;
};
export type I38bmcrmh852rk = {
    "proposal_index": number;
    "amount": bigint;
    "beneficiary": SS58String;
};
export type I4hcillge8de5f = {
    "reactivated": bigint;
    "deactivated": bigint;
};
export type I2cftk5tgrglaa = {
    "index": number;
    "asset_kind": Anonymize<I2q3ri6itcjj5u>;
    "amount": bigint;
    "beneficiary": XcmVersionedLocation;
    "valid_from": number;
    "expire_at": number;
};
export type I2q3ri6itcjj5u = AnonymousEnum<{
    "V3": {
        "location": Anonymize<I4c0s5cioidn76>;
        "asset_id": XcmV3MultiassetAssetId;
    };
    "V4": {
        "location": Anonymize<I4c0s5cioidn76>;
        "asset_id": Anonymize<I4c0s5cioidn76>;
    };
    "V5": {
        "location": Anonymize<If9iqq7i64mur8>;
        "asset_id": Anonymize<If9iqq7i64mur8>;
    };
}>;
export type I4c0s5cioidn76 = {
    "parents": number;
    "interior": XcmV3Junctions;
};
export type XcmV3Junctions = Enum<{
    "Here": undefined;
    "X1": XcmV3Junction;
    "X2": FixedSizeArray<2, XcmV3Junction>;
    "X3": FixedSizeArray<3, XcmV3Junction>;
    "X4": FixedSizeArray<4, XcmV3Junction>;
    "X5": FixedSizeArray<5, XcmV3Junction>;
    "X6": FixedSizeArray<6, XcmV3Junction>;
    "X7": FixedSizeArray<7, XcmV3Junction>;
    "X8": FixedSizeArray<8, XcmV3Junction>;
}>;
export declare const XcmV3Junctions: GetEnum<XcmV3Junctions>;
export type XcmV3Junction = Enum<{
    "Parachain": number;
    "AccountId32": {
        "network"?: Anonymize<Idcq3vns9tgp5p>;
        "id": FixedSizeBinary<32>;
    };
    "AccountIndex64": {
        "network"?: Anonymize<Idcq3vns9tgp5p>;
        "index": bigint;
    };
    "AccountKey20": {
        "network"?: Anonymize<Idcq3vns9tgp5p>;
        "key": FixedSizeBinary<20>;
    };
    "PalletInstance": number;
    "GeneralIndex": bigint;
    "GeneralKey": Anonymize<I15lht6t53odo4>;
    "OnlyChild": undefined;
    "Plurality": Anonymize<I518fbtnclg1oc>;
    "GlobalConsensus": XcmV3JunctionNetworkId;
}>;
export declare const XcmV3Junction: GetEnum<XcmV3Junction>;
export type Idcq3vns9tgp5p = (XcmV3JunctionNetworkId) | undefined;
export type XcmV3JunctionNetworkId = Enum<{
    "ByGenesis": FixedSizeBinary<32>;
    "ByFork": Anonymize<I15vf5oinmcgps>;
    "Polkadot": undefined;
    "Kusama": undefined;
    "Westend": undefined;
    "Rococo": undefined;
    "Wococo": undefined;
    "Ethereum": Anonymize<I623eo8t3jrbeo>;
    "BitcoinCore": undefined;
    "BitcoinCash": undefined;
    "PolkadotBulletin": undefined;
}>;
export declare const XcmV3JunctionNetworkId: GetEnum<XcmV3JunctionNetworkId>;
export type I15vf5oinmcgps = {
    "block_number": bigint;
    "block_hash": FixedSizeBinary<32>;
};
export type I623eo8t3jrbeo = {
    "chain_id": bigint;
};
export type I15lht6t53odo4 = {
    "length": number;
    "data": FixedSizeBinary<32>;
};
export type I518fbtnclg1oc = {
    "id": XcmV3JunctionBodyId;
    "part": XcmV2JunctionBodyPart;
};
export type XcmV3JunctionBodyId = Enum<{
    "Unit": undefined;
    "Moniker": FixedSizeBinary<4>;
    "Index": number;
    "Executive": undefined;
    "Technical": undefined;
    "Legislative": undefined;
    "Judicial": undefined;
    "Defense": undefined;
    "Administration": undefined;
    "Treasury": undefined;
}>;
export declare const XcmV3JunctionBodyId: GetEnum<XcmV3JunctionBodyId>;
export type XcmV2JunctionBodyPart = Enum<{
    "Voice": undefined;
    "Members": Anonymize<Iafscmv8tjf0ou>;
    "Fraction": {
        "nom": number;
        "denom": number;
    };
    "AtLeastProportion": {
        "nom": number;
        "denom": number;
    };
    "MoreThanProportion": {
        "nom": number;
        "denom": number;
    };
}>;
export declare const XcmV2JunctionBodyPart: GetEnum<XcmV2JunctionBodyPart>;
export type Iafscmv8tjf0ou = {
    "count": number;
};
export type XcmV3MultiassetAssetId = Enum<{
    "Concrete": Anonymize<I4c0s5cioidn76>;
    "Abstract": FixedSizeBinary<32>;
}>;
export declare const XcmV3MultiassetAssetId: GetEnum<XcmV3MultiassetAssetId>;
export type If9iqq7i64mur8 = {
    "parents": number;
    "interior": XcmV5Junctions;
};
export type XcmV5Junctions = Enum<{
    "Here": undefined;
    "X1": XcmV5Junction;
    "X2": FixedSizeArray<2, XcmV5Junction>;
    "X3": FixedSizeArray<3, XcmV5Junction>;
    "X4": FixedSizeArray<4, XcmV5Junction>;
    "X5": FixedSizeArray<5, XcmV5Junction>;
    "X6": FixedSizeArray<6, XcmV5Junction>;
    "X7": FixedSizeArray<7, XcmV5Junction>;
    "X8": FixedSizeArray<8, XcmV5Junction>;
}>;
export declare const XcmV5Junctions: GetEnum<XcmV5Junctions>;
export type XcmV5Junction = Enum<{
    "Parachain": number;
    "AccountId32": {
        "network"?: Anonymize<I97pd2rst02a7r>;
        "id": FixedSizeBinary<32>;
    };
    "AccountIndex64": {
        "network"?: Anonymize<I97pd2rst02a7r>;
        "index": bigint;
    };
    "AccountKey20": {
        "network"?: Anonymize<I97pd2rst02a7r>;
        "key": FixedSizeBinary<20>;
    };
    "PalletInstance": number;
    "GeneralIndex": bigint;
    "GeneralKey": Anonymize<I15lht6t53odo4>;
    "OnlyChild": undefined;
    "Plurality": Anonymize<I518fbtnclg1oc>;
    "GlobalConsensus": XcmV5NetworkId;
}>;
export declare const XcmV5Junction: GetEnum<XcmV5Junction>;
export type I97pd2rst02a7r = (XcmV5NetworkId) | undefined;
export type XcmV5NetworkId = Enum<{
    "ByGenesis": FixedSizeBinary<32>;
    "ByFork": Anonymize<I15vf5oinmcgps>;
    "Polkadot": undefined;
    "Kusama": undefined;
    "Ethereum": Anonymize<I623eo8t3jrbeo>;
    "BitcoinCore": undefined;
    "BitcoinCash": undefined;
    "PolkadotBulletin": undefined;
}>;
export declare const XcmV5NetworkId: GetEnum<XcmV5NetworkId>;
export type XcmVersionedLocation = Enum<{
    "V3": Anonymize<I4c0s5cioidn76>;
    "V4": Anonymize<I4c0s5cioidn76>;
    "V5": Anonymize<If9iqq7i64mur8>;
}>;
export declare const XcmVersionedLocation: GetEnum<XcmVersionedLocation>;
export type Iek7v4hrgnq6iv = {
    "index": number;
    "payment_id": bigint;
};
export type I7tvgbf73o5td4 = AnonymousEnum<{
    /**
     * An account has delegated their vote to another account. \[who, target\]
     */
    "Delegated": Anonymize<I2na29tt2afp0j>;
    /**
     * An \[account\] has cancelled a previous delegation operation.
     */
    "Undelegated": SS58String;
    /**
     * An account has voted
     */
    "Voted": Anonymize<I9qfchhljqsjjl>;
    /**
     * A vote has been removed
     */
    "VoteRemoved": Anonymize<I9qfchhljqsjjl>;
    /**
     * The lockup period of a conviction vote expired, and the funds have been unlocked.
     */
    "VoteUnlocked": Anonymize<I7kij8p9kchdjo>;
}>;
export type I2na29tt2afp0j = FixedSizeArray<2, SS58String>;
export type I9qfchhljqsjjl = {
    "who": SS58String;
    "vote": ConvictionVotingVoteAccountVote;
};
export type ConvictionVotingVoteAccountVote = Enum<{
    "Standard": Anonymize<Ib024p97ls1cla>;
    "Split": Anonymize<I5pi71t9bosoiv>;
    "SplitAbstain": {
        "aye": bigint;
        "nay": bigint;
        "abstain": bigint;
    };
}>;
export declare const ConvictionVotingVoteAccountVote: GetEnum<ConvictionVotingVoteAccountVote>;
export type Ib024p97ls1cla = {
    "vote": number;
    "balance": bigint;
};
export type I5pi71t9bosoiv = {
    "aye": bigint;
    "nay": bigint;
};
export type I7kij8p9kchdjo = {
    "who": SS58String;
    "class": number;
};
export type Idfraa3b4eu018 = AnonymousEnum<{
    /**
     * A referendum has been submitted.
     */
    "Submitted": Anonymize<I229ijht536qdu>;
    /**
     * The decision deposit has been placed.
     */
    "DecisionDepositPlaced": Anonymize<I62nte77gksm0f>;
    /**
     * The decision deposit has been refunded.
     */
    "DecisionDepositRefunded": Anonymize<I62nte77gksm0f>;
    /**
     * A deposit has been slashed.
     */
    "DepositSlashed": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * A referendum has moved into the deciding phase.
     */
    "DecisionStarted": Anonymize<I9cg2delv92pvq>;
    "ConfirmStarted": Anonymize<I666bl2fqjkejo>;
    "ConfirmAborted": Anonymize<I666bl2fqjkejo>;
    /**
     * A referendum has ended its confirmation phase and is ready for approval.
     */
    "Confirmed": Anonymize<Ilhp45uime5tp>;
    /**
     * A referendum has been approved and its proposal has been scheduled.
     */
    "Approved": Anonymize<I666bl2fqjkejo>;
    /**
     * A proposal has been rejected by referendum.
     */
    "Rejected": Anonymize<Ilhp45uime5tp>;
    /**
     * A referendum has been timed out without being decided.
     */
    "TimedOut": Anonymize<Ilhp45uime5tp>;
    /**
     * A referendum has been cancelled.
     */
    "Cancelled": Anonymize<Ilhp45uime5tp>;
    /**
     * A referendum has been killed.
     */
    "Killed": Anonymize<Ilhp45uime5tp>;
    /**
     * The submission deposit has been refunded.
     */
    "SubmissionDepositRefunded": Anonymize<I62nte77gksm0f>;
    /**
     * Metadata for a referendum has been set.
     */
    "MetadataSet": Anonymize<I4f1hv034jf1dt>;
    /**
     * Metadata for a referendum has been cleared.
     */
    "MetadataCleared": Anonymize<I4f1hv034jf1dt>;
}>;
export type I229ijht536qdu = {
    /**
     * Index of the referendum.
     */
    "index": number;
    /**
     * The track (and by extension proposal dispatch origin) of this referendum.
     */
    "track": number;
    /**
     * The proposal for the referendum.
     */
    "proposal": PreimagesBounded;
};
export type PreimagesBounded = Enum<{
    "Legacy": Anonymize<I1jm8m1rh9e20v>;
    "Inline": Binary;
    "Lookup": {
        "hash": FixedSizeBinary<32>;
        "len": number;
    };
}>;
export declare const PreimagesBounded: GetEnum<PreimagesBounded>;
export type I62nte77gksm0f = {
    /**
     * Index of the referendum.
     */
    "index": number;
    /**
     * The account who placed the deposit.
     */
    "who": SS58String;
    /**
     * The amount placed by the account.
     */
    "amount": bigint;
};
export type I9cg2delv92pvq = {
    /**
     * Index of the referendum.
     */
    "index": number;
    /**
     * The track (and by extension proposal dispatch origin) of this referendum.
     */
    "track": number;
    /**
     * The proposal for the referendum.
     */
    "proposal": PreimagesBounded;
    /**
     * The current tally of votes in this referendum.
     */
    "tally": Anonymize<Ifsk7cbmtit1jd>;
};
export type Ifsk7cbmtit1jd = {
    "ayes": bigint;
    "nays": bigint;
    "support": bigint;
};
export type Ilhp45uime5tp = {
    /**
     * Index of the referendum.
     */
    "index": number;
    /**
     * The final tally of votes in this referendum.
     */
    "tally": Anonymize<Ifsk7cbmtit1jd>;
};
export type I4f1hv034jf1dt = {
    /**
     * Index of the referendum.
     */
    "index": number;
    /**
     * Preimage hash.
     */
    "hash": FixedSizeBinary<32>;
};
export type Ibes6fmdev02fd = AnonymousEnum<{
    "CallWhitelisted": Anonymize<I1adbcfi5uc62r>;
    "WhitelistedCallRemoved": Anonymize<I1adbcfi5uc62r>;
    "WhitelistedCallDispatched": Anonymize<Ieunmvpkskgp6r>;
}>;
export type I1adbcfi5uc62r = {
    "call_hash": FixedSizeBinary<32>;
};
export type Ieunmvpkskgp6r = {
    "call_hash": FixedSizeBinary<32>;
    "result": Anonymize<I5d7bc003ki6lp>;
};
export type I5d7bc003ki6lp = ResultPayload<Anonymize<Ia1u1r3n74r13c>, {
    "post_info": Anonymize<Ia1u1r3n74r13c>;
    "error": Anonymize<I3rv535b81c0ac>;
}>;
export type Ia1u1r3n74r13c = {
    "actual_weight"?: Anonymize<Iasb8k6ash5mjn>;
    "pays_fee": Anonymize<Iehg04bj71rkd>;
};
export type Iasb8k6ash5mjn = (Anonymize<I4q39t5hn830vp>) | undefined;
export type CommonClaimsEvent = Enum<{
    /**
     * Someone claimed some DOTs.
     */
    "Claimed": Anonymize<Ie3hcrrq6r18fs>;
}>;
export declare const CommonClaimsEvent: GetEnum<CommonClaimsEvent>;
export type Ie3hcrrq6r18fs = {
    "who": SS58String;
    "ethereum_address": FixedSizeBinary<20>;
    "amount": bigint;
};
export type VestingEvent = Enum<{
    /**
     * The amount vested has been updated. This could indicate a change in funds available.
     * The balance given is the amount which is left unvested (and thus locked).
     */
    "VestingUpdated": Anonymize<Ievr89968437gm>;
    /**
     * An \[account\] has become fully vested.
     */
    "VestingCompleted": Anonymize<Icbccs0ug47ilf>;
}>;
export declare const VestingEvent: GetEnum<VestingEvent>;
export type Ievr89968437gm = {
    "account": SS58String;
    "unvested": bigint;
};
export type I82huppsu6dfkt = AnonymousEnum<{
    /**
     * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
     * well as the error.
     */
    "BatchInterrupted": Anonymize<I8j7cochsto3bl>;
    /**
     * Batch of dispatches completed fully with no error.
     */
    "BatchCompleted": undefined;
    /**
     * Batch of dispatches completed but has errors.
     */
    "BatchCompletedWithErrors": undefined;
    /**
     * A single item within a Batch of dispatches has completed with no error.
     */
    "ItemCompleted": undefined;
    /**
     * A single item within a Batch of dispatches has completed with error.
     */
    "ItemFailed": Anonymize<Id8kvoh0n33u2v>;
    /**
     * A call was dispatched.
     */
    "DispatchedAs": Anonymize<I54jl6jnbv8591>;
    /**
     * Main call was dispatched.
     */
    "IfElseMainSuccess": undefined;
    /**
     * The fallback call was dispatched.
     */
    "IfElseFallbackCalled": Anonymize<I20dig0c31vkg4>;
}>;
export type I8j7cochsto3bl = {
    "index": number;
    "error": Anonymize<I3rv535b81c0ac>;
};
export type Id8kvoh0n33u2v = {
    "error": Anonymize<I3rv535b81c0ac>;
};
export type I54jl6jnbv8591 = {
    "result": Anonymize<I7jgmvdrn822de>;
};
export type I20dig0c31vkg4 = {
    "main_error": Anonymize<I3rv535b81c0ac>;
};
export type Ie8893ig1oqadp = AnonymousEnum<{
    /**
     * A proxy was executed correctly, with the given.
     */
    "ProxyExecuted": Anonymize<I54jl6jnbv8591>;
    /**
     * A pure account has been created by new proxy with given
     * disambiguation index and proxy type.
     */
    "PureCreated": Anonymize<Iamng908a7suk4>;
    /**
     * An announcement was placed to make a call in the future.
     */
    "Announced": Anonymize<I2ur0oeqg495j8>;
    /**
     * A proxy was added.
     */
    "ProxyAdded": Anonymize<Iejcjkg8bsr2ik>;
    /**
     * A proxy was removed.
     */
    "ProxyRemoved": Anonymize<Iejcjkg8bsr2ik>;
    /**
     * A deposit stored for proxies or announcements was poked / updated.
     */
    "DepositPoked": Anonymize<I1bhd210c3phjj>;
}>;
export type Iamng908a7suk4 = {
    "pure": SS58String;
    "who": SS58String;
    "proxy_type": Anonymize<I7adrgaqb51jb9>;
    "disambiguation_index": number;
};
export type I7adrgaqb51jb9 = AnonymousEnum<{
    "Any": undefined;
    "NonTransfer": undefined;
    "Governance": undefined;
    "Staking": undefined;
    "CancelProxy": undefined;
    "Auction": undefined;
    "NominationPools": undefined;
    "ParaRegistration": undefined;
}>;
export type I2ur0oeqg495j8 = {
    "real": SS58String;
    "proxy": SS58String;
    "call_hash": FixedSizeBinary<32>;
};
export type Iejcjkg8bsr2ik = {
    "delegator": SS58String;
    "delegatee": SS58String;
    "proxy_type": Anonymize<I7adrgaqb51jb9>;
    "delay": number;
};
export type I1bhd210c3phjj = {
    "who": SS58String;
    "kind": Enum<{
        "Proxies": undefined;
        "Announcements": undefined;
    }>;
    "old_deposit": bigint;
    "new_deposit": bigint;
};
export type I1m5e04eop0qlq = AnonymousEnum<{
    /**
     * A new multisig operation has begun.
     */
    "NewMultisig": Anonymize<Iep27ialq4a7o7>;
    /**
     * A multisig operation has been approved by someone.
     */
    "MultisigApproval": Anonymize<Iasu5jvoqr43mv>;
    /**
     * A multisig operation has been executed.
     */
    "MultisigExecuted": Anonymize<I2kd2t8gk882hk>;
    /**
     * A multisig operation has been cancelled.
     */
    "MultisigCancelled": Anonymize<I5qolde99acmd1>;
    /**
     * The deposit for a multisig operation has been updated/poked.
     */
    "DepositPoked": Anonymize<I8gtde5abn1g9a>;
}>;
export type Iep27ialq4a7o7 = {
    "approving": SS58String;
    "multisig": SS58String;
    "call_hash": FixedSizeBinary<32>;
};
export type Iasu5jvoqr43mv = {
    "approving": SS58String;
    "timepoint": Anonymize<Itvprrpb0nm3o>;
    "multisig": SS58String;
    "call_hash": FixedSizeBinary<32>;
};
export type Itvprrpb0nm3o = {
    "height": number;
    "index": number;
};
export type I2kd2t8gk882hk = {
    "approving": SS58String;
    "timepoint": Anonymize<Itvprrpb0nm3o>;
    "multisig": SS58String;
    "call_hash": FixedSizeBinary<32>;
    "result": Anonymize<I7jgmvdrn822de>;
};
export type I5qolde99acmd1 = {
    "cancelling": SS58String;
    "timepoint": Anonymize<Itvprrpb0nm3o>;
    "multisig": SS58String;
    "call_hash": FixedSizeBinary<32>;
};
export type I8gtde5abn1g9a = {
    "who": SS58String;
    "call_hash": FixedSizeBinary<32>;
    "old_deposit": bigint;
    "new_deposit": bigint;
};
export type BountiesEvent = Enum<{
    /**
     * New bounty proposal.
     */
    "BountyProposed": Anonymize<I666bl2fqjkejo>;
    /**
     * A bounty proposal was rejected; funds were slashed.
     */
    "BountyRejected": Anonymize<Id9idaj83175f9>;
    /**
     * A bounty proposal is funded and became active.
     */
    "BountyBecameActive": Anonymize<I666bl2fqjkejo>;
    /**
     * A bounty is awarded to a beneficiary.
     */
    "BountyAwarded": Anonymize<Ie1semicfuv5uu>;
    /**
     * A bounty is claimed by beneficiary.
     */
    "BountyClaimed": Anonymize<If25fjs9o37co1>;
    /**
     * A bounty is cancelled.
     */
    "BountyCanceled": Anonymize<I666bl2fqjkejo>;
    /**
     * A bounty expiry is extended.
     */
    "BountyExtended": Anonymize<I666bl2fqjkejo>;
    /**
     * A bounty is approved.
     */
    "BountyApproved": Anonymize<I666bl2fqjkejo>;
    /**
     * A bounty curator is proposed.
     */
    "CuratorProposed": Anonymize<I70sc1pdo8vtos>;
    /**
     * A bounty curator is unassigned.
     */
    "CuratorUnassigned": Anonymize<Ia9p5bg6p18r0i>;
    /**
     * A bounty curator is accepted.
     */
    "CuratorAccepted": Anonymize<I70sc1pdo8vtos>;
}>;
export declare const BountiesEvent: GetEnum<BountiesEvent>;
export type Id9idaj83175f9 = {
    "index": number;
    "bond": bigint;
};
export type Ie1semicfuv5uu = {
    "index": number;
    "beneficiary": SS58String;
};
export type If25fjs9o37co1 = {
    "index": number;
    "payout": bigint;
    "beneficiary": SS58String;
};
export type I70sc1pdo8vtos = {
    "bounty_id": number;
    "curator": SS58String;
};
export type Ia9p5bg6p18r0i = {
    "bounty_id": number;
};
export type ChildBountiesEvent = Enum<{
    /**
     * A child-bounty is added.
     */
    "Added": Anonymize<I60p8l86a8cm59>;
    /**
     * A child-bounty is awarded to a beneficiary.
     */
    "Awarded": Anonymize<I3m3sk2lgcabvp>;
    /**
     * A child-bounty is claimed by beneficiary.
     */
    "Claimed": Anonymize<I5pf572duh4oeg>;
    /**
     * A child-bounty is cancelled.
     */
    "Canceled": Anonymize<I60p8l86a8cm59>;
}>;
export declare const ChildBountiesEvent: GetEnum<ChildBountiesEvent>;
export type I60p8l86a8cm59 = {
    "index": number;
    "child_index": number;
};
export type I3m3sk2lgcabvp = {
    "index": number;
    "child_index": number;
    "beneficiary": SS58String;
};
export type I5pf572duh4oeg = {
    "index": number;
    "child_index": number;
    "payout": bigint;
    "beneficiary": SS58String;
};
export type ElectionProviderMultiPhaseEvent = Enum<{
    /**
     * A solution was stored with the given compute.
     *
     * The `origin` indicates the origin of the solution. If `origin` is `Some(AccountId)`,
     * the stored solution was submitted in the signed phase by a miner with the `AccountId`.
     * Otherwise, the solution was stored either during the unsigned phase or by
     * `T::ForceOrigin`. The `bool` is `true` when a previous solution was ejected to make
     * room for this one.
     */
    "SolutionStored": Anonymize<I4mol6k10mv0io>;
    /**
     * The election has been finalized, with the given computation and score.
     */
    "ElectionFinalized": Anonymize<Iec90vukseit9e>;
    /**
     * An election failed.
     *
     * Not much can be said about which computes failed in the process.
     */
    "ElectionFailed": undefined;
    /**
     * An account has been rewarded for their signed submission being finalized.
     */
    "Rewarded": Anonymize<I7j4m7a3pkvsf4>;
    /**
     * An account has been slashed for submitting an invalid signed submission.
     */
    "Slashed": Anonymize<I7j4m7a3pkvsf4>;
    /**
     * There was a phase transition in a given round.
     */
    "PhaseTransitioned": Anonymize<Ic2n50kpnu5mae>;
}>;
export declare const ElectionProviderMultiPhaseEvent: GetEnum<ElectionProviderMultiPhaseEvent>;
export type I4mol6k10mv0io = {
    "compute": ElectionProviderMultiPhaseElectionCompute;
    "origin"?: Anonymize<Ihfphjolmsqq1>;
    "prev_ejected": boolean;
};
export type ElectionProviderMultiPhaseElectionCompute = Enum<{
    "OnChain": undefined;
    "Signed": undefined;
    "Unsigned": undefined;
    "Fallback": undefined;
    "Emergency": undefined;
}>;
export declare const ElectionProviderMultiPhaseElectionCompute: GetEnum<ElectionProviderMultiPhaseElectionCompute>;
export type Ihfphjolmsqq1 = (SS58String) | undefined;
export type Iec90vukseit9e = {
    "compute": ElectionProviderMultiPhaseElectionCompute;
    "score": Anonymize<I8s6n43okuj2b1>;
};
export type I8s6n43okuj2b1 = {
    "minimal_stake": bigint;
    "sum_stake": bigint;
    "sum_stake_squared": bigint;
};
export type I7j4m7a3pkvsf4 = {
    "account": SS58String;
    "value": bigint;
};
export type Ic2n50kpnu5mae = {
    "from": ElectionProviderMultiPhasePhase;
    "to": ElectionProviderMultiPhasePhase;
    "round": number;
};
export type ElectionProviderMultiPhasePhase = Enum<{
    "Off": undefined;
    "Signed": undefined;
    "Unsigned": [boolean, number];
    "Emergency": undefined;
}>;
export declare const ElectionProviderMultiPhasePhase: GetEnum<ElectionProviderMultiPhasePhase>;
export type BagsListEvent = Enum<{
    /**
     * Moved an account from one bag to another.
     */
    "Rebagged": Anonymize<I37454vatvmm1l>;
    /**
     * Updated the score of some account to the given amount.
     */
    "ScoreUpdated": Anonymize<Iblau1qa7u7fet>;
}>;
export declare const BagsListEvent: GetEnum<BagsListEvent>;
export type I37454vatvmm1l = {
    "who": SS58String;
    "from": bigint;
    "to": bigint;
};
export type Iblau1qa7u7fet = {
    "who": SS58String;
    "new_score": bigint;
};
export type Id0dkgikq71n9h = AnonymousEnum<{
    /**
     * A pool has been created.
     */
    "Created": Anonymize<I1ti389kf8t6oi>;
    /**
     * A member has became bonded in a pool.
     */
    "Bonded": Anonymize<If4nnre373amul>;
    /**
     * A payout has been made to a member.
     */
    "PaidOut": Anonymize<I55kbor0ocqk6h>;
    /**
     * A member has unbonded from their pool.
     *
     * - `balance` is the corresponding balance of the number of points that has been
     * requested to be unbonded (the argument of the `unbond` transaction) from the bonded
     * pool.
     * - `points` is the number of points that are issued as a result of `balance` being
     * dissolved into the corresponding unbonding pool.
     * - `era` is the era in which the balance will be unbonded.
     * In the absence of slashing, these values will match. In the presence of slashing, the
     * number of points that are issued in the unbonding pool will be less than the amount
     * requested to be unbonded.
     */
    "Unbonded": Anonymize<Idsj9cg7j96kpc>;
    /**
     * A member has withdrawn from their pool.
     *
     * The given number of `points` have been dissolved in return of `balance`.
     *
     * Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance
     * will be 1.
     */
    "Withdrawn": Anonymize<Ido4u9drncfaml>;
    /**
     * A pool has been destroyed.
     */
    "Destroyed": Anonymize<I931cottvong90>;
    /**
     * The state of a pool has changed
     */
    "StateChanged": Anonymize<Ie8c7ctks8ur2p>;
    /**
     * A member has been removed from a pool.
     *
     * The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked).
     * Any funds that are still delegated (i.e. dangling delegation) are released and are
     * represented by `released_balance`.
     */
    "MemberRemoved": Anonymize<I6c6fpqmnqijqd>;
    /**
     * The roles of a pool have been updated to the given new roles. Note that the depositor
     * can never change.
     */
    "RolesUpdated": Anonymize<I6mik29s5073td>;
    /**
     * The active balance of pool `pool_id` has been slashed to `balance`.
     */
    "PoolSlashed": Anonymize<I2m0sqmb75cnpb>;
    /**
     * The unbond pool at `era` of pool `pool_id` has been slashed to `balance`.
     */
    "UnbondingPoolSlashed": Anonymize<I49agc5b62mehu>;
    /**
     * A pool's commission setting has been changed.
     */
    "PoolCommissionUpdated": Anonymize<Iatq9jda4hq6pg>;
    /**
     * A pool's maximum commission setting has been changed.
     */
    "PoolMaxCommissionUpdated": Anonymize<I8cbluptqo8kbp>;
    /**
     * A pool's commission `change_rate` has been changed.
     */
    "PoolCommissionChangeRateUpdated": Anonymize<I81cc4plffa1dm>;
    /**
     * Pool commission claim permission has been updated.
     */
    "PoolCommissionClaimPermissionUpdated": Anonymize<I3ihan8icf0c5k>;
    /**
     * Pool commission has been claimed.
     */
    "PoolCommissionClaimed": Anonymize<I2g87evcjlgmqi>;
    /**
     * Topped up deficit in frozen ED of the reward pool.
     */
    "MinBalanceDeficitAdjusted": Anonymize<Ieg1oc56mamrl5>;
    /**
     * Claimed excess frozen ED of af the reward pool.
     */
    "MinBalanceExcessAdjusted": Anonymize<Ieg1oc56mamrl5>;
    /**
     * A pool member's claim permission has been updated.
     */
    "MemberClaimPermissionUpdated": Anonymize<I93ajn7brqs8df>;
    /**
     * A pool's metadata was updated.
     */
    "MetadataUpdated": Anonymize<Ib2q8vnsr19t9b>;
    /**
     * A pool's nominating account (or the pool's root account) has nominated a validator set
     * on behalf of the pool.
     */
    "PoolNominationMade": Anonymize<Ib2q8vnsr19t9b>;
    /**
     * The pool is chilled i.e. no longer nominating.
     */
    "PoolNominatorChilled": Anonymize<Ib2q8vnsr19t9b>;
    /**
     * Global parameters regulating nomination pools have been updated.
     */
    "GlobalParamsUpdated": Anonymize<If6q1q7op2gvqf>;
}>;
export type I1ti389kf8t6oi = {
    "depositor": SS58String;
    "pool_id": number;
};
export type If4nnre373amul = {
    "member": SS58String;
    "pool_id": number;
    "bonded": bigint;
    "joined": boolean;
};
export type I55kbor0ocqk6h = {
    "member": SS58String;
    "pool_id": number;
    "payout": bigint;
};
export type Idsj9cg7j96kpc = {
    "member": SS58String;
    "pool_id": number;
    "balance": bigint;
    "points": bigint;
    "era": number;
};
export type Ido4u9drncfaml = {
    "member": SS58String;
    "pool_id": number;
    "balance": bigint;
    "points": bigint;
};
export type I931cottvong90 = {
    "pool_id": number;
};
export type Ie8c7ctks8ur2p = {
    "pool_id": number;
    "new_state": NominationPoolsPoolState;
};
export type NominationPoolsPoolState = Enum<{
    "Open": undefined;
    "Blocked": undefined;
    "Destroying": undefined;
}>;
export declare const NominationPoolsPoolState: GetEnum<NominationPoolsPoolState>;
export type I6c6fpqmnqijqd = {
    "pool_id": number;
    "member": SS58String;
    "released_balance": bigint;
};
export type I6mik29s5073td = {
    "root"?: Anonymize<Ihfphjolmsqq1>;
    "bouncer"?: Anonymize<Ihfphjolmsqq1>;
    "nominator"?: Anonymize<Ihfphjolmsqq1>;
};
export type I2m0sqmb75cnpb = {
    "pool_id": number;
    "balance": bigint;
};
export type I49agc5b62mehu = {
    "pool_id": number;
    "era": number;
    "balance": bigint;
};
export type Iatq9jda4hq6pg = {
    "pool_id": number;
    "current"?: Anonymize<Ie8iutm7u02lmj>;
};
export type Ie8iutm7u02lmj = (Anonymize<I7svnfko10tq2e>) | undefined;
export type I7svnfko10tq2e = [number, SS58String];
export type I8cbluptqo8kbp = {
    "pool_id": number;
    "max_commission": number;
};
export type I81cc4plffa1dm = {
    "pool_id": number;
    "change_rate": Anonymize<Ibqul338t9c1ll>;
};
export type Ibqul338t9c1ll = {
    "max_increase": number;
    "min_delay": number;
};
export type I3ihan8icf0c5k = {
    "pool_id": number;
    "permission"?: Anonymize<I16m1kn78dee7v>;
};
export type I16m1kn78dee7v = (NominationPoolsCommissionClaimPermission) | undefined;
export type NominationPoolsCommissionClaimPermission = Enum<{
    "Permissionless": undefined;
    "Account": SS58String;
}>;
export declare const NominationPoolsCommissionClaimPermission: GetEnum<NominationPoolsCommissionClaimPermission>;
export type I2g87evcjlgmqi = {
    "pool_id": number;
    "commission": bigint;
};
export type Ieg1oc56mamrl5 = {
    "pool_id": number;
    "amount": bigint;
};
export type I93ajn7brqs8df = {
    "member": SS58String;
    "permission": NominationPoolsClaimPermission;
};
export type NominationPoolsClaimPermission = Enum<{
    "Permissioned": undefined;
    "PermissionlessCompound": undefined;
    "PermissionlessWithdraw": undefined;
    "PermissionlessAll": undefined;
}>;
export declare const NominationPoolsClaimPermission: GetEnum<NominationPoolsClaimPermission>;
export type Ib2q8vnsr19t9b = {
    "pool_id": number;
    "caller": SS58String;
};
export type If6q1q7op2gvqf = {
    "min_join_bond": bigint;
    "min_create_bond": bigint;
    "max_pools"?: Anonymize<I4arjljr6dpflb>;
    "max_members"?: Anonymize<I4arjljr6dpflb>;
    "max_members_per_pool"?: Anonymize<I4arjljr6dpflb>;
    "global_max_commission"?: Anonymize<I4arjljr6dpflb>;
};
export type Iaq2o5035hc46c = AnonymousEnum<{
    /**
     * A staker was unstaked.
     */
    "Unstaked": Anonymize<I6j31jv3j9e11b>;
    /**
     * A staker was slashed for requesting fast-unstake whilst being exposed.
     */
    "Slashed": Anonymize<Ifk8eme5o7mukf>;
    /**
     * A batch was partially checked for the given eras, but the process did not finish.
     */
    "BatchChecked": Anonymize<Ic0he9tlf9ll0u>;
    /**
     * A batch of a given size was terminated.
     *
     * This is always follows by a number of `Unstaked` or `Slashed` events, marking the end
     * of the batch. A new batch will be created upon next block.
     */
    "BatchFinished": Anonymize<I54umskavgc9du>;
    /**
     * An internal error happened. Operations will be paused now.
     */
    "InternalError": undefined;
}>;
export type I6j31jv3j9e11b = {
    "stash": SS58String;
    "result": Anonymize<I7jgmvdrn822de>;
};
export type Ic0he9tlf9ll0u = {
    "eras": Anonymize<Icgljjb6j82uhn>;
};
export type Icgljjb6j82uhn = Array<number>;
export type I1nq1se98idofq = AnonymousEnum<{
    /**
     * Funds delegated by a delegator.
     */
    "Delegated": Anonymize<Id2aanom2jncf1>;
    /**
     * Funds released to a delegator.
     */
    "Released": Anonymize<Id2aanom2jncf1>;
    /**
     * Funds slashed from a delegator.
     */
    "Slashed": Anonymize<Id2aanom2jncf1>;
    /**
     * Unclaimed delegation funds migrated to delegator.
     */
    "MigratedDelegation": Anonymize<Id2aanom2jncf1>;
}>;
export type Id2aanom2jncf1 = {
    "agent": SS58String;
    "delegator": SS58String;
    "amount": bigint;
};
export type If7iaaqrjurpqf = AnonymousEnum<{
    /**
     * A candidate was backed. `[candidate, head_data]`
     */
    "CandidateBacked": Anonymize<I4s0gvfhejmdp2>;
    /**
     * A candidate was included. `[candidate, head_data]`
     */
    "CandidateIncluded": Anonymize<I4s0gvfhejmdp2>;
    /**
     * A candidate timed out. `[candidate, head_data]`
     */
    "CandidateTimedOut": Anonymize<I9njsgm2qsgnil>;
    /**
     * Some upward messages have been received and will be processed.
     */
    "UpwardMessagesReceived": Anonymize<Ic8i89mfkmn3n7>;
}>;
export type I4s0gvfhejmdp2 = [Anonymize<Iceqied2dhrjit>, Binary, number, number];
export type Iceqied2dhrjit = {
    "descriptor": Anonymize<Ibnq2mkuf1plno>;
    "commitments_hash": FixedSizeBinary<32>;
};
export type Ibnq2mkuf1plno = {
    "para_id": number;
    "relay_parent": FixedSizeBinary<32>;
    "version": number;
    "core_index": number;
    "session_index": number;
    "reserved1": FixedSizeBinary<25>;
    "persisted_validation_data_hash": FixedSizeBinary<32>;
    "pov_hash": FixedSizeBinary<32>;
    "erasure_root": FixedSizeBinary<32>;
    "reserved2": FixedSizeBinary<64>;
    "para_head": FixedSizeBinary<32>;
    "validation_code_hash": FixedSizeBinary<32>;
};
export type I9njsgm2qsgnil = [Anonymize<Iceqied2dhrjit>, Binary, number];
export type Ic8i89mfkmn3n7 = {
    "from": number;
    "count": number;
};
export type ParachainsParasEvent = Enum<{
    /**
     * Current code has been updated for a Para. `para_id`
     */
    "CurrentCodeUpdated": number;
    /**
     * Current head has been updated for a Para. `para_id`
     */
    "CurrentHeadUpdated": number;
    /**
     * A code upgrade has been scheduled for a Para. `para_id`
     */
    "CodeUpgradeScheduled": number;
    /**
     * A new head has been noted for a Para. `para_id`
     */
    "NewHeadNoted": number;
    /**
     * A para has been queued to execute pending actions. `para_id`
     */
    "ActionQueued": Anonymize<I9jd27rnpm8ttv>;
    /**
     * The given para either initiated or subscribed to a PVF check for the given validation
     * code. `code_hash` `para_id`
     */
    "PvfCheckStarted": Anonymize<I4pact7n2e9a0i>;
    /**
     * The given validation code was accepted by the PVF pre-checking vote.
     * `code_hash` `para_id`
     */
    "PvfCheckAccepted": Anonymize<I4pact7n2e9a0i>;
    /**
     * The given validation code was rejected by the PVF pre-checking vote.
     * `code_hash` `para_id`
     */
    "PvfCheckRejected": Anonymize<I4pact7n2e9a0i>;
}>;
export declare const ParachainsParasEvent: GetEnum<ParachainsParasEvent>;
export type I4pact7n2e9a0i = [FixedSizeBinary<32>, number];
export type ParachainsHrmpEvent = Enum<{
    /**
     * Open HRMP channel requested.
     */
    "OpenChannelRequested": Anonymize<Id2bej717ckub0>;
    /**
     * An HRMP channel request sent by the receiver was canceled by either party.
     */
    "OpenChannelCanceled": Anonymize<I545vo2e86o5i4>;
    /**
     * Open HRMP channel accepted.
     */
    "OpenChannelAccepted": Anonymize<I50mrcbubp554e>;
    /**
     * HRMP channel closed.
     */
    "ChannelClosed": Anonymize<I545vo2e86o5i4>;
    /**
     * An HRMP channel was opened via Root origin.
     */
    "HrmpChannelForceOpened": Anonymize<Id2bej717ckub0>;
    /**
     * An HRMP channel was opened with a system chain.
     */
    "HrmpSystemChannelOpened": Anonymize<Id2bej717ckub0>;
    /**
     * An HRMP channel's deposits were updated.
     */
    "OpenChannelDepositsUpdated": Anonymize<I50mrcbubp554e>;
}>;
export declare const ParachainsHrmpEvent: GetEnum<ParachainsHrmpEvent>;
export type Id2bej717ckub0 = {
    "sender": number;
    "recipient": number;
    "proposed_max_capacity": number;
    "proposed_max_message_size": number;
};
export type I545vo2e86o5i4 = {
    "by_parachain": number;
    "channel_id": Anonymize<I50mrcbubp554e>;
};
export type I50mrcbubp554e = {
    "sender": number;
    "recipient": number;
};
export type ParachainsDisputesEvent = Enum<{
    /**
     * A dispute has been initiated. \[candidate hash, dispute location\]
     */
    "DisputeInitiated": Anonymize<I3i09nus3ku37s>;
    /**
     * A dispute has concluded for or against a candidate.
     * `\[para id, candidate hash, dispute result\]`
     */
    "DisputeConcluded": Anonymize<I2e447aa6a0imh>;
    /**
     * A dispute has concluded with supermajority against a candidate.
     * Block authors should no longer build on top of this head and should
     * instead revert the block at the given height. This should be the
     * number of the child of the last known valid block in the chain.
     */
    "Revert": number;
}>;
export declare const ParachainsDisputesEvent: GetEnum<ParachainsDisputesEvent>;
export type I3i09nus3ku37s = [FixedSizeBinary<32>, ParachainsDisputeLocation];
export type ParachainsDisputeLocation = Enum<{
    "Local": undefined;
    "Remote": undefined;
}>;
export declare const ParachainsDisputeLocation: GetEnum<ParachainsDisputeLocation>;
export type I2e447aa6a0imh = [FixedSizeBinary<32>, ParachainsDisputeResult];
export type ParachainsDisputeResult = Enum<{
    "Valid": undefined;
    "Invalid": undefined;
}>;
export declare const ParachainsDisputeResult: GetEnum<ParachainsDisputeResult>;
export type I8vt07l5vp6sb8 = AnonymousEnum<{
    /**
     * An order was placed at some spot price amount by orderer ordered_by
     */
    "OnDemandOrderPlaced": Anonymize<I82n7gg49bvucn>;
    /**
     * The value of the spot price has likely changed
     */
    "SpotPriceSet": Anonymize<I58qkru548f7dl>;
    /**
     * An account was given credits.
     */
    "AccountCredited": Anonymize<Id5fm4p8lj5qgi>;
}>;
export type I82n7gg49bvucn = {
    "para_id": number;
    "spot_price": bigint;
    "ordered_by": SS58String;
};
export type I58qkru548f7dl = {
    "spot_price": bigint;
};
export type CommonParasRegistrarEvent = Enum<{
    "Registered": Anonymize<Ibs22tt76qp5bi>;
    "Deregistered": Anonymize<I37r4bdai8o9mp>;
    "Reserved": Anonymize<Idn2ghub1o4i40>;
    "Swapped": Anonymize<I48u78djt89dod>;
}>;
export declare const CommonParasRegistrarEvent: GetEnum<CommonParasRegistrarEvent>;
export type Ibs22tt76qp5bi = {
    "para_id": number;
    "manager": SS58String;
};
export type I37r4bdai8o9mp = {
    "para_id": number;
};
export type Idn2ghub1o4i40 = {
    "para_id": number;
    "who": SS58String;
};
export type I48u78djt89dod = {
    "para_id": number;
    "other_id": number;
};
export type CommonSlotsEvent = Enum<{
    /**
     * A new `[lease_period]` is beginning.
     */
    "NewLeasePeriod": Anonymize<Ib85m5kfbepu2t>;
    /**
     * A para has won the right to a continuous set of lease periods as a parachain.
     * First balance is any extra amount reserved on top of the para's existing deposit.
     * Second balance is the total amount reserved.
     */
    "Leased": Anonymize<Idaml5bdhsfcsl>;
}>;
export declare const CommonSlotsEvent: GetEnum<CommonSlotsEvent>;
export type Ib85m5kfbepu2t = {
    "lease_period": number;
};
export type Idaml5bdhsfcsl = {
    "para_id": number;
    "leaser": SS58String;
    "period_begin": number;
    "period_count": number;
    "extra_reserved": bigint;
    "total_amount": bigint;
};
export type CommonAuctionsEvent = Enum<{
    /**
     * An auction started. Provides its index and the block number where it will begin to
     * close and the first lease period of the quadruplet that is auctioned.
     */
    "AuctionStarted": Anonymize<Ieec0cu336gteb>;
    /**
     * An auction ended. All funds become unreserved.
     */
    "AuctionClosed": Anonymize<I815d5k4ij85nv>;
    /**
     * Funds were reserved for a winning bid. First balance is the extra amount reserved.
     * Second is the total.
     */
    "Reserved": Anonymize<Ifi98fgi9o46v7>;
    /**
     * Funds were unreserved since bidder is no longer active. `[bidder, amount]`
     */
    "Unreserved": Anonymize<Ic0oj9tok33uap>;
    /**
     * Someone attempted to lease the same slot twice for a parachain. The amount is held in
     * reserve but no parachain slot has been leased.
     */
    "ReserveConfiscated": Anonymize<I3tdutpfjuk32j>;
    /**
     * A new bid has been accepted as the current winner.
     */
    "BidAccepted": Anonymize<I1esdujrkdacpb>;
    /**
     * The winning offset was chosen for an auction. This will map into the `Winning` storage
     * map.
     */
    "WinningOffset": Anonymize<I9g1d820jf9m2s>;
}>;
export declare const CommonAuctionsEvent: GetEnum<CommonAuctionsEvent>;
export type Ieec0cu336gteb = {
    "auction_index": number;
    "lease_period": number;
    "ending": number;
};
export type I815d5k4ij85nv = {
    "auction_index": number;
};
export type Ifi98fgi9o46v7 = {
    "bidder": SS58String;
    "extra_reserved": bigint;
    "total_amount": bigint;
};
export type Ic0oj9tok33uap = {
    "bidder": SS58String;
    "amount": bigint;
};
export type I3tdutpfjuk32j = {
    "para_id": number;
    "leaser": SS58String;
    "amount": bigint;
};
export type I1esdujrkdacpb = {
    "bidder": SS58String;
    "para_id": number;
    "amount": bigint;
    "first_slot": number;
    "last_slot": number;
};
export type I9g1d820jf9m2s = {
    "auction_index": number;
    "block_number": number;
};
export type Iaoudv69ujgdup = AnonymousEnum<{
    /**
     * Create a new crowdloaning campaign.
     */
    "Created": Anonymize<I37r4bdai8o9mp>;
    /**
     * Contributed to a crowd sale.
     */
    "Contributed": Anonymize<I8ve4g3egaln6a>;
    /**
     * Withdrew full balance of a contributor.
     */
    "Withdrew": Anonymize<I8ve4g3egaln6a>;
    /**
     * The loans in a fund have been partially dissolved, i.e. there are some left
     * over child keys that still need to be killed.
     */
    "PartiallyRefunded": Anonymize<I37r4bdai8o9mp>;
    /**
     * All loans in a fund have been refunded.
     */
    "AllRefunded": Anonymize<I37r4bdai8o9mp>;
    /**
     * Fund is dissolved.
     */
    "Dissolved": Anonymize<I37r4bdai8o9mp>;
    /**
     * The result of trying to submit a new bid to the Slots pallet.
     */
    "HandleBidResult": Anonymize<Ie2jn511v4jgmc>;
    /**
     * The configuration to a crowdloan has been edited.
     */
    "Edited": Anonymize<I37r4bdai8o9mp>;
    /**
     * A memo has been updated.
     */
    "MemoUpdated": Anonymize<If4hvqaeoqq5us>;
    /**
     * A parachain has been moved to `NewRaise`
     */
    "AddedToNewRaise": Anonymize<I37r4bdai8o9mp>;
}>;
export type I8ve4g3egaln6a = {
    "who": SS58String;
    "fund_index": number;
    "amount": bigint;
};
export type Ie2jn511v4jgmc = {
    "para_id": number;
    "result": Anonymize<I7jgmvdrn822de>;
};
export type If4hvqaeoqq5us = {
    "who": SS58String;
    "para_id": number;
    "memo": Binary;
};
export type PolkadotRuntimeParachainsCoretimeEvent = Enum<{
    /**
     * The broker chain has asked for revenue information for a specific block.
     */
    "RevenueInfoRequested": Anonymize<Ibtsa3docbr9el>;
    /**
     * A core has received a new assignment from the broker chain.
     */
    "CoreAssigned": Anonymize<Iaiqv5prlisjkg>;
}>;
export declare const PolkadotRuntimeParachainsCoretimeEvent: GetEnum<PolkadotRuntimeParachainsCoretimeEvent>;
export type Iaiqv5prlisjkg = {
    "core": number;
};
export type I61dksvl51aujo = AnonymousEnum<{
    /**
     * Given number of `(top, child)` keys were migrated respectively, with the given
     * `compute`.
     */
    "Migrated": Anonymize<Iagqcb06kbevb1>;
    /**
     * Some account got slashed by the given amount.
     */
    "Slashed": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * The auto migration task finished.
     */
    "AutoMigrationFinished": undefined;
    /**
     * Migration got halted due to an error or miss-configuration.
     */
    "Halted": Anonymize<Iec8defeh924b6>;
}>;
export type Iagqcb06kbevb1 = {
    "top": number;
    "child": number;
    "compute": Enum<{
        "Signed": undefined;
        "Auto": undefined;
    }>;
};
export type Iec8defeh924b6 = {
    "error": Anonymize<I96objte63brjr>;
};
export type Id2l439q7pe8kr = AnonymousEnum<{
    /**
     * Execution of an XCM message was attempted.
     */
    "Attempted": Anonymize<Ia72eet39sf8j9>;
    /**
     * An XCM message was sent.
     */
    "Sent": Anonymize<If8u5kl4h8070m>;
    /**
     * An XCM message failed to send.
     */
    "SendFailed": Anonymize<Ibmuil6p3vl83l>;
    /**
     * An XCM message failed to process.
     */
    "ProcessXcmError": Anonymize<I7lul91g50ae87>;
    /**
     * Query response received which does not match a registered query. This may be because a
     * matching query was never registered, it may be because it is a duplicate response, or
     * because the query timed out.
     */
    "UnexpectedResponse": Anonymize<Icl7nl1rfeog3i>;
    /**
     * Query response has been received and is ready for taking with `take_response`. There is
     * no registered notification call.
     */
    "ResponseReady": Anonymize<Iasr6pj6shs0fl>;
    /**
     * Query response has been received and query is removed. The registered notification has
     * been dispatched and executed successfully.
     */
    "Notified": Anonymize<I2uqmls7kcdnii>;
    /**
     * Query response has been received and query is removed. The registered notification
     * could not be dispatched because the dispatch weight is greater than the maximum weight
     * originally budgeted by this runtime for the query result.
     */
    "NotifyOverweight": Anonymize<Idg69klialbkb8>;
    /**
     * Query response has been received and query is removed. There was a general error with
     * dispatching the notification call.
     */
    "NotifyDispatchError": Anonymize<I2uqmls7kcdnii>;
    /**
     * Query response has been received and query is removed. The dispatch was unable to be
     * decoded into a `Call`; this might be due to dispatch function having a signature which
     * is not `(origin, QueryId, Response)`.
     */
    "NotifyDecodeFailed": Anonymize<I2uqmls7kcdnii>;
    /**
     * Expected query response has been received but the origin location of the response does
     * not match that expected. The query remains registered for a later, valid, response to
     * be received and acted upon.
     */
    "InvalidResponder": Anonymize<I7r6b7145022pp>;
    /**
     * Expected query response has been received but the expected origin location placed in
     * storage by this runtime previously cannot be decoded. The query remains registered.
     *
     * This is unexpected (since a location placed in storage in a previously executing
     * runtime should be readable prior to query timeout) and dangerous since the possibly
     * valid response will be dropped. Manual governance intervention is probably going to be
     * needed.
     */
    "InvalidResponderVersion": Anonymize<Icl7nl1rfeog3i>;
    /**
     * Received query response has been read and removed.
     */
    "ResponseTaken": Anonymize<I30pg328m00nr3>;
    /**
     * Some assets have been placed in an asset trap.
     */
    "AssetsTrapped": Anonymize<Icmrn7bogp28cs>;
    /**
     * An XCM version change notification message has been attempted to be sent.
     *
     * The cost of sending it (borne by the chain) is included.
     */
    "VersionChangeNotified": Anonymize<I7m9b5plj4h5ot>;
    /**
     * The supported version of a location has been changed. This might be through an
     * automatic notification or a manual intervention.
     */
    "SupportedVersionChanged": Anonymize<I9kt8c221c83ln>;
    /**
     * A given location which had a version change subscription was dropped owing to an error
     * sending the notification to it.
     */
    "NotifyTargetSendFail": Anonymize<I9onhk772nfs4f>;
    /**
     * A given location which had a version change subscription was dropped owing to an error
     * migrating the location to our new XCM format.
     */
    "NotifyTargetMigrationFail": Anonymize<I3l6bnksrmt56r>;
    /**
     * Expected query response has been received but the expected querier location placed in
     * storage by this runtime previously cannot be decoded. The query remains registered.
     *
     * This is unexpected (since a location placed in storage in a previously executing
     * runtime should be readable prior to query timeout) and dangerous since the possibly
     * valid response will be dropped. Manual governance intervention is probably going to be
     * needed.
     */
    "InvalidQuerierVersion": Anonymize<Icl7nl1rfeog3i>;
    /**
     * Expected query response has been received but the querier location of the response does
     * not match the expected. The query remains registered for a later, valid, response to
     * be received and acted upon.
     */
    "InvalidQuerier": Anonymize<Idh09k0l2pmdcg>;
    /**
     * A remote has requested XCM version change notification from us and we have honored it.
     * A version information message is sent to them and its cost is included.
     */
    "VersionNotifyStarted": Anonymize<I7uoiphbm0tj4r>;
    /**
     * We have requested that a remote chain send us XCM version change notifications.
     */
    "VersionNotifyRequested": Anonymize<I7uoiphbm0tj4r>;
    /**
     * We have requested that a remote chain stops sending us XCM version change
     * notifications.
     */
    "VersionNotifyUnrequested": Anonymize<I7uoiphbm0tj4r>;
    /**
     * Fees were paid from a location for an operation (often for using `SendXcm`).
     */
    "FeesPaid": Anonymize<I512p1n7qt24l8>;
    /**
     * Some assets have been claimed from an asset trap
     */
    "AssetsClaimed": Anonymize<Icmrn7bogp28cs>;
    /**
     * A XCM version migration finished.
     */
    "VersionMigrationFinished": Anonymize<I6s1nbislhk619>;
    /**
     * An `aliaser` location was authorized by `target` to alias it, authorization valid until
     * `expiry` block number.
     */
    "AliasAuthorized": Anonymize<I3gghqnh2mj0is>;
    /**
     * `target` removed alias authorization for `aliaser`.
     */
    "AliasAuthorizationRemoved": Anonymize<I6iv852roh6t3h>;
    /**
     * `target` removed all alias authorizations.
     */
    "AliasesAuthorizationsRemoved": Anonymize<I9oc2o6itbiopq>;
}>;
export type Ia72eet39sf8j9 = {
    "outcome": Anonymize<I6uq5gb4s805s7>;
};
export type I6uq5gb4s805s7 = AnonymousEnum<{
    "Complete": {
        "used": Anonymize<I4q39t5hn830vp>;
    };
    "Incomplete": {
        "used": Anonymize<I4q39t5hn830vp>;
        "error": Anonymize<Id56rgs0bdb7gl>;
    };
    "Error": Anonymize<Iflkd2j467575k>;
}>;
export type Id56rgs0bdb7gl = AnonymousEnum<{
    "Overflow": undefined;
    "Unimplemented": undefined;
    "UntrustedReserveLocation": undefined;
    "UntrustedTeleportLocation": undefined;
    "LocationFull": undefined;
    "LocationNotInvertible": undefined;
    "BadOrigin": undefined;
    "InvalidLocation": undefined;
    "AssetNotFound": undefined;
    "FailedToTransactAsset": undefined;
    "NotWithdrawable": undefined;
    "LocationCannotHold": undefined;
    "ExceedsMaxMessageSize": undefined;
    "DestinationUnsupported": undefined;
    "Transport": undefined;
    "Unroutable": undefined;
    "UnknownClaim": undefined;
    "FailedToDecode": undefined;
    "MaxWeightInvalid": undefined;
    "NotHoldingFees": undefined;
    "TooExpensive": undefined;
    "Trap": bigint;
    "ExpectationFalse": undefined;
    "PalletNotFound": undefined;
    "NameMismatch": undefined;
    "VersionIncompatible": undefined;
    "HoldingWouldOverflow": undefined;
    "ExportError": undefined;
    "ReanchorFailed": undefined;
    "NoDeal": undefined;
    "FeesNotMet": undefined;
    "LockError": undefined;
    "NoPermission": undefined;
    "Unanchored": undefined;
    "NotDepositable": undefined;
    "TooManyAssets": undefined;
    "UnhandledXcmVersion": undefined;
    "WeightLimitReached": Anonymize<I4q39t5hn830vp>;
    "Barrier": undefined;
    "WeightNotComputable": undefined;
    "ExceedsStackLimit": undefined;
}>;
export type Iflkd2j467575k = {
    "error": Anonymize<Id56rgs0bdb7gl>;
};
export type If8u5kl4h8070m = {
    "origin": Anonymize<If9iqq7i64mur8>;
    "destination": Anonymize<If9iqq7i64mur8>;
    "message": Anonymize<Ict03eedr8de9s>;
    "message_id": FixedSizeBinary<32>;
};
export type Ict03eedr8de9s = Array<XcmV5Instruction>;
export type XcmV5Instruction = Enum<{
    "WithdrawAsset": Anonymize<I4npjalvhmfuj>;
    "ReserveAssetDeposited": Anonymize<I4npjalvhmfuj>;
    "ReceiveTeleportedAsset": Anonymize<I4npjalvhmfuj>;
    "QueryResponse": {
        "query_id": bigint;
        "response": Anonymize<I7vucpgm2c6959>;
        "max_weight": Anonymize<I4q39t5hn830vp>;
        "querier"?: Anonymize<I4pai6qnfk426l>;
    };
    "TransferAsset": {
        "assets": Anonymize<I4npjalvhmfuj>;
        "beneficiary": Anonymize<If9iqq7i64mur8>;
    };
    "TransferReserveAsset": {
        "assets": Anonymize<I4npjalvhmfuj>;
        "dest": Anonymize<If9iqq7i64mur8>;
        "xcm": Anonymize<Ict03eedr8de9s>;
    };
    "Transact": {
        "origin_kind": XcmV2OriginKind;
        "fallback_max_weight"?: Anonymize<Iasb8k6ash5mjn>;
        "call": Binary;
    };
    "HrmpNewChannelOpenRequest": Anonymize<I5uhhrjqfuo4e5>;
    "HrmpChannelAccepted": Anonymize<Ifij4jam0o7sub>;
    "HrmpChannelClosing": Anonymize<Ieeb4svd9i8fji>;
    "ClearOrigin": undefined;
    "DescendOrigin": XcmV5Junctions;
    "ReportError": Anonymize<I6vsmh07hrp1rc>;
    "DepositAsset": {
        "assets": XcmV5AssetFilter;
        "beneficiary": Anonymize<If9iqq7i64mur8>;
    };
    "DepositReserveAsset": {
        "assets": XcmV5AssetFilter;
        "dest": Anonymize<If9iqq7i64mur8>;
        "xcm": Anonymize<Ict03eedr8de9s>;
    };
    "ExchangeAsset": {
        "give": XcmV5AssetFilter;
        "want": Anonymize<I4npjalvhmfuj>;
        "maximal": boolean;
    };
    "InitiateReserveWithdraw": {
        "assets": XcmV5AssetFilter;
        "reserve": Anonymize<If9iqq7i64mur8>;
        "xcm": Anonymize<Ict03eedr8de9s>;
    };
    "InitiateTeleport": {
        "assets": XcmV5AssetFilter;
        "dest": Anonymize<If9iqq7i64mur8>;
        "xcm": Anonymize<Ict03eedr8de9s>;
    };
    "ReportHolding": {
        "response_info": Anonymize<I6vsmh07hrp1rc>;
        "assets": XcmV5AssetFilter;
    };
    "BuyExecution": {
        "fees": Anonymize<Iffh1nc5e1mod6>;
        "weight_limit": XcmV3WeightLimit;
    };
    "RefundSurplus": undefined;
    "SetErrorHandler": Anonymize<Ict03eedr8de9s>;
    "SetAppendix": Anonymize<Ict03eedr8de9s>;
    "ClearError": undefined;
    "ClaimAsset": {
        "assets": Anonymize<I4npjalvhmfuj>;
        "ticket": Anonymize<If9iqq7i64mur8>;
    };
    "Trap": bigint;
    "SubscribeVersion": Anonymize<Ieprdqqu7ildvr>;
    "UnsubscribeVersion": undefined;
    "BurnAsset": Anonymize<I4npjalvhmfuj>;
    "ExpectAsset": Anonymize<I4npjalvhmfuj>;
    "ExpectOrigin"?: Anonymize<I4pai6qnfk426l>;
    "ExpectError"?: Anonymize<I3l6ejee750fv1>;
    "ExpectTransactStatus": XcmV3MaybeErrorCode;
    "QueryPallet": {
        "module_name": Binary;
        "response_info": Anonymize<I6vsmh07hrp1rc>;
    };
    "ExpectPallet": Anonymize<Id7mf37dkpgfjs>;
    "ReportTransactStatus": Anonymize<I6vsmh07hrp1rc>;
    "ClearTransactStatus": undefined;
    "UniversalOrigin": XcmV5Junction;
    "ExportMessage": {
        "network": XcmV5NetworkId;
        "destination": XcmV5Junctions;
        "xcm": Anonymize<Ict03eedr8de9s>;
    };
    "LockAsset": {
        "asset": Anonymize<Iffh1nc5e1mod6>;
        "unlocker": Anonymize<If9iqq7i64mur8>;
    };
    "UnlockAsset": {
        "asset": Anonymize<Iffh1nc5e1mod6>;
        "target": Anonymize<If9iqq7i64mur8>;
    };
    "NoteUnlockable": {
        "asset": Anonymize<Iffh1nc5e1mod6>;
        "owner": Anonymize<If9iqq7i64mur8>;
    };
    "RequestUnlock": {
        "asset": Anonymize<Iffh1nc5e1mod6>;
        "locker": Anonymize<If9iqq7i64mur8>;
    };
    "SetFeesMode": Anonymize<I4nae9rsql8fa7>;
    "SetTopic": FixedSizeBinary<32>;
    "ClearTopic": undefined;
    "AliasOrigin": Anonymize<If9iqq7i64mur8>;
    "UnpaidExecution": {
        "weight_limit": XcmV3WeightLimit;
        "check_origin"?: Anonymize<I4pai6qnfk426l>;
    };
    "PayFees": {
        "asset": Anonymize<Iffh1nc5e1mod6>;
    };
    "InitiateTransfer": {
        "destination": Anonymize<If9iqq7i64mur8>;
        "remote_fees"?: (Anonymize<Ifhmc9e7vpeeig>) | undefined;
        "preserve_origin": boolean;
        "assets": Array<Anonymize<Ifhmc9e7vpeeig>>;
        "remote_xcm": Anonymize<Ict03eedr8de9s>;
    };
    "ExecuteWithOrigin": {
        "descendant_origin"?: (XcmV5Junctions) | undefined;
        "xcm": Anonymize<Ict03eedr8de9s>;
    };
    "SetHints": {
        "hints": Array<Enum<{
            "AssetClaimer": Anonymize<I2adkav4nfpltp>;
        }>>;
    };
}>;
export declare const XcmV5Instruction: GetEnum<XcmV5Instruction>;
export type I4npjalvhmfuj = Array<Anonymize<Iffh1nc5e1mod6>>;
export type Iffh1nc5e1mod6 = {
    "id": Anonymize<If9iqq7i64mur8>;
    "fun": XcmV3MultiassetFungibility;
};
export type XcmV3MultiassetFungibility = Enum<{
    "Fungible": bigint;
    "NonFungible": XcmV3MultiassetAssetInstance;
}>;
export declare const XcmV3MultiassetFungibility: GetEnum<XcmV3MultiassetFungibility>;
export type XcmV3MultiassetAssetInstance = Enum<{
    "Undefined": undefined;
    "Index": bigint;
    "Array4": FixedSizeBinary<4>;
    "Array8": FixedSizeBinary<8>;
    "Array16": FixedSizeBinary<16>;
    "Array32": FixedSizeBinary<32>;
}>;
export declare const XcmV3MultiassetAssetInstance: GetEnum<XcmV3MultiassetAssetInstance>;
export type I7vucpgm2c6959 = AnonymousEnum<{
    "Null": undefined;
    "Assets": Anonymize<I4npjalvhmfuj>;
    "ExecutionResult"?: Anonymize<I3l6ejee750fv1>;
    "Version": number;
    "PalletsInfo": Anonymize<I599u7h20b52at>;
    "DispatchResult": XcmV3MaybeErrorCode;
}>;
export type I3l6ejee750fv1 = ([number, Anonymize<Id56rgs0bdb7gl>]) | undefined;
export type I599u7h20b52at = Array<{
    "index": number;
    "name": Binary;
    "module_name": Binary;
    "major": number;
    "minor": number;
    "patch": number;
}>;
export type XcmV3MaybeErrorCode = Enum<{
    "Success": undefined;
    "Error": Binary;
    "TruncatedError": Binary;
}>;
export declare const XcmV3MaybeErrorCode: GetEnum<XcmV3MaybeErrorCode>;
export type I4pai6qnfk426l = (Anonymize<If9iqq7i64mur8>) | undefined;
export type XcmV2OriginKind = Enum<{
    "Native": undefined;
    "SovereignAccount": undefined;
    "Superuser": undefined;
    "Xcm": undefined;
}>;
export declare const XcmV2OriginKind: GetEnum<XcmV2OriginKind>;
export type I5uhhrjqfuo4e5 = {
    "sender": number;
    "max_message_size": number;
    "max_capacity": number;
};
export type Ifij4jam0o7sub = {
    "recipient": number;
};
export type Ieeb4svd9i8fji = {
    "initiator": number;
    "sender": number;
    "recipient": number;
};
export type I6vsmh07hrp1rc = {
    "destination": Anonymize<If9iqq7i64mur8>;
    "query_id": bigint;
    "max_weight": Anonymize<I4q39t5hn830vp>;
};
export type XcmV5AssetFilter = Enum<{
    "Definite": Anonymize<I4npjalvhmfuj>;
    "Wild": XcmV5WildAsset;
}>;
export declare const XcmV5AssetFilter: GetEnum<XcmV5AssetFilter>;
export type XcmV5WildAsset = Enum<{
    "All": undefined;
    "AllOf": {
        "id": Anonymize<If9iqq7i64mur8>;
        "fun": XcmV2MultiassetWildFungibility;
    };
    "AllCounted": number;
    "AllOfCounted": {
        "id": Anonymize<If9iqq7i64mur8>;
        "fun": XcmV2MultiassetWildFungibility;
        "count": number;
    };
}>;
export declare const XcmV5WildAsset: GetEnum<XcmV5WildAsset>;
export type XcmV2MultiassetWildFungibility = Enum<{
    "Fungible": undefined;
    "NonFungible": undefined;
}>;
export declare const XcmV2MultiassetWildFungibility: GetEnum<XcmV2MultiassetWildFungibility>;
export type XcmV3WeightLimit = Enum<{
    "Unlimited": undefined;
    "Limited": Anonymize<I4q39t5hn830vp>;
}>;
export declare const XcmV3WeightLimit: GetEnum<XcmV3WeightLimit>;
export type Ieprdqqu7ildvr = {
    "query_id": bigint;
    "max_response_weight": Anonymize<I4q39t5hn830vp>;
};
export type Id7mf37dkpgfjs = {
    "index": number;
    "name": Binary;
    "module_name": Binary;
    "crate_major": number;
    "min_crate_minor": number;
};
export type I4nae9rsql8fa7 = {
    "jit_withdraw": boolean;
};
export type Ifhmc9e7vpeeig = AnonymousEnum<{
    "Teleport": XcmV5AssetFilter;
    "ReserveDeposit": XcmV5AssetFilter;
    "ReserveWithdraw": XcmV5AssetFilter;
}>;
export type I2adkav4nfpltp = {
    "location": Anonymize<If9iqq7i64mur8>;
};
export type Ibmuil6p3vl83l = {
    "origin": Anonymize<If9iqq7i64mur8>;
    "destination": Anonymize<If9iqq7i64mur8>;
    "error": Enum<{
        "NotApplicable": undefined;
        "Transport": undefined;
        "Unroutable": undefined;
        "DestinationUnsupported": undefined;
        "ExceedsMaxMessageSize": undefined;
        "MissingArgument": undefined;
        "Fees": undefined;
    }>;
    "message_id": FixedSizeBinary<32>;
};
export type I7lul91g50ae87 = {
    "origin": Anonymize<If9iqq7i64mur8>;
    "error": Anonymize<Id56rgs0bdb7gl>;
    "message_id": FixedSizeBinary<32>;
};
export type Icl7nl1rfeog3i = {
    "origin": Anonymize<If9iqq7i64mur8>;
    "query_id": bigint;
};
export type Iasr6pj6shs0fl = {
    "query_id": bigint;
    "response": Anonymize<I7vucpgm2c6959>;
};
export type I2uqmls7kcdnii = {
    "query_id": bigint;
    "pallet_index": number;
    "call_index": number;
};
export type Idg69klialbkb8 = {
    "query_id": bigint;
    "pallet_index": number;
    "call_index": number;
    "actual_weight": Anonymize<I4q39t5hn830vp>;
    "max_budgeted_weight": Anonymize<I4q39t5hn830vp>;
};
export type I7r6b7145022pp = {
    "origin": Anonymize<If9iqq7i64mur8>;
    "query_id": bigint;
    "expected_location"?: Anonymize<I4pai6qnfk426l>;
};
export type I30pg328m00nr3 = {
    "query_id": bigint;
};
export type Icmrn7bogp28cs = {
    "hash": FixedSizeBinary<32>;
    "origin": Anonymize<If9iqq7i64mur8>;
    "assets": XcmVersionedAssets;
};
export type XcmVersionedAssets = Enum<{
    "V3": Anonymize<Iai6dhqiq3bach>;
    "V4": Anonymize<I50mli3hb64f9b>;
    "V5": Anonymize<I4npjalvhmfuj>;
}>;
export declare const XcmVersionedAssets: GetEnum<XcmVersionedAssets>;
export type Iai6dhqiq3bach = Array<Anonymize<Idcm24504c8bkk>>;
export type Idcm24504c8bkk = {
    "id": XcmV3MultiassetAssetId;
    "fun": XcmV3MultiassetFungibility;
};
export type I50mli3hb64f9b = Array<Anonymize<Ia5l7mu5a6v49o>>;
export type Ia5l7mu5a6v49o = {
    "id": Anonymize<I4c0s5cioidn76>;
    "fun": XcmV3MultiassetFungibility;
};
export type I7m9b5plj4h5ot = {
    "destination": Anonymize<If9iqq7i64mur8>;
    "result": number;
    "cost": Anonymize<I4npjalvhmfuj>;
    "message_id": FixedSizeBinary<32>;
};
export type I9kt8c221c83ln = {
    "location": Anonymize<If9iqq7i64mur8>;
    "version": number;
};
export type I9onhk772nfs4f = {
    "location": Anonymize<If9iqq7i64mur8>;
    "query_id": bigint;
    "error": Anonymize<Id56rgs0bdb7gl>;
};
export type I3l6bnksrmt56r = {
    "location": XcmVersionedLocation;
    "query_id": bigint;
};
export type Idh09k0l2pmdcg = {
    "origin": Anonymize<If9iqq7i64mur8>;
    "query_id": bigint;
    "expected_querier": Anonymize<If9iqq7i64mur8>;
    "maybe_actual_querier"?: Anonymize<I4pai6qnfk426l>;
};
export type I7uoiphbm0tj4r = {
    "destination": Anonymize<If9iqq7i64mur8>;
    "cost": Anonymize<I4npjalvhmfuj>;
    "message_id": FixedSizeBinary<32>;
};
export type I512p1n7qt24l8 = {
    "paying": Anonymize<If9iqq7i64mur8>;
    "fees": Anonymize<I4npjalvhmfuj>;
};
export type I6s1nbislhk619 = {
    "version": number;
};
export type I3gghqnh2mj0is = {
    "aliaser": Anonymize<If9iqq7i64mur8>;
    "target": Anonymize<If9iqq7i64mur8>;
    "expiry"?: Anonymize<I35p85j063s0il>;
};
export type I35p85j063s0il = (bigint) | undefined;
export type I6iv852roh6t3h = {
    "aliaser": Anonymize<If9iqq7i64mur8>;
    "target": Anonymize<If9iqq7i64mur8>;
};
export type I9oc2o6itbiopq = {
    "target": Anonymize<If9iqq7i64mur8>;
};
export type I13vul90391uuv = AnonymousEnum<{
    /**
     * Message discarded due to an error in the `MessageProcessor` (usually a format error).
     */
    "ProcessingFailed": Anonymize<I218fa3heih67o>;
    /**
     * Message is processed.
     */
    "Processed": Anonymize<I1tf93k54ltg1v>;
    /**
     * Message placed in overweight queue.
     */
    "OverweightEnqueued": Anonymize<I6ove5at7hfiur>;
    /**
     * This page was reaped.
     */
    "PageReaped": Anonymize<I9c0urppp07b8b>;
}>;
export type I218fa3heih67o = {
    /**
     * The `blake2_256` hash of the message.
     */
    "id": FixedSizeBinary<32>;
    /**
     * The queue of the message.
     */
    "origin": ParachainsInclusionAggregateMessageOrigin;
    /**
     * The error that occurred.
     *
     * This error is pretty opaque. More fine-grained errors need to be emitted as events
     * by the `MessageProcessor`.
     */
    "error": Anonymize<I5hhsj7l9obr84>;
};
export type ParachainsInclusionAggregateMessageOrigin = Enum<{
    "Ump": ParachainsInclusionUmpQueueId;
}>;
export declare const ParachainsInclusionAggregateMessageOrigin: GetEnum<ParachainsInclusionAggregateMessageOrigin>;
export type ParachainsInclusionUmpQueueId = Enum<{
    "Para": number;
}>;
export declare const ParachainsInclusionUmpQueueId: GetEnum<ParachainsInclusionUmpQueueId>;
export type I5hhsj7l9obr84 = AnonymousEnum<{
    "BadFormat": undefined;
    "Corrupt": undefined;
    "Unsupported": undefined;
    "Overweight": Anonymize<I4q39t5hn830vp>;
    "Yield": undefined;
    "StackLimitReached": undefined;
}>;
export type I1tf93k54ltg1v = {
    /**
     * The `blake2_256` hash of the message.
     */
    "id": FixedSizeBinary<32>;
    /**
     * The queue of the message.
     */
    "origin": ParachainsInclusionAggregateMessageOrigin;
    /**
     * How much weight was used to process the message.
     */
    "weight_used": Anonymize<I4q39t5hn830vp>;
    /**
     * Whether the message was processed.
     *
     * Note that this does not mean that the underlying `MessageProcessor` was internally
     * successful. It *solely* means that the MQ pallet will treat this as a success
     * condition and discard the message. Any internal error needs to be emitted as events
     * by the `MessageProcessor`.
     */
    "success": boolean;
};
export type I6ove5at7hfiur = {
    /**
     * The `blake2_256` hash of the message.
     */
    "id": FixedSizeBinary<32>;
    /**
     * The queue of the message.
     */
    "origin": ParachainsInclusionAggregateMessageOrigin;
    /**
     * The page of the message.
     */
    "page_index": number;
    /**
     * The index of the message within the page.
     */
    "message_index": number;
};
export type I9c0urppp07b8b = {
    /**
     * The queue of the page.
     */
    "origin": ParachainsInclusionAggregateMessageOrigin;
    /**
     * The index of the page.
     */
    "index": number;
};
export type I1dcjapt414ijf = AnonymousEnum<{
    "AssetRateCreated": Anonymize<I9c4d50jrp7as1>;
    "AssetRateRemoved": Anonymize<Ifplevr9hp8jo3>;
    "AssetRateUpdated": Anonymize<Idrugh2blv81ia>;
}>;
export type I9c4d50jrp7as1 = {
    "asset_kind": Anonymize<I2q3ri6itcjj5u>;
    "rate": bigint;
};
export type Ifplevr9hp8jo3 = {
    "asset_kind": Anonymize<I2q3ri6itcjj5u>;
};
export type Idrugh2blv81ia = {
    "asset_kind": Anonymize<I2q3ri6itcjj5u>;
    "old": bigint;
    "new": bigint;
};
export type Ic5m5lp1oioo8r = Array<FixedSizeBinary<32>>;
export type I95g6i7ilua7lq = Array<Anonymize<I9jd27rnpm8ttv>>;
export type Ieniouoqkq4icf = {
    "spec_version": number;
    "spec_name": string;
};
export type Ib7036jci3pr35 = Array<({
    "maybe_id"?: Anonymize<I4s6vifaf8k998>;
    "priority": number;
    "call": PreimagesBounded;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "origin": Anonymize<Iarigqlp2c2plh>;
}) | undefined>;
export type Iep7au1720bm0e = (Anonymize<I9jd27rnpm8ttv>) | undefined;
export type Iarigqlp2c2plh = AnonymousEnum<{
    "system": DispatchRawOrigin;
    "Origins": GovernanceOrigin;
    "ParachainsOrigin": ParachainsOrigin;
    "XcmPallet": Anonymize<Icvilmd7qu30i4>;
}>;
export type DispatchRawOrigin = Enum<{
    "Root": undefined;
    "Signed": SS58String;
    "None": undefined;
}>;
export declare const DispatchRawOrigin: GetEnum<DispatchRawOrigin>;
export type GovernanceOrigin = Enum<{
    "StakingAdmin": undefined;
    "Treasurer": undefined;
    "FellowshipAdmin": undefined;
    "GeneralAdmin": undefined;
    "AuctionAdmin": undefined;
    "LeaseAdmin": undefined;
    "ReferendumCanceller": undefined;
    "ReferendumKiller": undefined;
    "SmallTipper": undefined;
    "BigTipper": undefined;
    "SmallSpender": undefined;
    "MediumSpender": undefined;
    "BigSpender": undefined;
    "WhitelistedCaller": undefined;
    "WishForChange": undefined;
}>;
export declare const GovernanceOrigin: GetEnum<GovernanceOrigin>;
export type ParachainsOrigin = Enum<{
    "Parachain": number;
}>;
export declare const ParachainsOrigin: GetEnum<ParachainsOrigin>;
export type Icvilmd7qu30i4 = AnonymousEnum<{
    "Xcm": Anonymize<If9iqq7i64mur8>;
    "Response": Anonymize<If9iqq7i64mur8>;
}>;
export type I56u24ncejr5kt = {
    "total_retries": number;
    "remaining": number;
    "period": number;
};
export type PreimageOldRequestStatus = Enum<{
    "Unrequested": {
        "deposit": Anonymize<I95l2k9b1re95f>;
        "len": number;
    };
    "Requested": {
        "deposit"?: Anonymize<I92hdo1clkbp4g>;
        "count": number;
        "len"?: Anonymize<I4arjljr6dpflb>;
    };
}>;
export declare const PreimageOldRequestStatus: GetEnum<PreimageOldRequestStatus>;
export type I95l2k9b1re95f = [SS58String, bigint];
export type I92hdo1clkbp4g = (Anonymize<I95l2k9b1re95f>) | undefined;
export type PreimageRequestStatus = Enum<{
    "Unrequested": {
        "ticket": Anonymize<I95l2k9b1re95f>;
        "len": number;
    };
    "Requested": {
        "maybe_ticket"?: Anonymize<I92hdo1clkbp4g>;
        "count": number;
        "maybe_len"?: Anonymize<I4arjljr6dpflb>;
    };
}>;
export declare const PreimageRequestStatus: GetEnum<PreimageRequestStatus>;
export type BabeDigestsNextConfigDescriptor = Enum<{
    "V1": Anonymize<I8jnd4d8ip6djo>;
}>;
export declare const BabeDigestsNextConfigDescriptor: GetEnum<BabeDigestsNextConfigDescriptor>;
export type I8jnd4d8ip6djo = {
    "c": Anonymize<I200n1ov5tbcvr>;
    "allowed_slots": BabeAllowedSlots;
};
export type I200n1ov5tbcvr = FixedSizeArray<2, bigint>;
export type BabeAllowedSlots = Enum<{
    "PrimarySlots": undefined;
    "PrimaryAndSecondaryPlainSlots": undefined;
    "PrimaryAndSecondaryVRFSlots": undefined;
}>;
export declare const BabeAllowedSlots: GetEnum<BabeAllowedSlots>;
export type Idq7or56ds2f13 = (BabeDigestsPreDigest) | undefined;
export type BabeDigestsPreDigest = Enum<{
    "Primary": {
        "authority_index": number;
        "slot": bigint;
        "vrf_signature": {
            "pre_output": FixedSizeBinary<32>;
            "proof": FixedSizeBinary<64>;
        };
    };
    "SecondaryPlain": {
        "authority_index": number;
        "slot": bigint;
    };
    "SecondaryVRF": {
        "authority_index": number;
        "slot": bigint;
        "vrf_signature": {
            "pre_output": FixedSizeBinary<32>;
            "proof": FixedSizeBinary<64>;
        };
    };
}>;
export declare const BabeDigestsPreDigest: GetEnum<BabeDigestsPreDigest>;
export type Ifip05kcrl65am = Array<Anonymize<I6cs1itejju2vv>>;
export type I6cs1itejju2vv = [bigint, number];
export type Iff9heri56m1mb = [SS58String, bigint, boolean];
export type I8ds64oj6581v0 = Array<{
    "id": FixedSizeBinary<8>;
    "amount": bigint;
    "reasons": BalancesTypesReasons;
}>;
export type BalancesTypesReasons = Enum<{
    "Fee": undefined;
    "Misc": undefined;
    "All": undefined;
}>;
export declare const BalancesTypesReasons: GetEnum<BalancesTypesReasons>;
export type Ia7pdug7cdsg8g = Array<{
    "id": FixedSizeBinary<8>;
    "amount": bigint;
}>;
export type I9i0gpifqjcft8 = Array<{
    "id": Enum<{
        "Preimage": PreimagePalletHoldReason;
        "Staking": Anonymize<Icbapambb5rug3>;
        "DelegatedStaking": Anonymize<Ib6ve2drlnapui>;
        "StateTrieMigration": Enum<{
            "SlashForMigrate": undefined;
        }>;
        "XcmPallet": Anonymize<Ideiof6273rsoe>;
    }>;
    "amount": bigint;
}>;
export type PreimagePalletHoldReason = Enum<{
    "Preimage": undefined;
}>;
export declare const PreimagePalletHoldReason: GetEnum<PreimagePalletHoldReason>;
export type Icbapambb5rug3 = AnonymousEnum<{
    "Staking": undefined;
}>;
export type Ib6ve2drlnapui = AnonymousEnum<{
    "StakingDelegation": undefined;
}>;
export type Ideiof6273rsoe = AnonymousEnum<{
    "AuthorizeAlias": undefined;
}>;
export type I2l1ctuihi2mfd = Array<{
    "id": WestendRuntimeRuntimeFreezeReason;
    "amount": bigint;
}>;
export type WestendRuntimeRuntimeFreezeReason = Enum<{
    "NominationPools": NominationPoolsPalletFreezeReason;
}>;
export declare const WestendRuntimeRuntimeFreezeReason: GetEnum<WestendRuntimeRuntimeFreezeReason>;
export type NominationPoolsPalletFreezeReason = Enum<{
    "PoolMinBalance": undefined;
}>;
export declare const NominationPoolsPalletFreezeReason: GetEnum<NominationPoolsPalletFreezeReason>;
export type TransactionPaymentReleases = Enum<{
    "V1Ancient": undefined;
    "V2": undefined;
}>;
export declare const TransactionPaymentReleases: GetEnum<TransactionPaymentReleases>;
export type Ia2lhg7l2hilo3 = Array<SS58String>;
export type Ic12aht5vh2sen = {
    "stash": SS58String;
    "total": bigint;
    "active": bigint;
    "unlocking": Anonymize<I9nc4v1upo2c8e>;
    "legacy_claimed_rewards": Anonymize<Icgljjb6j82uhn>;
};
export type I9nc4v1upo2c8e = Array<{
    "value": bigint;
    "era": number;
}>;
export type Ic3m9d6tdl6gi2 = {
    "targets": Anonymize<Ia2lhg7l2hilo3>;
    "submitted_in": number;
    "suppressed": boolean;
};
export type Ib3j7gb0jgs38u = {
    "index": number;
    "start"?: Anonymize<I35p85j063s0il>;
};
export type Ifekshcrgkl12g = {
    "total": bigint;
    "own": bigint;
    "others": Anonymize<I252o97fo263q7>;
};
export type I252o97fo263q7 = Array<{
    "who": SS58String;
    "value": bigint;
}>;
export type I6flrronqs3l6n = {
    "total": bigint;
    "own": bigint;
    "nominator_count": number;
    "page_count": number;
};
export type I97fulj5h3ik95 = {
    "page_total": bigint;
    "others": Anonymize<I252o97fo263q7>;
};
export type Ia8896dq44k9m4 = [number, SS58String, number];
export type Iff9p3c7k6pfoi = {
    "total": number;
    "individual": Anonymize<I205qrookusi3d>;
};
export type I205qrookusi3d = Array<Anonymize<I6ouflveob4eli>>;
export type I6ouflveob4eli = [SS58String, number];
export type Iafq6t4rgheait = Array<{
    "validator": SS58String;
    "own": bigint;
    "others": Anonymize<Iba9inugg1atvo>;
    "reporters": Anonymize<Ia2lhg7l2hilo3>;
    "payout": bigint;
}>;
export type Iba9inugg1atvo = Array<Anonymize<I95l2k9b1re95f>>;
export type I4ojmnsk1dchql = [number, bigint];
export type Iinkhfdlka9ch = {
    "span_index": number;
    "last_start": number;
    "last_nonzero_slash": number;
    "prior": Anonymize<Icgljjb6j82uhn>;
};
export type I2kj4j6mp68hf8 = {
    "slashed": bigint;
    "paid_out": bigint;
};
export type I2bqvqrg0sbrdj = {
    "offender": [SS58String, Anonymize<Ifekshcrgkl12g>];
    "reporters": Anonymize<Ia2lhg7l2hilo3>;
};
export type I23nq3fsgtejt = [FixedSizeBinary<16>, Binary];
export type Idt624nf41g34e = Array<[SS58String, Anonymize<I9kr8cseidc66h>]>;
export type I9kr8cseidc66h = {
    "grandpa": FixedSizeBinary<32>;
    "babe": FixedSizeBinary<32>;
    "para_validator": FixedSizeBinary<32>;
    "para_assignment": FixedSizeBinary<32>;
    "authority_discovery": FixedSizeBinary<32>;
    "beefy": FixedSizeBinary<33>;
};
export type GrandpaStoredState = Enum<{
    "Live": undefined;
    "PendingPause": {
        "scheduled_at": number;
        "delay": number;
    };
    "Paused": undefined;
    "PendingResume": {
        "scheduled_at": number;
        "delay": number;
    };
}>;
export declare const GrandpaStoredState: GetEnum<GrandpaStoredState>;
export type I7pe2me3i3vtn9 = {
    "scheduled_at": number;
    "delay": number;
    "next_authorities": Anonymize<I3geksg000c171>;
    "forced"?: Anonymize<I4arjljr6dpflb>;
};
export type Iegmj7n48sc3am = {
    "proposer": SS58String;
    "value": bigint;
    "beneficiary": SS58String;
    "bond": bigint;
};
export type I3s9vvjt0el98d = {
    "asset_kind": Anonymize<I2q3ri6itcjj5u>;
    "amount": bigint;
    "beneficiary": XcmVersionedLocation;
    "valid_from": number;
    "expire_at": number;
    "status": TreasuryPaymentState;
};
export type TreasuryPaymentState = Enum<{
    "Pending": undefined;
    "Attempted": Anonymize<I4ov6e94l79mbg>;
    "Failed": undefined;
}>;
export declare const TreasuryPaymentState: GetEnum<TreasuryPaymentState>;
export type I4ov6e94l79mbg = {
    "id": bigint;
};
export type ConvictionVotingVoteVoting = Enum<{
    "Casting": Anonymize<If52hjr5c5nrc5>;
    "Delegating": Anonymize<I251o9sbu5566f>;
}>;
export declare const ConvictionVotingVoteVoting: GetEnum<ConvictionVotingVoteVoting>;
export type If52hjr5c5nrc5 = {
    "votes": Anonymize<I42jj1su7asrm9>;
    "delegations": Anonymize<I538qha8r4j3ii>;
    "prior": Anonymize<I4ojmnsk1dchql>;
};
export type I42jj1su7asrm9 = Array<[number, ConvictionVotingVoteAccountVote]>;
export type I538qha8r4j3ii = {
    "votes": bigint;
    "capital": bigint;
};
export type I251o9sbu5566f = {
    "balance": bigint;
    "target": SS58String;
    "conviction": VotingConviction;
    "delegations": Anonymize<I538qha8r4j3ii>;
    "prior": Anonymize<I4ojmnsk1dchql>;
};
export type VotingConviction = Enum<{
    "None": undefined;
    "Locked1x": undefined;
    "Locked2x": undefined;
    "Locked3x": undefined;
    "Locked4x": undefined;
    "Locked5x": undefined;
    "Locked6x": undefined;
}>;
export declare const VotingConviction: GetEnum<VotingConviction>;
export type If9jidduiuq7vv = Array<Anonymize<I4ojmnsk1dchql>>;
export type I51n42d2as34oa = AnonymousEnum<{
    "Ongoing": {
        "track": number;
        "origin": Anonymize<Iarigqlp2c2plh>;
        "proposal": PreimagesBounded;
        "enactment": TraitsScheduleDispatchTime;
        "submitted": number;
        "submission_deposit": Anonymize<Id5fm4p8lj5qgi>;
        "decision_deposit"?: Anonymize<Ibd24caul84kv2>;
        "deciding"?: Anonymize<Ibcbcndfmk0jd9>;
        "tally": Anonymize<Ifsk7cbmtit1jd>;
        "in_queue": boolean;
        "alarm"?: Anonymize<I3aj03qk2o5mdm>;
    };
    "Approved": Anonymize<Ini94eljn5lj8>;
    "Rejected": Anonymize<Ini94eljn5lj8>;
    "Cancelled": Anonymize<Ini94eljn5lj8>;
    "TimedOut": Anonymize<Ini94eljn5lj8>;
    "Killed": number;
}>;
export type TraitsScheduleDispatchTime = Enum<{
    "At": number;
    "After": number;
}>;
export declare const TraitsScheduleDispatchTime: GetEnum<TraitsScheduleDispatchTime>;
export type Ibd24caul84kv2 = (Anonymize<Id5fm4p8lj5qgi>) | undefined;
export type Ibcbcndfmk0jd9 = ({
    "since": number;
    "confirming"?: Anonymize<I4arjljr6dpflb>;
}) | undefined;
export type I3aj03qk2o5mdm = ([number, Anonymize<I9jd27rnpm8ttv>]) | undefined;
export type Ini94eljn5lj8 = [number, Anonymize<Ibd24caul84kv2>, Anonymize<Ibd24caul84kv2>];
export type I2phecamkn3pej = [bigint, bigint, number];
export type ClaimsStatementKind = Enum<{
    "Regular": undefined;
    "Saft": undefined;
}>;
export declare const ClaimsStatementKind: GetEnum<ClaimsStatementKind>;
export type Ifble4juuml5ig = Array<Anonymize<I4aro1m78pdrtt>>;
export type I4aro1m78pdrtt = {
    "locked": bigint;
    "per_block": bigint;
    "starting_block": number;
};
export type Version = Enum<{
    "V0": undefined;
    "V1": undefined;
}>;
export declare const Version: GetEnum<Version>;
export type I8oad3rb9oe9n1 = [Array<{
    "delegate": SS58String;
    "proxy_type": Anonymize<I7adrgaqb51jb9>;
    "delay": number;
}>, bigint];
export type I9p9lq3rej5bhc = [Array<{
    "real": SS58String;
    "call_hash": FixedSizeBinary<32>;
    "height": number;
}>, bigint];
export type Iag146hmjgqfgj = {
    "when": Anonymize<Itvprrpb0nm3o>;
    "deposit": bigint;
    "depositor": SS58String;
    "approvals": Anonymize<Ia2lhg7l2hilo3>;
};
export type I8uo3fpd3bcc6f = [SS58String, FixedSizeBinary<32>];
export type Ict0fmb8krq1lk = {
    "proposer": SS58String;
    "value": bigint;
    "fee": bigint;
    "curator_deposit": bigint;
    "bond": bigint;
    "status": Enum<{
        "Proposed": undefined;
        "Approved": undefined;
        "Funded": undefined;
        "CuratorProposed": Anonymize<I846573mdj1pfn>;
        "Active": {
            "curator": SS58String;
            "update_due": number;
        };
        "PendingPayout": Anonymize<I4aulgjqrdphrm>;
        "ApprovedWithCurator": Anonymize<I846573mdj1pfn>;
    }>;
};
export type I846573mdj1pfn = {
    "curator": SS58String;
};
export type I4aulgjqrdphrm = {
    "curator": SS58String;
    "beneficiary": SS58String;
    "unlock_at": number;
};
export type Ibofbvvaehln4e = {
    "parent_bounty": number;
    "value": bigint;
    "fee": bigint;
    "curator_deposit": bigint;
    "status": ChildBountyStatus;
};
export type ChildBountyStatus = Enum<{
    "Added": undefined;
    "CuratorProposed": Anonymize<I846573mdj1pfn>;
    "Active": Anonymize<I846573mdj1pfn>;
    "PendingPayout": Anonymize<I4aulgjqrdphrm>;
}>;
export declare const ChildBountyStatus: GetEnum<ChildBountyStatus>;
export type Ictkaqdbfabuek = {
    "supports": Anonymize<I4bboqsv44evel>;
    "score": Anonymize<I8s6n43okuj2b1>;
    "compute": ElectionProviderMultiPhaseElectionCompute;
};
export type I4bboqsv44evel = Array<[SS58String, {
    "total": bigint;
    "voters": Anonymize<Iba9inugg1atvo>;
}]>;
export type Ia7o65280hur3p = {
    "voters": Array<[SS58String, bigint, Anonymize<Ia2lhg7l2hilo3>]>;
    "targets": Anonymize<Ia2lhg7l2hilo3>;
};
export type Iasd2iat48n080 = {
    "voters": number;
    "targets": number;
};
export type Ic8d01sg6acf60 = Array<[Anonymize<I8s6n43okuj2b1>, number, number]>;
export type Irl37q7erstrb = {
    "who": SS58String;
    "deposit": bigint;
    "raw_solution": Anonymize<I7je4n92ump862>;
    "call_fee": bigint;
};
export type I7je4n92ump862 = {
    "solution": {
        "votes1": Anonymize<Iep4uo61810hfs>;
        "votes2": Anonymize<Ickjq69hlul8c3>;
        "votes3": Anonymize<Icf645ln9bi1bj>;
        "votes4": Anonymize<I8nospv7k5s457>;
        "votes5": Anonymize<Iig9pofg77rah>;
        "votes6": Anonymize<Irttjt9tghoc0>;
        "votes7": Anonymize<I3o5epjr2va0dl>;
        "votes8": Anonymize<I1gfnebceebqb5>;
        "votes9": Anonymize<Ibo38fh2dhj4it>;
        "votes10": Anonymize<Id4gvspmdh8h9l>;
        "votes11": Anonymize<I5be3ho5m1r68a>;
        "votes12": Anonymize<I7s2sh7cpuv56r>;
        "votes13": Anonymize<I5fq8855gfhmlo>;
        "votes14": Anonymize<I4mvok713k4g7o>;
        "votes15": Anonymize<I90tu9lmjmhfhd>;
        "votes16": Anonymize<I3cqaev9m4hn9m>;
    };
    "score": Anonymize<I8s6n43okuj2b1>;
    "round": number;
};
export type Iep4uo61810hfs = Array<Anonymize<I5g2vv0ckl2m8b>>;
export type I5g2vv0ckl2m8b = [number, number];
export type Ickjq69hlul8c3 = Array<[number, Anonymize<I5g2vv0ckl2m8b>, number]>;
export type Icf645ln9bi1bj = Array<[number, FixedSizeArray<2, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type I8nospv7k5s457 = Array<[number, FixedSizeArray<3, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type Iig9pofg77rah = Array<[number, FixedSizeArray<4, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type Irttjt9tghoc0 = Array<[number, FixedSizeArray<5, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type I3o5epjr2va0dl = Array<[number, FixedSizeArray<6, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type I1gfnebceebqb5 = Array<[number, FixedSizeArray<7, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type Ibo38fh2dhj4it = Array<[number, FixedSizeArray<8, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type Id4gvspmdh8h9l = Array<[number, FixedSizeArray<9, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type I5be3ho5m1r68a = Array<[number, FixedSizeArray<10, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type I7s2sh7cpuv56r = Array<[number, FixedSizeArray<11, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type I5fq8855gfhmlo = Array<[number, FixedSizeArray<12, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type I4mvok713k4g7o = Array<[number, FixedSizeArray<13, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type I90tu9lmjmhfhd = Array<[number, FixedSizeArray<14, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type I3cqaev9m4hn9m = Array<[number, FixedSizeArray<15, Anonymize<I5g2vv0ckl2m8b>>, number]>;
export type Ic5t26f9cp3tvk = {
    "id": SS58String;
    "prev"?: Anonymize<Ihfphjolmsqq1>;
    "next"?: Anonymize<Ihfphjolmsqq1>;
    "bag_upper": bigint;
    "score": bigint;
};
export type I39k39h6vu4hbq = {
    "head"?: Anonymize<Ihfphjolmsqq1>;
    "tail"?: Anonymize<Ihfphjolmsqq1>;
};
export type Idphjddn2h69vc = {
    "pool_id": number;
    "points": bigint;
    "last_recorded_reward_counter": bigint;
    "unbonding_eras": Anonymize<If9jidduiuq7vv>;
};
export type Idhh9vuu2bderg = {
    "commission": {
        "current"?: Anonymize<Ie8iutm7u02lmj>;
        "max"?: Anonymize<I4arjljr6dpflb>;
        "change_rate"?: (Anonymize<Ibqul338t9c1ll>) | undefined;
        "throttle_from"?: Anonymize<I4arjljr6dpflb>;
        "claim_permission"?: Anonymize<I16m1kn78dee7v>;
    };
    "member_counter": number;
    "points": bigint;
    "roles": {
        "depositor": SS58String;
        "root"?: Anonymize<Ihfphjolmsqq1>;
        "nominator"?: Anonymize<Ihfphjolmsqq1>;
        "bouncer"?: Anonymize<Ihfphjolmsqq1>;
    };
    "state": NominationPoolsPoolState;
};
export type If6qa32dj75gu1 = {
    "last_recorded_reward_counter": bigint;
    "last_recorded_total_payouts": bigint;
    "total_rewards_claimed": bigint;
    "total_commission_pending": bigint;
    "total_commission_claimed": bigint;
};
export type I7oo2mprv1qd1s = {
    "no_era": Anonymize<I4h0cfnkiqrna6>;
    "with_era": Array<[number, Anonymize<I4h0cfnkiqrna6>]>;
};
export type I4h0cfnkiqrna6 = {
    "points": bigint;
    "balance": bigint;
};
export type I2eh80qovrl7h2 = {
    "stashes": Anonymize<Iba9inugg1atvo>;
    "checked": Anonymize<Icgljjb6j82uhn>;
};
export type I542q009qbgt8k = {
    "agent": SS58String;
    "amount": bigint;
};
export type I4e5ujckjq61g8 = {
    "payee": SS58String;
    "total_delegated": bigint;
    "unclaimed_withdrawals": bigint;
    "pending_slash": bigint;
};
export type Idinvj2ldfa0k7 = {
    "max_code_size": number;
    "max_head_data_size": number;
    "max_upward_queue_count": number;
    "max_upward_queue_size": number;
    "max_upward_message_size": number;
    "max_upward_message_num_per_candidate": number;
    "hrmp_max_message_num_per_candidate": number;
    "validation_upgrade_cooldown": number;
    "validation_upgrade_delay": number;
    "async_backing_params": Anonymize<Iavuvfkop6318c>;
    "max_pov_size": number;
    "max_downward_message_size": number;
    "hrmp_max_parachain_outbound_channels": number;
    "hrmp_sender_deposit": bigint;
    "hrmp_recipient_deposit": bigint;
    "hrmp_channel_max_capacity": number;
    "hrmp_channel_max_total_size": number;
    "hrmp_max_parachain_inbound_channels": number;
    "hrmp_channel_max_message_size": number;
    "executor_params": Anonymize<I80rnntpog8qp6>;
    "code_retention_period": number;
    "max_validators"?: Anonymize<I4arjljr6dpflb>;
    "dispute_period": number;
    "dispute_post_conclusion_acceptance_period": number;
    "no_show_slots": number;
    "n_delay_tranches": number;
    "zeroth_delay_tranche_width": number;
    "needed_approvals": number;
    "relay_vrf_modulo_samples": number;
    "pvf_voting_ttl": number;
    "minimum_validation_upgrade_delay": number;
    "minimum_backing_votes": number;
    "node_features": {
        bytes: Uint8Array;
        bitsLen: number;
    };
    "approval_voting_params": number;
    "scheduler_params": Anonymize<I555j7pvb27qd5>;
};
export type Iavuvfkop6318c = {
    "max_candidate_depth": number;
    "allowed_ancestry_len": number;
};
export type I80rnntpog8qp6 = Array<PolkadotPrimitivesV6ExecutorParamsExecutorParam>;
export type PolkadotPrimitivesV6ExecutorParamsExecutorParam = Enum<{
    "MaxMemoryPages": number;
    "StackLogicalMax": number;
    "StackNativeMax": number;
    "PrecheckingMaxMemory": bigint;
    "PvfPrepTimeout": [PolkadotPrimitivesV6PvfPrepKind, bigint];
    "PvfExecTimeout": [PvfExecKind, bigint];
    "WasmExtBulkMemory": undefined;
}>;
export declare const PolkadotPrimitivesV6ExecutorParamsExecutorParam: GetEnum<PolkadotPrimitivesV6ExecutorParamsExecutorParam>;
export type PolkadotPrimitivesV6PvfPrepKind = Enum<{
    "Precheck": undefined;
    "Prepare": undefined;
}>;
export declare const PolkadotPrimitivesV6PvfPrepKind: GetEnum<PolkadotPrimitivesV6PvfPrepKind>;
export type PvfExecKind = Enum<{
    "Backing": undefined;
    "Approval": undefined;
}>;
export declare const PvfExecKind: GetEnum<PvfExecKind>;
export type I555j7pvb27qd5 = {
    "group_rotation_frequency": number;
    "paras_availability_period": number;
    "max_validators_per_core"?: Anonymize<I4arjljr6dpflb>;
    "lookahead": number;
    "num_cores": number;
    "max_availability_timeouts": number;
    "on_demand_queue_max_size": number;
    "on_demand_target_queue_utilization": number;
    "on_demand_fee_variability": number;
    "on_demand_base_fee": bigint;
    "ttl": number;
};
export type I78k2970vpbt1t = Array<[number, Anonymize<Idinvj2ldfa0k7>]>;
export type I2d4k4cqluhq5i = {
    "buffer": Array<{
        "relay_parent": FixedSizeBinary<32>;
        "state_root": FixedSizeBinary<32>;
        "claim_queue": Array<[number, Anonymize<I9olhgo2o08h7b>]>;
    }>;
    "latest_number": number;
};
export type I9olhgo2o08h7b = Array<[number, Anonymize<Icgljjb6j82uhn>]>;
export type I91e9aiuocql92 = Array<{
    "core": number;
    "hash": FixedSizeBinary<32>;
    "descriptor": Anonymize<Ibnq2mkuf1plno>;
    "commitments": Anonymize<Ic1d4u2opv3fst>;
    "availability_votes": {
        bytes: Uint8Array;
        bitsLen: number;
    };
    "backers": {
        bytes: Uint8Array;
        bitsLen: number;
    };
    "relay_parent_number": number;
    "backed_in_number": number;
    "backing_group": number;
}>;
export type Ic1d4u2opv3fst = {
    "upward_messages": Anonymize<Itom7fk49o0c9>;
    "horizontal_messages": Anonymize<I6r5cbv8ttrb09>;
    "new_validation_code"?: Anonymize<Iabpgqcjikia83>;
    "head_data": Binary;
    "processed_downward_messages": number;
    "hrmp_watermark": number;
};
export type Itom7fk49o0c9 = Array<Binary>;
export type I6r5cbv8ttrb09 = Array<{
    "recipient": number;
    "data": Binary;
}>;
export type Iabpgqcjikia83 = (Binary) | undefined;
export type Ia1viqq9k85bv1 = {
    "session": number;
    "backing_validators_per_candidate": Array<[Anonymize<Iceqied2dhrjit>, Array<[number, ValidityAttestation]>]>;
    "disputes": Anonymize<Ibt1op6l47p1r2>;
};
export type ValidityAttestation = Enum<{
    "Implicit": FixedSizeBinary<64>;
    "Explicit": FixedSizeBinary<64>;
}>;
export declare const ValidityAttestation: GetEnum<ValidityAttestation>;
export type Ibt1op6l47p1r2 = Array<{
    "candidate_hash": FixedSizeBinary<32>;
    "session": number;
    "statements": Array<[PolkadotPrimitivesV6DisputeStatement, number, FixedSizeBinary<64>]>;
}>;
export type PolkadotPrimitivesV6DisputeStatement = Enum<{
    "Valid": PolkadotPrimitivesV6ValidDisputeStatementKind;
    "Invalid": InvalidDisputeStatementKind;
}>;
export declare const PolkadotPrimitivesV6DisputeStatement: GetEnum<PolkadotPrimitivesV6DisputeStatement>;
export type PolkadotPrimitivesV6ValidDisputeStatementKind = Enum<{
    "Explicit": undefined;
    "BackingSeconded": FixedSizeBinary<32>;
    "BackingValid": FixedSizeBinary<32>;
    "ApprovalChecking": undefined;
    "ApprovalCheckingMultipleCandidates": Anonymize<Ic5m5lp1oioo8r>;
}>;
export declare const PolkadotPrimitivesV6ValidDisputeStatementKind: GetEnum<PolkadotPrimitivesV6ValidDisputeStatementKind>;
export type InvalidDisputeStatementKind = Enum<{
    "Explicit": undefined;
}>;
export declare const InvalidDisputeStatementKind: GetEnum<InvalidDisputeStatementKind>;
export type Iarlj3qd8u1v13 = Array<Anonymize<Icgljjb6j82uhn>>;
export type Idp9imcf15rli1 = Array<[number, Array<PolkadotRuntimeParachainsSchedulerCommonAssignment>]>;
export type PolkadotRuntimeParachainsSchedulerCommonAssignment = Enum<{
    "Pool": {
        "para_id": number;
        "core_index": number;
    };
    "Bulk": number;
}>;
export declare const PolkadotRuntimeParachainsSchedulerCommonAssignment: GetEnum<PolkadotRuntimeParachainsSchedulerCommonAssignment>;
export type I4vk12npmr8ll0 = {
    "votes_accept": {
        bytes: Uint8Array;
        bitsLen: number;
    };
    "votes_reject": {
        bytes: Uint8Array;
        bitsLen: number;
    };
    "age": number;
    "created_at": number;
    "causes": Array<Enum<{
        "Onboarding": number;
        "Upgrade": {
            "id": number;
            "included_at": number;
            "upgrade_strategy": Enum<{
                "SetGoAheadSignal": undefined;
                "ApplyAtExpectedBlock": undefined;
            }>;
        };
    }>>;
};
export type ParachainsParasParaLifecycle = Enum<{
    "Onboarding": undefined;
    "Parathread": undefined;
    "Parachain": undefined;
    "UpgradingParathread": undefined;
    "DowngradingParachain": undefined;
    "OffboardingParathread": undefined;
    "OffboardingParachain": undefined;
}>;
export declare const ParachainsParasParaLifecycle: GetEnum<ParachainsParasParaLifecycle>;
export type I79cs1p3m59mo7 = {
    "upgrade_times": Array<{
        "expected_at": number;
        "activated_at": number;
    }>;
    "last_pruned"?: Anonymize<I4arjljr6dpflb>;
};
export type UpgradeGoAhead = Enum<{
    "Abort": undefined;
    "GoAhead": undefined;
}>;
export declare const UpgradeGoAhead: GetEnum<UpgradeGoAhead>;
export type UpgradeRestriction = Enum<{
    "Present": undefined;
}>;
export declare const UpgradeRestriction: GetEnum<UpgradeRestriction>;
export type I2duhnt686rv0q = {
    "genesis_head": Binary;
    "validation_code": Binary;
    "para_kind": boolean;
};
export type I7ulu3h1ibu60i = Array<{
    "validators": Anonymize<Ic5m5lp1oioo8r>;
    "queued": Anonymize<Ic5m5lp1oioo8r>;
    "session_index": number;
}>;
export type I6ljjd4b5fa4ov = Array<{
    "sent_at": number;
    "msg": Binary;
}>;
export type Ibhmrlkcu01imb = {
    "confirmed": boolean;
    "_age": number;
    "sender_deposit": bigint;
    "max_message_size": number;
    "max_capacity": number;
    "max_total_size": number;
};
export type Id43g4eveajpkl = Array<Anonymize<I50mrcbubp554e>>;
export type I7iua3ehrgl4va = {
    "max_capacity": number;
    "max_total_size": number;
    "max_message_size": number;
    "msg_count": number;
    "total_size": number;
    "mqc_head"?: Anonymize<I4s6vifaf8k998>;
    "sender_deposit": bigint;
    "recipient_deposit": bigint;
};
export type Iev3u09i2vqn93 = Array<{
    "sent_at": number;
    "data": Binary;
}>;
export type I9m4rd2a7lc9md = {
    "active_validator_indices": Anonymize<Icgljjb6j82uhn>;
    "random_seed": FixedSizeBinary<32>;
    "dispute_period": number;
    "validators": Anonymize<Ic5m5lp1oioo8r>;
    "discovery_keys": Anonymize<Ic5m5lp1oioo8r>;
    "assignment_keys": Anonymize<Ic5m5lp1oioo8r>;
    "validator_groups": Anonymize<Iarlj3qd8u1v13>;
    "n_cores": number;
    "zeroth_delay_tranche_width": number;
    "relay_vrf_modulo_samples": number;
    "n_delay_tranches": number;
    "no_show_slots": number;
    "needed_approvals": number;
};
export type I87u7jalc0lhah = {
    "validators_for": {
        bytes: Uint8Array;
        bitsLen: number;
    };
    "validators_against": {
        bytes: Uint8Array;
        bitsLen: number;
    };
    "start": number;
    "concluded_at"?: Anonymize<I4arjljr6dpflb>;
};
export type I4p5t2krb1gmvp = [number, FixedSizeBinary<32>];
export type Ids3ua6tfbgvj0 = {
    "keys": Anonymize<Iqnbvitf7a7l3>;
    "kind": Anonymize<I9ng4p85mim3lc>;
};
export type Iqnbvitf7a7l3 = Array<Anonymize<I4p5t2krb1gmvp>>;
export type I9ng4p85mim3lc = AnonymousEnum<{
    "ForInvalidBacked": undefined;
    "AgainstValid": undefined;
    "ForInvalidApproved": undefined;
}>;
export type I4akf1ifqeclef = {
    "core_index": number;
    "count": number;
};
export type Ido5stnsbghtpd = {
    "traffic": bigint;
    "next_index": number;
    "smallest_index": number;
    "freed_indices": Anonymize<Icgljjb6j82uhn>;
};
export type I3ndpvu09rj685 = Array<{
    "para_id": number;
    "idx": number;
}>;
export type Iafqnechp3omqg = Array<bigint>;
export type I9dasmua8326io = {
    "assignments": Anonymize<Idt36labebpqsd>;
    "end_hint"?: Anonymize<I4arjljr6dpflb>;
    "next_schedule"?: Anonymize<I4arjljr6dpflb>;
};
export type Idt36labebpqsd = Array<[BrokerCoretimeInterfaceCoreAssignment, number]>;
export type BrokerCoretimeInterfaceCoreAssignment = Enum<{
    "Idle": undefined;
    "Pool": undefined;
    "Task": number;
}>;
export declare const BrokerCoretimeInterfaceCoreAssignment: GetEnum<BrokerCoretimeInterfaceCoreAssignment>;
export type I3g90iebhds6kb = {
    "queue"?: ({
        "first": number;
        "last": number;
    }) | undefined;
    "current_work"?: ({
        "assignments": Array<[BrokerCoretimeInterfaceCoreAssignment, {
            "ratio": number;
            "remaining": number;
        }]>;
        "end_hint"?: Anonymize<I4arjljr6dpflb>;
        "pos": number;
        "step": number;
    }) | undefined;
};
export type I3av628q6dt6mq = {
    "manager": SS58String;
    "deposit": bigint;
    "locked"?: Anonymize<I8ie0dco0kcuq5>;
};
export type I8ie0dco0kcuq5 = (boolean) | undefined;
export type Ifmaahl40gom3g = Array<Anonymize<I92hdo1clkbp4g>>;
export type I70iuri2ilha1f = FixedSizeArray<36, (Anonymize<I7fcree6lak6uv>) | undefined>;
export type I7fcree6lak6uv = [SS58String, number, bigint];
export type I6gun5k9fbb4s0 = {
    "depositor": SS58String;
    "verifier"?: Anonymize<I21lmi57mmu91l>;
    "deposit": bigint;
    "raised": bigint;
    "end": number;
    "cap": bigint;
    "last_contribution": CommonCrowdloanLastContribution;
    "first_period": number;
    "last_period": number;
    "fund_index": number;
};
export type I21lmi57mmu91l = (MultiSigner) | undefined;
export type MultiSigner = Enum<{
    "Ed25519": FixedSizeBinary<32>;
    "Sr25519": FixedSizeBinary<32>;
    "Ecdsa": FixedSizeBinary<33>;
}>;
export declare const MultiSigner: GetEnum<MultiSigner>;
export type CommonCrowdloanLastContribution = Enum<{
    "Never": undefined;
    "PreEnding": number;
    "Ending": number;
}>;
export declare const CommonCrowdloanLastContribution: GetEnum<CommonCrowdloanLastContribution>;
export type If354jrdedj0pj = {
    "progress_top": Anonymize<I1ufmh6d8psvik>;
    "progress_child": Anonymize<I1ufmh6d8psvik>;
    "size": number;
    "top_items": number;
    "child_items": number;
};
export type I1ufmh6d8psvik = AnonymousEnum<{
    "ToStart": undefined;
    "LastKey": Binary;
    "Complete": undefined;
}>;
export type Ib17t3992hb64n = (Anonymize<I215mkl885p4da>) | undefined;
export type I215mkl885p4da = {
    "size": number;
    "item": number;
};
export type I5qfubnuvrnqn6 = AnonymousEnum<{
    "Pending": {
        "responder": XcmVersionedLocation;
        "maybe_match_querier"?: (XcmVersionedLocation) | undefined;
        "maybe_notify"?: (FixedSizeBinary<2>) | undefined;
        "timeout": number;
    };
    "VersionNotifier": {
        "origin": XcmVersionedLocation;
        "is_active": boolean;
    };
    "Ready": {
        "response": Enum<{
            "V3": XcmV3Response;
            "V4": XcmV4Response;
            "V5": Anonymize<I7vucpgm2c6959>;
        }>;
        "at": number;
    };
}>;
export type XcmV3Response = Enum<{
    "Null": undefined;
    "Assets": Anonymize<Iai6dhqiq3bach>;
    "ExecutionResult"?: Anonymize<I7sltvf8v2nure>;
    "Version": number;
    "PalletsInfo": Anonymize<I599u7h20b52at>;
    "DispatchResult": XcmV3MaybeErrorCode;
}>;
export declare const XcmV3Response: GetEnum<XcmV3Response>;
export type I7sltvf8v2nure = ([number, XcmV3TraitsError]) | undefined;
export type XcmV3TraitsError = Enum<{
    "Overflow": undefined;
    "Unimplemented": undefined;
    "UntrustedReserveLocation": undefined;
    "UntrustedTeleportLocation": undefined;
    "LocationFull": undefined;
    "LocationNotInvertible": undefined;
    "BadOrigin": undefined;
    "InvalidLocation": undefined;
    "AssetNotFound": undefined;
    "FailedToTransactAsset": undefined;
    "NotWithdrawable": undefined;
    "LocationCannotHold": undefined;
    "ExceedsMaxMessageSize": undefined;
    "DestinationUnsupported": undefined;
    "Transport": undefined;
    "Unroutable": undefined;
    "UnknownClaim": undefined;
    "FailedToDecode": undefined;
    "MaxWeightInvalid": undefined;
    "NotHoldingFees": undefined;
    "TooExpensive": undefined;
    "Trap": bigint;
    "ExpectationFalse": undefined;
    "PalletNotFound": undefined;
    "NameMismatch": undefined;
    "VersionIncompatible": undefined;
    "HoldingWouldOverflow": undefined;
    "ExportError": undefined;
    "ReanchorFailed": undefined;
    "NoDeal": undefined;
    "FeesNotMet": undefined;
    "LockError": undefined;
    "NoPermission": undefined;
    "Unanchored": undefined;
    "NotDepositable": undefined;
    "UnhandledXcmVersion": undefined;
    "WeightLimitReached": Anonymize<I4q39t5hn830vp>;
    "Barrier": undefined;
    "WeightNotComputable": undefined;
    "ExceedsStackLimit": undefined;
}>;
export declare const XcmV3TraitsError: GetEnum<XcmV3TraitsError>;
export type XcmV4Response = Enum<{
    "Null": undefined;
    "Assets": Anonymize<I50mli3hb64f9b>;
    "ExecutionResult"?: Anonymize<I7sltvf8v2nure>;
    "Version": number;
    "PalletsInfo": Anonymize<I599u7h20b52at>;
    "DispatchResult": XcmV3MaybeErrorCode;
}>;
export declare const XcmV4Response: GetEnum<XcmV4Response>;
export type I8t3u2dv73ahbd = [number, XcmVersionedLocation];
export type I7vlvrrl2pnbgk = [bigint, Anonymize<I4q39t5hn830vp>, number];
export type Ie0rpl5bahldfk = Array<[XcmVersionedLocation, number]>;
export type XcmPalletVersionMigrationStage = Enum<{
    "MigrateSupportedVersion": undefined;
    "MigrateVersionNotifiers": undefined;
    "NotifyCurrentTargets"?: Anonymize<Iabpgqcjikia83>;
    "MigrateAndNotifyOldTargets": undefined;
}>;
export declare const XcmPalletVersionMigrationStage: GetEnum<XcmPalletVersionMigrationStage>;
export type I7e5oaj2qi4kl1 = {
    "amount": bigint;
    "owner": XcmVersionedLocation;
    "locker": XcmVersionedLocation;
    "consumers": Array<[undefined, bigint]>;
};
export type Ie849h3gncgvok = [number, SS58String, XcmVersionedAssetId];
export type XcmVersionedAssetId = Enum<{
    "V3": XcmV3MultiassetAssetId;
    "V4": Anonymize<I4c0s5cioidn76>;
    "V5": Anonymize<If9iqq7i64mur8>;
}>;
export declare const XcmVersionedAssetId: GetEnum<XcmVersionedAssetId>;
export type Iat62vud7hlod2 = Array<[bigint, XcmVersionedLocation]>;
export type Ici7ejds60vj52 = {
    "aliasers": Array<{
        "location": XcmVersionedLocation;
        "expiry"?: Anonymize<I35p85j063s0il>;
    }>;
};
export type I260m120dp9sbk = {
    "begin": number;
    "end": number;
    "count": number;
    "ready_neighbours"?: ({
        "prev": ParachainsInclusionAggregateMessageOrigin;
        "next": ParachainsInclusionAggregateMessageOrigin;
    }) | undefined;
    "message_count": bigint;
    "size": bigint;
};
export type I53esa2ms463bk = {
    "remaining": number;
    "remaining_size": number;
    "first_index": number;
    "first": number;
    "last": number;
    "heap": Binary;
};
export type I1lfimt2mpej64 = [ParachainsInclusionAggregateMessageOrigin, number];
export type I2fb54desdqd9n = Array<FixedSizeBinary<33>>;
export type Idjett00s2gd = {
    "id": bigint;
    "len": number;
    "keyset_commitment": FixedSizeBinary<32>;
};
export type In7a38730s6qs = {
    "base_block": Anonymize<I4q39t5hn830vp>;
    "max_block": Anonymize<I4q39t5hn830vp>;
    "per_class": {
        "normal": {
            "base_extrinsic": Anonymize<I4q39t5hn830vp>;
            "max_extrinsic"?: Anonymize<Iasb8k6ash5mjn>;
            "max_total"?: Anonymize<Iasb8k6ash5mjn>;
            "reserved"?: Anonymize<Iasb8k6ash5mjn>;
        };
        "operational": {
            "base_extrinsic": Anonymize<I4q39t5hn830vp>;
            "max_extrinsic"?: Anonymize<Iasb8k6ash5mjn>;
            "max_total"?: Anonymize<Iasb8k6ash5mjn>;
            "reserved"?: Anonymize<Iasb8k6ash5mjn>;
        };
        "mandatory": {
            "base_extrinsic": Anonymize<I4q39t5hn830vp>;
            "max_extrinsic"?: Anonymize<Iasb8k6ash5mjn>;
            "max_total"?: Anonymize<Iasb8k6ash5mjn>;
            "reserved"?: Anonymize<Iasb8k6ash5mjn>;
        };
    };
};
export type If15el53dd76v9 = {
    "normal": number;
    "operational": number;
    "mandatory": number;
};
export type I9s0ave7t0vnrk = {
    "read": bigint;
    "write": bigint;
};
export type I4fo08joqmcqnm = {
    "spec_name": string;
    "impl_name": string;
    "authoring_version": number;
    "spec_version": number;
    "impl_version": number;
    "apis": Array<[FixedSizeBinary<8>, number]>;
    "transaction_version": number;
    "system_version": number;
};
export type Ibafpkl9hhno69 = Array<[number, {
    "name": string;
    "max_deciding": number;
    "decision_deposit": bigint;
    "prepare_period": number;
    "decision_period": number;
    "confirm_period": number;
    "min_enactment_period": number;
    "min_approval": ReferendaTypesCurve;
    "min_support": ReferendaTypesCurve;
}]>;
export type ReferendaTypesCurve = Enum<{
    "LinearDecreasing": {
        "length": number;
        "floor": number;
        "ceil": number;
    };
    "SteppedDecreasing": {
        "begin": number;
        "end": number;
        "step": number;
        "period": number;
    };
    "Reciprocal": {
        "factor": bigint;
        "x_offset": bigint;
        "y_offset": bigint;
    };
}>;
export declare const ReferendaTypesCurve: GetEnum<ReferendaTypesCurve>;
export type Iekve0i6djpd9f = AnonymousEnum<{
    /**
     * Make some on-chain remark.
     *
     * Can be executed by every `origin`.
     */
    "remark": Anonymize<I8ofcg5rbj0g2c>;
    /**
     * Set the number of pages in the WebAssembly environment's heap.
     */
    "set_heap_pages": Anonymize<I4adgbll7gku4i>;
    /**
     * Set the new runtime code.
     */
    "set_code": Anonymize<I6pjjpfvhvcfru>;
    /**
     * Set the new runtime code without doing any checks of the given `code`.
     *
     * Note that runtime upgrades will not run if this is called with a not-increasing spec
     * version!
     */
    "set_code_without_checks": Anonymize<I6pjjpfvhvcfru>;
    /**
     * Set some items of storage.
     */
    "set_storage": Anonymize<I9pj91mj79qekl>;
    /**
     * Kill some items from storage.
     */
    "kill_storage": Anonymize<I39uah9nss64h9>;
    /**
     * Kill all storage items with a key that starts with the given prefix.
     *
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     */
    "kill_prefix": Anonymize<Ik64dknsq7k08>;
    /**
     * Make some on-chain remark and emit event.
     */
    "remark_with_event": Anonymize<I8ofcg5rbj0g2c>;
    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * This call requires Root origin.
     */
    "authorize_upgrade": Anonymize<Ib51vk42m1po4n>;
    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * WARNING: This authorizes an upgrade that will take place without any safety checks, for
     * example that the spec name remains the same and that the version number increases. Not
     * recommended for normal use. Use `authorize_upgrade` instead.
     *
     * This call requires Root origin.
     */
    "authorize_upgrade_without_checks": Anonymize<Ib51vk42m1po4n>;
    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
     * the new `code` in the same block or attempt to schedule the upgrade.
     *
     * All origins are allowed.
     */
    "apply_authorized_upgrade": Anonymize<I6pjjpfvhvcfru>;
}>;
export type I8ofcg5rbj0g2c = {
    "remark": Binary;
};
export type I4adgbll7gku4i = {
    "pages": bigint;
};
export type I6pjjpfvhvcfru = {
    "code": Binary;
};
export type I9pj91mj79qekl = {
    "items": Array<Anonymize<Idkbvh6dahk1v7>>;
};
export type Idkbvh6dahk1v7 = FixedSizeArray<2, Binary>;
export type I39uah9nss64h9 = {
    "keys": Anonymize<Itom7fk49o0c9>;
};
export type Ik64dknsq7k08 = {
    "prefix": Binary;
    "subkeys": number;
};
export type Ib51vk42m1po4n = {
    "code_hash": FixedSizeBinary<32>;
};
export type Idmih7a3dohotq = AnonymousEnum<{
    /**
     * Anonymously schedule a task.
     */
    "schedule": Anonymize<Id9ebe06i9tg65>;
    /**
     * Cancel an anonymously scheduled task.
     */
    "cancel": Anonymize<I5n4sebgkfr760>;
    /**
     * Schedule a named task.
     */
    "schedule_named": Anonymize<I5f8lr6595dhpv>;
    /**
     * Cancel a named scheduled task.
     */
    "cancel_named": Anonymize<Ifs1i5fk9cqvr6>;
    /**
     * Anonymously schedule a task after a delay.
     */
    "schedule_after": Anonymize<I8vkrotg6qm77c>;
    /**
     * Schedule a named task after a delay.
     */
    "schedule_named_after": Anonymize<I54okh5uq3usbi>;
    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     */
    "set_retry": Anonymize<Ieg3fd8p4pkt10>;
    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     */
    "set_retry_named": Anonymize<I8kg5ll427kfqq>;
    /**
     * Removes the retry configuration of a task.
     */
    "cancel_retry": Anonymize<I467333262q1l9>;
    /**
     * Cancel the retry configuration of a named task.
     */
    "cancel_retry_named": Anonymize<Ifs1i5fk9cqvr6>;
}>;
export type Id9ebe06i9tg65 = {
    "when": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I5f8lr6595dhpv = {
    "id": FixedSizeBinary<32>;
    "when": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type Ifs1i5fk9cqvr6 = {
    "id": FixedSizeBinary<32>;
};
export type I8vkrotg6qm77c = {
    "after": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I54okh5uq3usbi = {
    "id": FixedSizeBinary<32>;
    "after": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type Ieg3fd8p4pkt10 = {
    "task": Anonymize<I9jd27rnpm8ttv>;
    "retries": number;
    "period": number;
};
export type I8kg5ll427kfqq = {
    "id": FixedSizeBinary<32>;
    "retries": number;
    "period": number;
};
export type I467333262q1l9 = {
    "task": Anonymize<I9jd27rnpm8ttv>;
};
export type If81ks88t5mpk5 = AnonymousEnum<{
    /**
     * Register a preimage on-chain.
     *
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     */
    "note_preimage": Anonymize<I82nfqfkd48n10>;
    /**
     * Clear an unrequested preimage from the runtime storage.
     *
     * If `len` is provided, then it will be a much cheaper operation.
     *
     * - `hash`: The hash of the preimage to be removed from the store.
     * - `len`: The length of the preimage of `hash`.
     */
    "unnote_preimage": Anonymize<I1jm8m1rh9e20v>;
    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     *
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     */
    "request_preimage": Anonymize<I1jm8m1rh9e20v>;
    /**
     * Clear a previously made request for a preimage.
     *
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     */
    "unrequest_preimage": Anonymize<I1jm8m1rh9e20v>;
    /**
     * Ensure that the bulk of pre-images is upgraded.
     *
     * The caller pays no fee if at least 90% of pre-images were successfully updated.
     */
    "ensure_updated": Anonymize<I3o5j3bli1pd8e>;
}>;
export type I82nfqfkd48n10 = {
    "bytes": Binary;
};
export type I3o5j3bli1pd8e = {
    "hashes": Anonymize<Ic5m5lp1oioo8r>;
};
export type I1jeo0dpbkma5g = AnonymousEnum<{
    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     */
    "report_equivocation": Anonymize<I50ppnqasq4tjq>;
    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    "report_equivocation_unsigned": Anonymize<I50ppnqasq4tjq>;
    /**
     * Plan an epoch config change. The epoch config change is recorded and will be enacted on
     * the next call to `enact_epoch_change`. The config will be activated one epoch after.
     * Multiple calls to this method will replace any existing planned config change that had
     * not been enacted yet.
     */
    "plan_config_change": Anonymize<I9fin09kkg0jaj>;
}>;
export type I50ppnqasq4tjq = {
    "equivocation_proof": Anonymize<I68ii5ik8avr9o>;
    "key_owner_proof": Anonymize<I3ia7aufsoj0l1>;
};
export type I68ii5ik8avr9o = {
    "offender": FixedSizeBinary<32>;
    "slot": bigint;
    "first_header": Anonymize<Ic952bubvq4k7d>;
    "second_header": Anonymize<Ic952bubvq4k7d>;
};
export type Ic952bubvq4k7d = {
    "parent_hash": FixedSizeBinary<32>;
    "number": number;
    "state_root": FixedSizeBinary<32>;
    "extrinsics_root": FixedSizeBinary<32>;
    "digest": Anonymize<I4mddgoa69c0a2>;
};
export type I3ia7aufsoj0l1 = {
    "session": number;
    "trie_nodes": Anonymize<Itom7fk49o0c9>;
    "validator_count": number;
};
export type I9fin09kkg0jaj = {
    "config": BabeDigestsNextConfigDescriptor;
};
export type I7d75gqfg6jh9c = AnonymousEnum<{
    /**
     * Set the current time.
     *
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     *
     * The timestamp should be greater than the previous one by the amount specified by
     * [`Config::MinimumPeriod`].
     *
     * The dispatch origin for this call must be _None_.
     *
     * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
     * that changing the complexity of this call could result exhausting the resources in a
     * block to execute any other calls.
     *
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
     * `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     */
    "set": Anonymize<Idcr6u6361oad9>;
}>;
export type Idcr6u6361oad9 = {
    "now": bigint;
};
export type I67ac6i6ihmvpt = AnonymousEnum<{
    /**
     * Assign an previously unassigned index.
     *
     * Payment: `Deposit` is reserved from the sender account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `index`: the index to be claimed. This must not be in use.
     *
     * Emits `IndexAssigned` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "claim": Anonymize<I666bl2fqjkejo>;
    /**
     * Assign an index already owned by the sender to another account. The balance reservation
     * is effectively transferred to the new account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `index`: the index to be re-assigned. This must be owned by the sender.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     *
     * Emits `IndexAssigned` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "transfer": Anonymize<I6o1er683vod1j>;
    /**
     * Free up an index owned by the sender.
     *
     * Payment: Any previous deposit placed for the index is unreserved in the sender account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must own the index.
     *
     * - `index`: the index to be freed. This must be owned by the sender.
     *
     * Emits `IndexFreed` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "free": Anonymize<I666bl2fqjkejo>;
    /**
     * Force an index to an account. This doesn't require a deposit. If the index is already
     * held, then any deposit is reimbursed to its current owner.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `index`: the index to be (re-)assigned.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
     *
     * Emits `IndexAssigned` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "force_transfer": Anonymize<I5bq561t4gpfva>;
    /**
     * Freeze an index so it will always point to the sender account. This consumes the
     * deposit.
     *
     * The dispatch origin for this call must be _Signed_ and the signing account must have a
     * non-frozen account `index`.
     *
     * - `index`: the index to be frozen in place.
     *
     * Emits `IndexFrozen` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "freeze": Anonymize<I666bl2fqjkejo>;
    /**
     * Poke the deposit reserved for an index.
     *
     * The dispatch origin for this call must be _Signed_ and the signing account must have a
     * non-frozen account `index`.
     *
     * The transaction fees is waived if the deposit is changed after poking/reconsideration.
     *
     * - `index`: the index whose deposit is to be poked/reconsidered.
     *
     * Emits `DepositPoked` if successful.
     */
    "poke_deposit": Anonymize<I666bl2fqjkejo>;
}>;
export type I6o1er683vod1j = {
    "new": MultiAddress;
    "index": number;
};
export type MultiAddress = Enum<{
    "Id": SS58String;
    "Index": undefined;
    "Raw": Binary;
    "Address32": FixedSizeBinary<32>;
    "Address20": FixedSizeBinary<20>;
}>;
export declare const MultiAddress: GetEnum<MultiAddress>;
export type I5bq561t4gpfva = {
    "new": MultiAddress;
    "index": number;
    "freeze": boolean;
};
export type I9svldsp29mh87 = AnonymousEnum<{
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     */
    "transfer_allow_death": Anonymize<I4ktuaksf5i1gk>;
    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     */
    "force_transfer": Anonymize<I9bqtpv2ii35mp>;
    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     */
    "transfer_keep_alive": Anonymize<I4ktuaksf5i1gk>;
    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     */
    "transfer_all": Anonymize<I9j7pagd6d4bda>;
    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     */
    "force_unreserve": Anonymize<I2h9pmio37r7fb>;
    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     */
    "upgrade_accounts": Anonymize<Ibmr18suc9ikh9>;
    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     */
    "force_set_balance": Anonymize<I9iq22t0burs89>;
    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     */
    "force_adjust_total_issuance": Anonymize<I5u8olqbbvfnvf>;
    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     */
    "burn": Anonymize<I5utcetro501ir>;
}>;
export type I4ktuaksf5i1gk = {
    "dest": MultiAddress;
    "value": bigint;
};
export type I9bqtpv2ii35mp = {
    "source": MultiAddress;
    "dest": MultiAddress;
    "value": bigint;
};
export type I9j7pagd6d4bda = {
    "dest": MultiAddress;
    "keep_alive": boolean;
};
export type I2h9pmio37r7fb = {
    "who": MultiAddress;
    "amount": bigint;
};
export type Ibmr18suc9ikh9 = {
    "who": Anonymize<Ia2lhg7l2hilo3>;
};
export type I9iq22t0burs89 = {
    "who": MultiAddress;
    "new_free": bigint;
};
export type I5u8olqbbvfnvf = {
    "direction": BalancesAdjustmentDirection;
    "delta": bigint;
};
export type BalancesAdjustmentDirection = Enum<{
    "Increase": undefined;
    "Decrease": undefined;
}>;
export declare const BalancesAdjustmentDirection: GetEnum<BalancesAdjustmentDirection>;
export type I5utcetro501ir = {
    "value": bigint;
    "keep_alive": boolean;
};
export type Icm294co91mkfj = AnonymousEnum<{
    /**
     * Take the origin account as a stash and lock up `value` of its balance. `controller` will
     * be the account that controls it.
     *
     * `value` must be more than the `minimum_balance` specified by `T::Currency`.
     *
     * The dispatch origin for this call must be _Signed_ by the stash account.
     *
     * Emits `Bonded`.
     * ## Complexity
     * - Independent of the arguments. Moderate complexity.
     * - O(1).
     * - Three extra DB entries.
     *
     * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
     * unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed
     * as dust.
     */
    "bond": Anonymize<I2eip8tc75dpje>;
    /**
     * Add some extra amount that have appeared in the stash `free_balance` into the balance up
     * for staking.
     *
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     *
     * Use this if there are additional funds in your stash account that you wish to bond.
     * Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
     * any limitation on the amount that can be added.
     *
     * Emits `Bonded`.
     *
     * ## Complexity
     * - Independent of the arguments. Insignificant complexity.
     * - O(1).
     */
    "bond_extra": Anonymize<I564va64vtidbq>;
    /**
     * Schedule a portion of the stash to be unlocked ready for transfer out after the bond
     * period ends. If this leaves an amount actively bonded less than
     * [`asset::existential_deposit`], then it is increased to the full amount.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * Once the unlock period is done, you can call `withdraw_unbonded` to actually move
     * the funds out of management ready for transfer.
     *
     * No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
     * can co-exists at the same time. If there are no unlocking chunks slots available
     * [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
     *
     * If a user encounters the `InsufficientBond` error when calling this extrinsic,
     * they should call `chill` first in order to free up their bonded funds.
     *
     * Emits `Unbonded`.
     *
     * See also [`Call::withdraw_unbonded`].
     */
    "unbond": Anonymize<Ie5v6njpckr05b>;
    /**
     * Remove any unlocked chunks from the `unlocking` queue from our management.
     *
     * This essentially frees up that balance to be used by the stash account to do whatever
     * it wants.
     *
     * The dispatch origin for this call must be _Signed_ by the controller.
     *
     * Emits `Withdrawn`.
     *
     * See also [`Call::unbond`].
     *
     * ## Parameters
     *
     * - `num_slashing_spans` indicates the number of metadata slashing spans to clear when
     * this call results in a complete removal of all the data related to the stash account.
     * In this case, the `num_slashing_spans` must be larger or equal to the number of
     * slashing spans associated with the stash account in the [`SlashingSpans`] storage type,
     * otherwise the call will fail. The call weight is directly proportional to
     * `num_slashing_spans`.
     *
     * ## Complexity
     * O(S) where S is the number of slashing spans to remove
     * NOTE: Weight annotation is the kill scenario, we refund otherwise.
     */
    "withdraw_unbonded": Anonymize<I328av3j0bgmjb>;
    /**
     * Declare the desire to validate for the origin controller.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     */
    "validate": Anonymize<I4tuqm9ato907i>;
    /**
     * Declare the desire to nominate `targets` for the origin controller.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * ## Complexity
     * - The transaction's complexity is proportional to the size of `targets` (N)
     * which is capped at CompactAssignments::LIMIT (T::MaxNominations).
     * - Both the reads and writes follow a similar pattern.
     */
    "nominate": Anonymize<Iagi89qt4h1lqg>;
    /**
     * Declare no desire to either validate or nominate.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * ## Complexity
     * - Independent of the arguments. Insignificant complexity.
     * - Contains one read.
     * - Writes are limited to the `origin` account key.
     */
    "chill": undefined;
    /**
     * (Re-)set the payment target for a controller.
     *
     * Effects will be felt instantly (as soon as this function is completed successfully).
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * ## Complexity
     * - O(1)
     * - Independent of the arguments. Insignificant complexity.
     * - Contains a limited number of reads.
     * - Writes are limited to the `origin` account key.
     * ---------
     */
    "set_payee": Anonymize<I9dgmcnuamt5p8>;
    /**
     * (Re-)sets the controller of a stash to the stash itself. This function previously
     * accepted a `controller` argument to set the controller to an account other than the
     * stash itself. This functionality has now been removed, now only setting the controller
     * to the stash, if it is not already.
     *
     * Effects will be felt instantly (as soon as this function is completed successfully).
     *
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     *
     * ## Complexity
     * O(1)
     * - Independent of the arguments. Insignificant complexity.
     * - Contains a limited number of reads.
     * - Writes are limited to the `origin` account key.
     */
    "set_controller": undefined;
    /**
     * Sets the ideal number of validators.
     *
     * The dispatch origin must be Root.
     *
     * ## Complexity
     * O(1)
     */
    "set_validator_count": Anonymize<I3vh014cqgmrfd>;
    /**
     * Increments the ideal number of validators up to maximum of
     * `ElectionProviderBase::MaxWinners`.
     *
     * The dispatch origin must be Root.
     *
     * ## Complexity
     * Same as [`Self::set_validator_count`].
     */
    "increase_validator_count": Anonymize<Ifhs60omlhvt3>;
    /**
     * Scale up the ideal number of validators by a factor up to maximum of
     * `ElectionProviderBase::MaxWinners`.
     *
     * The dispatch origin must be Root.
     *
     * ## Complexity
     * Same as [`Self::set_validator_count`].
     */
    "scale_validator_count": Anonymize<If34udpd5e57vi>;
    /**
     * Force there to be no new eras indefinitely.
     *
     * The dispatch origin must be Root.
     *
     * # Warning
     *
     * The election process starts multiple blocks before the end of the era.
     * Thus the election process may be ongoing when this is called. In this case the
     * election will continue until the next era is triggered.
     *
     * ## Complexity
     * - No arguments.
     * - Weight: O(1)
     */
    "force_no_eras": undefined;
    /**
     * Force there to be a new era at the end of the next session. After this, it will be
     * reset to normal (non-forced) behaviour.
     *
     * The dispatch origin must be Root.
     *
     * # Warning
     *
     * The election process starts multiple blocks before the end of the era.
     * If this is called just before a new era is triggered, the election process may not
     * have enough blocks to get a result.
     *
     * ## Complexity
     * - No arguments.
     * - Weight: O(1)
     */
    "force_new_era": undefined;
    /**
     * Set the validators who cannot be slashed (if any).
     *
     * The dispatch origin must be Root.
     */
    "set_invulnerables": Anonymize<I39t01nnod9109>;
    /**
     * Force a current staker to become completely unstaked, immediately.
     *
     * The dispatch origin must be Root.
     *
     * ## Parameters
     *
     * - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
     * details.
     */
    "force_unstake": Anonymize<Ie5vbnd9198quk>;
    /**
     * Force there to be a new era at the end of sessions indefinitely.
     *
     * The dispatch origin must be Root.
     *
     * # Warning
     *
     * The election process starts multiple blocks before the end of the era.
     * If this is called just before a new era is triggered, the election process may not
     * have enough blocks to get a result.
     */
    "force_new_era_always": undefined;
    /**
     * Cancel enactment of a deferred slash.
     *
     * Can be called by the `T::AdminOrigin`.
     *
     * Parameters: era and indices of the slashes for that era to kill.
     */
    "cancel_deferred_slash": Anonymize<I3h6murn8bd4v5>;
    /**
     * Pay out next page of the stakers behind a validator for the given era.
     *
     * - `validator_stash` is the stash account of the validator.
     * - `era` may be any era between `[current_era - history_depth; current_era]`.
     *
     * The origin of this call must be _Signed_. Any account can call this function, even if
     * it is not one of the stakers.
     *
     * The reward payout could be paged in case there are too many nominators backing the
     * `validator_stash`. This call will payout unpaid pages in an ascending order. To claim a
     * specific page, use `payout_stakers_by_page`.`
     *
     * If all pages are claimed, it returns an error `InvalidPage`.
     */
    "payout_stakers": Anonymize<I6k6jf8ncesuu3>;
    /**
     * Rebond a portion of the stash scheduled to be unlocked.
     *
     * The dispatch origin must be signed by the controller.
     *
     * ## Complexity
     * - Time complexity: O(L), where L is unlocking chunks
     * - Bounded by `MaxUnlockingChunks`.
     */
    "rebond": Anonymize<Ie5v6njpckr05b>;
    /**
     * Remove all data structures concerning a staker/stash once it is at a state where it can
     * be considered `dust` in the staking system. The requirements are:
     *
     * 1. the `total_balance` of the stash is below existential deposit.
     * 2. or, the `ledger.total` of the stash is below existential deposit.
     * 3. or, existential deposit is zero and either `total_balance` or `ledger.total` is zero.
     *
     * The former can happen in cases like a slash; the latter when a fully unbonded account
     * is still receiving staking rewards in `RewardDestination::Staked`.
     *
     * It can be called by anyone, as long as `stash` meets the above requirements.
     *
     * Refunds the transaction fees upon successful execution.
     *
     * ## Parameters
     *
     * - `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more
     * details.
     */
    "reap_stash": Anonymize<Ie5vbnd9198quk>;
    /**
     * Remove the given nominations from the calling validator.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *
     * - `who`: A list of nominator stash accounts who are nominating this validator which
     * should no longer be nominating this validator.
     *
     * Note: Making this call only makes sense if you first set the validator preferences to
     * block any further nominations.
     */
    "kick": Anonymize<I3qhk481i120pk>;
    /**
     * Update the various staking configurations .
     *
     * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     * * `min_validator_bond`: The minimum active bond needed to be a validator.
     * * `max_nominator_count`: The max number of users who can be a nominator at once. When
     * set to `None`, no limit is enforced.
     * * `max_validator_count`: The max number of users who can be a validator at once. When
     * set to `None`, no limit is enforced.
     * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
     * should be filled in order for the `chill_other` transaction to work.
     * * `min_commission`: The minimum amount of commission that each validators must maintain.
     * This is checked only upon calling `validate`. Existing validators are not affected.
     *
     * RuntimeOrigin must be Root to call this function.
     *
     * NOTE: Existing nominators and validators will not be affected by this update.
     * to kick people under the new limits, `chill_other` should be called.
     */
    "set_staking_configs": Anonymize<If1qr0kbbl298c>;
    /**
     * Declare a `controller` to stop participating as either a validator or nominator.
     *
     * Effects will be felt at the beginning of the next era.
     *
     * The dispatch origin for this call must be _Signed_, but can be called by anyone.
     *
     * If the caller is the same as the controller being targeted, then no further checks are
     * enforced, and this function behaves just like `chill`.
     *
     * If the caller is different than the controller being targeted, the following conditions
     * must be met:
     *
     * * `controller` must belong to a nominator who has become non-decodable,
     *
     * Or:
     *
     * * A `ChillThreshold` must be set and checked which defines how close to the max
     * nominators or validators we must reach before users can start chilling one-another.
     * * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
     * how close we are to the threshold.
     * * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
     * if this is a person that should be chilled because they have not met the threshold
     * bond required.
     *
     * This can be helpful if bond requirements are updated, and we need to remove old users
     * who do not satisfy these requirements.
     */
    "chill_other": Anonymize<Idl3umm12u5pa>;
    /**
     * Force a validator to have at least the minimum commission. This will not affect a
     * validator who already has a commission greater than or equal to the minimum. Any account
     * can call this.
     */
    "force_apply_min_commission": Anonymize<I5ont0141q9ss5>;
    /**
     * Sets the minimum amount of commission that each validators must maintain.
     *
     * This call has lower privilege requirements than `set_staking_config` and can be called
     * by the `T::AdminOrigin`. Root can always call this.
     */
    "set_min_commission": Anonymize<I3vh014cqgmrfd>;
    /**
     * Pay out a page of the stakers behind a validator for the given era and page.
     *
     * - `validator_stash` is the stash account of the validator.
     * - `era` may be any era between `[current_era - history_depth; current_era]`.
     * - `page` is the page index of nominators to pay out with value between 0 and
     * `num_nominators / T::MaxExposurePageSize`.
     *
     * The origin of this call must be _Signed_. Any account can call this function, even if
     * it is not one of the stakers.
     *
     * If a validator has more than [`Config::MaxExposurePageSize`] nominators backing
     * them, then the list of nominators is paged, with each page being capped at
     * [`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,
     * the call needs to be made for each page separately in order for all the nominators
     * backing a validator to receive the reward. The nominators are not sorted across pages
     * and so it should not be assumed the highest staker would be on the topmost page and vice
     * versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost.
     */
    "payout_stakers_by_page": Anonymize<Ie6j49utvii126>;
    /**
     * Migrates an account's `RewardDestination::Controller` to
     * `RewardDestination::Account(controller)`.
     *
     * Effects will be felt instantly (as soon as this function is completed successfully).
     *
     * This will waive the transaction fee if the `payee` is successfully migrated.
     */
    "update_payee": Anonymize<I3v6ks33uluhnj>;
    /**
     * Updates a batch of controller accounts to their corresponding stash account if they are
     * not the same. Ignores any controller accounts that do not exist, and does not operate if
     * the stash and controller are already the same.
     *
     * Effects will be felt instantly (as soon as this function is completed successfully).
     *
     * The dispatch origin must be `T::AdminOrigin`.
     */
    "deprecate_controller_batch": Anonymize<I3kiiim1cds68i>;
    /**
     * Restores the state of a ledger which is in an inconsistent state.
     *
     * The requirements to restore a ledger are the following:
     * * The stash is bonded; or
     * * The stash is not bonded but it has a staking lock left behind; or
     * * If the stash has an associated ledger and its state is inconsistent; or
     * * If the ledger is not corrupted *but* its staking lock is out of sync.
     *
     * The `maybe_*` input parameters will overwrite the corresponding data and metadata of the
     * ledger associated with the stash. If the input parameters are not set, the ledger will
     * be reset values from on-chain state.
     */
    "restore_ledger": Anonymize<I4k60mkh2r6jjg>;
    /**
     * Removes the legacy Staking locks if they exist.
     *
     * This removes the legacy lock on the stake with [`Config::OldCurrency`] and creates a
     * hold on it if needed. If all stake cannot be held, the best effort is made to hold as
     * much as possible. The remaining stake is forced withdrawn from the ledger.
     *
     * The fee is waived if the migration is successful.
     */
    "migrate_currency": Anonymize<Idl3umm12u5pa>;
    /**
     * This function allows governance to manually slash a validator and is a
     * **fallback mechanism**.
     *
     * The dispatch origin must be `T::AdminOrigin`.
     *
     * ## Parameters
     * - `validator_stash` - The stash account of the validator to slash.
     * - `era` - The era in which the validator was in the active set.
     * - `slash_fraction` - The percentage of the stake to slash, expressed as a Perbill.
     *
     * ## Behavior
     *
     * The slash will be applied using the standard slashing mechanics, respecting the
     * configured `SlashDeferDuration`.
     *
     * This means:
     * - If the validator was already slashed by a higher percentage for the same era, this
     * slash will have no additional effect.
     * - If the validator was previously slashed by a lower percentage, only the difference
     * will be applied.
     * - The slash will be deferred by `SlashDeferDuration` eras before being enacted.
     */
    "manual_slash": Anonymize<Ic5njrpnvi3f8g>;
}>;
export type I2eip8tc75dpje = {
    "value": bigint;
    "payee": StakingRewardDestination;
};
export type I564va64vtidbq = {
    "max_additional": bigint;
};
export type I328av3j0bgmjb = {
    "num_slashing_spans": number;
};
export type I4tuqm9ato907i = {
    "prefs": Anonymize<I9o7ssi9vmhmgr>;
};
export type Iagi89qt4h1lqg = {
    "targets": Anonymize<I28gn91b2ttnbk>;
};
export type I28gn91b2ttnbk = Array<MultiAddress>;
export type I9dgmcnuamt5p8 = {
    "payee": StakingRewardDestination;
};
export type I3vh014cqgmrfd = {
    "new": number;
};
export type Ifhs60omlhvt3 = {
    "additional": number;
};
export type If34udpd5e57vi = {
    "factor": number;
};
export type I39t01nnod9109 = {
    "invulnerables": Anonymize<Ia2lhg7l2hilo3>;
};
export type Ie5vbnd9198quk = {
    "stash": SS58String;
    "num_slashing_spans": number;
};
export type I3h6murn8bd4v5 = {
    "era": number;
    "slash_indices": Anonymize<Icgljjb6j82uhn>;
};
export type I6k6jf8ncesuu3 = {
    "validator_stash": SS58String;
    "era": number;
};
export type I3qhk481i120pk = {
    "who": Anonymize<I28gn91b2ttnbk>;
};
export type If1qr0kbbl298c = {
    "min_nominator_bond": StakingPalletConfigOpBig;
    "min_validator_bond": StakingPalletConfigOpBig;
    "max_nominator_count": StakingPalletConfigOp;
    "max_validator_count": StakingPalletConfigOp;
    "chill_threshold": StakingPalletConfigOp;
    "min_commission": StakingPalletConfigOp;
    "max_staked_rewards": StakingPalletConfigOp;
};
export type StakingPalletConfigOpBig = Enum<{
    "Noop": undefined;
    "Set": bigint;
    "Remove": undefined;
}>;
export declare const StakingPalletConfigOpBig: GetEnum<StakingPalletConfigOpBig>;
export type StakingPalletConfigOp = Enum<{
    "Noop": undefined;
    "Set": number;
    "Remove": undefined;
}>;
export declare const StakingPalletConfigOp: GetEnum<StakingPalletConfigOp>;
export type I5ont0141q9ss5 = {
    "validator_stash": SS58String;
};
export type Ie6j49utvii126 = {
    "validator_stash": SS58String;
    "era": number;
    "page": number;
};
export type I3v6ks33uluhnj = {
    "controller": SS58String;
};
export type I3kiiim1cds68i = {
    "controllers": Anonymize<Ia2lhg7l2hilo3>;
};
export type I4k60mkh2r6jjg = {
    "stash": SS58String;
    "maybe_controller"?: Anonymize<Ihfphjolmsqq1>;
    "maybe_total"?: Anonymize<I35p85j063s0il>;
    "maybe_unlocking"?: (Anonymize<I9nc4v1upo2c8e>) | undefined;
};
export type Ic5njrpnvi3f8g = {
    "validator_stash": SS58String;
    "era": number;
    "slash_fraction": number;
};
export type Iceajactc9a8pc = AnonymousEnum<{
    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be signed.
     *
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     * fixed.
     */
    "set_keys": Anonymize<I5oi8saufice6j>;
    /**
     * Removes any session key(s) of the function caller.
     *
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     *
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     * `T::Keys::key_ids()` which is fixed.
     */
    "purge_keys": undefined;
}>;
export type I5oi8saufice6j = {
    "keys": Anonymize<I9kr8cseidc66h>;
    "proof": Binary;
};
export type I5u9ggmn8umfqm = AnonymousEnum<{
    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     */
    "report_equivocation": Anonymize<I7ne83r38c2sqq>;
    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    "report_equivocation_unsigned": Anonymize<I7ne83r38c2sqq>;
    /**
     * Note that the current authority set of the GRANDPA finality gadget has stalled.
     *
     * This will trigger a forced authority set change at the beginning of the next session, to
     * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
     * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
     * The block production rate (which may be slowed down because of finality lagging) should
     * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
     * authority will start voting on top of `best_finalized_block_number` for new finalized
     * blocks. `best_finalized_block_number` should be the highest of the latest finalized
     * block of all validators of the new authority set.
     *
     * Only callable by root.
     */
    "note_stalled": Anonymize<I2hviml3snvhhn>;
}>;
export type I7ne83r38c2sqq = {
    "equivocation_proof": Anonymize<I9puqgoda8ofk4>;
    "key_owner_proof": Anonymize<I3ia7aufsoj0l1>;
};
export type I9puqgoda8ofk4 = {
    "set_id": bigint;
    "equivocation": GrandpaEquivocation;
};
export type GrandpaEquivocation = Enum<{
    "Prevote": {
        "round_number": bigint;
        "identity": FixedSizeBinary<32>;
        "first": [Anonymize<I8e06chr1md241>, FixedSizeBinary<64>];
        "second": [Anonymize<I8e06chr1md241>, FixedSizeBinary<64>];
    };
    "Precommit": {
        "round_number": bigint;
        "identity": FixedSizeBinary<32>;
        "first": [Anonymize<I8e06chr1md241>, FixedSizeBinary<64>];
        "second": [Anonymize<I8e06chr1md241>, FixedSizeBinary<64>];
    };
}>;
export declare const GrandpaEquivocation: GetEnum<GrandpaEquivocation>;
export type I8e06chr1md241 = {
    "target_hash": FixedSizeBinary<32>;
    "target_number": number;
};
export type I2hviml3snvhhn = {
    "delay": number;
    "best_finalized_block_number": number;
};
export type I6jnp85onk3m8j = AnonymousEnum<{
    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
     *
     * ### Details
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     *
     * ### Parameters
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     *
     * ## Events
     *
     * Emits [`Event::SpendApproved`] if successful.
     */
    "spend_local": Anonymize<Icnrv1mfbd3in1>;
    /**
     * Force a previously approved proposal to be removed from the approval queue.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * The original deposit will no longer be returned.
     *
     * ### Parameters
     * - `proposal_id`: The index of a proposal
     *
     * ### Complexity
     * - O(A) where `A` is the number of approvals
     *
     * ### Errors
     * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
     * approval queue, i.e., the proposal has not been approved. This could also mean the
     * proposal does not exist altogether, thus there is no way it would have been approved
     * in the first place.
     */
    "remove_approval": Anonymize<Icm9m0qeemu66d>;
    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least
     * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
     * for assertion using the [`Config::BalanceConverter`].
     *
     * ## Details
     *
     * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
     * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
     * the [`Config::PayoutPeriod`].
     *
     * ### Parameters
     * - `asset_kind`: An indicator of the specific asset class to be spent.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The beneficiary of the spend.
     * - `valid_from`: The block number from which the spend can be claimed. It can refer to
     * the past if the resulting spend has not yet expired according to the
     * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
     * approval.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendApproved`] if successful.
     */
    "spend": Anonymize<I3pnhorh539dti>;
    /**
     * Claim a spend.
     *
     * ## Dispatch Origin
     *
     * Must be signed
     *
     * ## Details
     *
     * Spends must be claimed within some temporal bounds. A spend may be claimed within one
     * [`Config::PayoutPeriod`] from the `valid_from` block.
     * In case of a payout failure, the spend status must be updated with the `check_status`
     * dispatchable before retrying with the current function.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::Paid`] if successful.
     */
    "payout": Anonymize<I666bl2fqjkejo>;
    /**
     * Check the status of the spend and remove it from the storage if processed.
     *
     * ## Dispatch Origin
     *
     * Must be signed.
     *
     * ## Details
     *
     * The status check is a prerequisite for retrying a failed payout.
     * If a spend has either succeeded or expired, it is removed from the storage by this
     * function. In such instances, transaction fees are refunded.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::PaymentFailed`] if the spend payout has failed.
     * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
     */
    "check_status": Anonymize<I666bl2fqjkejo>;
    /**
     * Void previously approved spend.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * A spend void is only possible if the payout has not been attempted yet.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendVoided`] if successful.
     */
    "void_spend": Anonymize<I666bl2fqjkejo>;
}>;
export type Icnrv1mfbd3in1 = {
    "amount": bigint;
    "beneficiary": MultiAddress;
};
export type Icm9m0qeemu66d = {
    "proposal_id": number;
};
export type I3pnhorh539dti = {
    "asset_kind": Anonymize<I2q3ri6itcjj5u>;
    "amount": bigint;
    "beneficiary": XcmVersionedLocation;
    "valid_from"?: Anonymize<I4arjljr6dpflb>;
};
export type Ie5kd08tutk56t = AnonymousEnum<{
    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     *
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     */
    "vote": Anonymize<Idnsr2pndm36h0>;
    /**
     * Delegate the voting power (with some given conviction) of the sending account for a
     * particular class of polls.
     *
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     *
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     * - be delegating already; or
     * - have no voting activity (if there is, then it will need to be removed through
     * `remove_vote`).
     *
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
     * to this function are required.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     * account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     * be more than the account's current balance.
     *
     * Emits `Delegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    "delegate": Anonymize<Ia1pvdcbhuqf8m>;
    /**
     * Undelegate the voting power of the sending account for a particular class of polls.
     *
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued has passed.
     *
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     *
     * - `class`: The class of polls to remove the delegation from.
     *
     * Emits `Undelegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    "undelegate": Anonymize<I8steo882k7qns>;
    /**
     * Remove the lock caused by prior voting/delegating which has expired within a particular
     * class.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     *
     * Weight: `O(R)` with R number of vote of target.
     */
    "unlock": Anonymize<I4pa4q37gj6fua>;
    /**
     * Remove a vote for a poll.
     *
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     * - the vote of the account was in opposition to the result; or
     * - there was no conviction to the account's vote; or
     * - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     *
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     *
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     *
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     * which have finished or are cancelled, this must be `Some`.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     */
    "remove_vote": Anonymize<I5f178ab6b89t3>;
    /**
     * Remove a vote for a poll.
     *
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     * `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     */
    "remove_other_vote": Anonymize<I4nakhtbsk3c5s>;
}>;
export type Idnsr2pndm36h0 = {
    "poll_index": number;
    "vote": ConvictionVotingVoteAccountVote;
};
export type Ia1pvdcbhuqf8m = {
    "class": number;
    "to": MultiAddress;
    "conviction": VotingConviction;
    "balance": bigint;
};
export type I8steo882k7qns = {
    "class": number;
};
export type I4pa4q37gj6fua = {
    "class": number;
    "target": MultiAddress;
};
export type I5f178ab6b89t3 = {
    "class"?: Anonymize<I4arjljr6dpflb>;
    "index": number;
};
export type I4nakhtbsk3c5s = {
    "target": MultiAddress;
    "class": number;
    "index": number;
};
export type I8tu311hskajnl = AnonymousEnum<{
    /**
     * Propose a referendum on a privileged action.
     *
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     * available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     *
     * Emits `Submitted`.
     */
    "submit": Anonymize<I5uepe23r4qqta>;
    /**
     * Post the Decision Deposit for a referendum.
     *
     * - `origin`: must be `Signed` and the account must have funds available for the
     * referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     * posted.
     *
     * Emits `DecisionDepositPlaced`.
     */
    "place_decision_deposit": Anonymize<I666bl2fqjkejo>;
    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     * refunded.
     *
     * Emits `DecisionDepositRefunded`.
     */
    "refund_decision_deposit": Anonymize<I666bl2fqjkejo>;
    /**
     * Cancel an ongoing referendum.
     *
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Cancelled`.
     */
    "cancel": Anonymize<I666bl2fqjkejo>;
    /**
     * Cancel an ongoing referendum and slash the deposits.
     *
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Killed` and `DepositSlashed`.
     */
    "kill": Anonymize<I666bl2fqjkejo>;
    /**
     * Advance a referendum onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     */
    "nudge_referendum": Anonymize<I666bl2fqjkejo>;
    /**
     * Advance a track onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     *
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     */
    "one_fewer_deciding": Anonymize<Icbio0e1f0034b>;
    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     * refunded.
     *
     * Emits `SubmissionDepositRefunded`.
     */
    "refund_submission_deposit": Anonymize<I666bl2fqjkejo>;
    /**
     * Set or clear metadata of a referendum.
     *
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     * metadata of a finished referendum.
     * - `index`:  The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     */
    "set_metadata": Anonymize<I8c0vkqjjipnuj>;
}>;
export type I5uepe23r4qqta = {
    "proposal_origin": Anonymize<Iarigqlp2c2plh>;
    "proposal": PreimagesBounded;
    "enactment_moment": TraitsScheduleDispatchTime;
};
export type Icbio0e1f0034b = {
    "track": number;
};
export type I8c0vkqjjipnuj = {
    "index": number;
    "maybe_hash"?: Anonymize<I4s6vifaf8k998>;
};
export type Icqvg77845cnfe = AnonymousEnum<{
    "whitelist_call": Anonymize<I1adbcfi5uc62r>;
    "remove_whitelisted_call": Anonymize<I1adbcfi5uc62r>;
    "dispatch_whitelisted_call": Anonymize<Ibf6ucefn8fh49>;
    "dispatch_whitelisted_call_with_preimage": Anonymize<I89s00psqp91m8>;
}>;
export type Ibf6ucefn8fh49 = {
    "call_hash": FixedSizeBinary<32>;
    "call_encoded_len": number;
    "call_weight_witness": Anonymize<I4q39t5hn830vp>;
};
export type I89s00psqp91m8 = {
    "call": TxCallData;
};
export type Id0dj18ct09hlp = AnonymousEnum<{
    /**
     * Make a claim to collect your DOTs.
     *
     * The dispatch origin for this call must be _None_.
     *
     * Unsigned Validation:
     * A call to claim is deemed valid if the signature provided matches
     * the expected signed message of:
     *
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)
     *
     * and `address` matches the `dest` account.
     *
     * Parameters:
     * - `dest`: The destination account to payout the claim.
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     * described above.
     *
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to validate unsigned `claim` call.
     *
     * Total Complexity: O(1)
     * </weight>
     */
    "claim": Anonymize<I6uag8j5aql8q>;
    /**
     * Mint a new claim to collect DOTs.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * Parameters:
     * - `who`: The Ethereum address allowed to collect this claim.
     * - `value`: The number of DOTs that will be claimed.
     * - `vesting_schedule`: An optional vesting schedule for these DOTs.
     *
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * We assume worst case that both vesting and statement is being inserted.
     *
     * Total Complexity: O(1)
     * </weight>
     */
    "mint_claim": Anonymize<Isq3k9rh2c0l4>;
    /**
     * Make a claim to collect your DOTs by signing a statement.
     *
     * The dispatch origin for this call must be _None_.
     *
     * Unsigned Validation:
     * A call to `claim_attest` is deemed valid if the signature provided matches
     * the expected signed message of:
     *
     * > Ethereum Signed Message:
     * > (configured prefix string)(address)(statement)
     *
     * and `address` matches the `dest` account; the `statement` must match that which is
     * expected according to your purchase arrangement.
     *
     * Parameters:
     * - `dest`: The destination account to payout the claim.
     * - `ethereum_signature`: The signature of an ethereum signed message matching the format
     * described above.
     * - `statement`: The identity of the statement which is being attested to in the
     * signature.
     *
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to validate unsigned `claim_attest` call.
     *
     * Total Complexity: O(1)
     * </weight>
     */
    "claim_attest": Anonymize<I1dqiovk0tpoah>;
    /**
     * Attest to a statement, needed to finalize the claims process.
     *
     * WARNING: Insecure unless your chain includes `PrevalidateAttests` as a
     * `TransactionExtension`.
     *
     * Unsigned Validation:
     * A call to attest is deemed valid if the sender has a `Preclaim` registered
     * and provides a `statement` which is expected for the account.
     *
     * Parameters:
     * - `statement`: The identity of the statement which is being attested to in the
     * signature.
     *
     * <weight>
     * The weight of this call is invariant over the input parameters.
     * Weight includes logic to do pre-validation on `attest` call.
     *
     * Total Complexity: O(1)
     * </weight>
     */
    "attest": Anonymize<I1ntko0oih7v1a>;
    "move_claim": Anonymize<I2tf5qmg09624f>;
}>;
export type I6uag8j5aql8q = {
    "dest": SS58String;
    "ethereum_signature": FixedSizeBinary<65>;
};
export type Isq3k9rh2c0l4 = {
    "who": FixedSizeBinary<20>;
    "value": bigint;
    "vesting_schedule"?: (Anonymize<I2phecamkn3pej>) | undefined;
    "statement"?: (ClaimsStatementKind) | undefined;
};
export type I1dqiovk0tpoah = {
    "dest": SS58String;
    "ethereum_signature": FixedSizeBinary<65>;
    "statement": Binary;
};
export type I1ntko0oih7v1a = {
    "statement": Binary;
};
export type I2tf5qmg09624f = {
    "old": FixedSizeBinary<20>;
    "new": FixedSizeBinary<20>;
    "maybe_preclaim"?: Anonymize<Ihfphjolmsqq1>;
};
export type Icgf8vmtkbnu4u = AnonymousEnum<{
    /**
     * Unlock any vested funds of the sender account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "vest": undefined;
    /**
     * Unlock any vested funds of a `target` account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account whose vested funds should be unlocked. Must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "vest_other": Anonymize<Id9uqtigc0il3v>;
    /**
     * Create a vested transfer.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account receiving the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "vested_transfer": Anonymize<Iaa2o6cgjdpdn5>;
    /**
     * Force a vested transfer.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `source`: The account whose funds should be transferred.
     * - `target`: The account that should be transferred the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "force_vested_transfer": Anonymize<Iam6hrl7ptd85l>;
    /**
     * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
     * the highest possible start and end blocks. If both schedules have already started the
     * current block will be used as the schedule start; with the caveat that if one schedule
     * is finished by the current block, the other will be treated as the new merged schedule,
     * unmodified.
     *
     * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
     * NOTE: This will unlock all schedules through the current block prior to merging.
     * NOTE: If both schedules have ended by the current block, no new schedule will be created
     * and both will be removed.
     *
     * Merged schedule attributes:
     * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
     * current_block)`.
     * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
     * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `schedule1_index`: index of the first schedule to merge.
     * - `schedule2_index`: index of the second schedule to merge.
     */
    "merge_schedules": Anonymize<Ict9ivhr2c5hv0>;
    /**
     * Force remove a vesting schedule
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `target`: An account that has a vesting schedule
     * - `schedule_index`: The vesting schedule index that should be removed
     */
    "force_remove_vesting_schedule": Anonymize<I8t4vv03357lk9>;
}>;
export type Id9uqtigc0il3v = {
    "target": MultiAddress;
};
export type Iaa2o6cgjdpdn5 = {
    "target": MultiAddress;
    "schedule": Anonymize<I4aro1m78pdrtt>;
};
export type Iam6hrl7ptd85l = {
    "source": MultiAddress;
    "target": MultiAddress;
    "schedule": Anonymize<I4aro1m78pdrtt>;
};
export type Ict9ivhr2c5hv0 = {
    "schedule1_index": number;
    "schedule2_index": number;
};
export type I8t4vv03357lk9 = {
    "target": MultiAddress;
    "schedule_index": number;
};
export type I9hqnknd58s34t = AnonymousEnum<{
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    "batch": Anonymize<Iei32791v914nk>;
    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     */
    "as_derivative": Anonymize<Ic7r7vdklc9nc3>;
    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    "batch_all": Anonymize<Iei32791v914nk>;
    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     */
    "dispatch_as": Anonymize<I45q3ft911puud>;
    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    "force_batch": Anonymize<Iei32791v914nk>;
    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     */
    "with_weight": Anonymize<Ibjjjog2h7tn59>;
    /**
     * Dispatch a fallback call in the event the main call fails to execute.
     * May be called from any origin except `None`.
     *
     * This function first attempts to dispatch the `main` call.
     * If the `main` call fails, the `fallback` is attemted.
     * if the fallback is successfully dispatched, the weights of both calls
     * are accumulated and an event containing the main call error is deposited.
     *
     * In the event of a fallback failure the whole call fails
     * with the weights returned.
     *
     * - `main`: The main call to be dispatched. This is the primary action to execute.
     * - `fallback`: The fallback call to be dispatched in case the `main` call fails.
     *
     * ## Dispatch Logic
     * - If the origin is `root`, both the main and fallback calls are executed without
     * applying any origin filters.
     * - If the origin is not `root`, the origin filter is applied to both the `main` and
     * `fallback` calls.
     *
     * ## Use Case
     * - Some use cases might involve submitting a `batch` type call in either main, fallback
     * or both.
     */
    "if_else": Anonymize<Ibah25fgkhc4u1>;
    /**
     * Dispatches a function call with a provided origin.
     *
     * Almost the same as [`Pallet::dispatch_as`] but forwards any error of the inner call.
     *
     * The dispatch origin for this call must be _Root_.
     */
    "dispatch_as_fallible": Anonymize<I45q3ft911puud>;
}>;
export type Iei32791v914nk = {
    "calls": Array<TxCallData>;
};
export type Ic7r7vdklc9nc3 = {
    "index": number;
    "call": TxCallData;
};
export type I45q3ft911puud = {
    "as_origin": Anonymize<Iarigqlp2c2plh>;
    "call": TxCallData;
};
export type Ibjjjog2h7tn59 = {
    "call": TxCallData;
    "weight": Anonymize<I4q39t5hn830vp>;
};
export type Ibah25fgkhc4u1 = {
    "main": TxCallData;
    "fallback": TxCallData;
};
export type Ibhvuekbs2l561 = AnonymousEnum<{
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    "proxy": Anonymize<Iac3j0gu39jfq0>;
    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     */
    "add_proxy": Anonymize<Ib1tr5ljcskalg>;
    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     */
    "remove_proxy": Anonymize<Ib1tr5ljcskalg>;
    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     */
    "remove_proxies": undefined;
    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     */
    "create_pure": Anonymize<I7l4hu9floq5js>;
    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     */
    "kill_pure": Anonymize<I5860vql6ga92>;
    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    "announce": Anonymize<I2eb501t8s6hsq>;
    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    "remove_announcement": Anonymize<I2eb501t8s6hsq>;
    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     */
    "reject_announcement": Anonymize<Ianmuoljk2sk1u>;
    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    "proxy_announced": Anonymize<Ihcikdo2rigie>;
    /**
     * Poke / Adjust deposits made for proxies and announcements based on current values.
     * This can be used by accounts to possibly lower their locked amount.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * The transaction fee is waived if the deposit amount has changed.
     *
     * Emits `DepositPoked` if successful.
     */
    "poke_deposit": undefined;
}>;
export type Iac3j0gu39jfq0 = {
    "real": MultiAddress;
    "force_proxy_type"?: Anonymize<I93g3hgcn0dpaj>;
    "call": TxCallData;
};
export type I93g3hgcn0dpaj = (Anonymize<I7adrgaqb51jb9>) | undefined;
export type Ib1tr5ljcskalg = {
    "delegate": MultiAddress;
    "proxy_type": Anonymize<I7adrgaqb51jb9>;
    "delay": number;
};
export type I7l4hu9floq5js = {
    "proxy_type": Anonymize<I7adrgaqb51jb9>;
    "delay": number;
    "index": number;
};
export type I5860vql6ga92 = {
    "spawner": MultiAddress;
    "proxy_type": Anonymize<I7adrgaqb51jb9>;
    "index": number;
    "height": number;
    "ext_index": number;
};
export type I2eb501t8s6hsq = {
    "real": MultiAddress;
    "call_hash": FixedSizeBinary<32>;
};
export type Ianmuoljk2sk1u = {
    "delegate": MultiAddress;
    "call_hash": FixedSizeBinary<32>;
};
export type Ihcikdo2rigie = {
    "delegate": MultiAddress;
    "real": MultiAddress;
    "force_proxy_type"?: Anonymize<I93g3hgcn0dpaj>;
    "call": TxCallData;
};
export type I9oe8lfo3d66rb = AnonymousEnum<{
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    "as_multi_threshold_1": Anonymize<I1ebc71u4dhk60>;
    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    "as_multi": Anonymize<I484frm04r9kpe>;
    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    "approve_as_multi": Anonymize<Ideaemvoneh309>;
    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     */
    "cancel_as_multi": Anonymize<I3d9o9d7epp66v>;
    /**
     * Poke the deposit reserved for an existing multisig operation.
     *
     * The dispatch origin for this call must be _Signed_ and must be the original depositor of
     * the multisig operation.
     *
     * The transaction fee is waived if the deposit amount has changed.
     *
     * - `threshold`: The total number of approvals needed for this multisig.
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multisig.
     * - `call_hash`: The hash of the call this deposit is reserved for.
     *
     * Emits `DepositPoked` if successful.
     */
    "poke_deposit": Anonymize<I6lqh1vgb4mcja>;
}>;
export type I1ebc71u4dhk60 = {
    "other_signatories": Anonymize<Ia2lhg7l2hilo3>;
    "call": TxCallData;
};
export type I484frm04r9kpe = {
    "threshold": number;
    "other_signatories": Anonymize<Ia2lhg7l2hilo3>;
    "maybe_timepoint"?: Anonymize<I95jfd8j5cr5eh>;
    "call": TxCallData;
    "max_weight": Anonymize<I4q39t5hn830vp>;
};
export type I95jfd8j5cr5eh = (Anonymize<Itvprrpb0nm3o>) | undefined;
export type Ideaemvoneh309 = {
    "threshold": number;
    "other_signatories": Anonymize<Ia2lhg7l2hilo3>;
    "maybe_timepoint"?: Anonymize<I95jfd8j5cr5eh>;
    "call_hash": FixedSizeBinary<32>;
    "max_weight": Anonymize<I4q39t5hn830vp>;
};
export type I3d9o9d7epp66v = {
    "threshold": number;
    "other_signatories": Anonymize<Ia2lhg7l2hilo3>;
    "timepoint": Anonymize<Itvprrpb0nm3o>;
    "call_hash": FixedSizeBinary<32>;
};
export type I6lqh1vgb4mcja = {
    "threshold": number;
    "other_signatories": Anonymize<Ia2lhg7l2hilo3>;
    "call_hash": FixedSizeBinary<32>;
};
export type I1nnef4ljub6d0 = AnonymousEnum<{
    /**
     * Propose a new bounty.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     * `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
     * or slashed when rejected.
     *
     * - `curator`: The curator account whom will manage this bounty.
     * - `fee`: The curator fee.
     * - `value`: The total payment amount of this bounty, curator fee included.
     * - `description`: The description of this bounty.
     */
    "propose_bounty": Anonymize<I2a839vbf5817q>;
    /**
     * Approve a bounty proposal. At a later time, the bounty will be funded and become active
     * and the original deposit will be returned.
     *
     * May only be called from `T::SpendOrigin`.
     *
     * ## Complexity
     * - O(1).
     */
    "approve_bounty": Anonymize<Ia9p5bg6p18r0i>;
    /**
     * Propose a curator to a funded bounty.
     *
     * May only be called from `T::SpendOrigin`.
     *
     * ## Complexity
     * - O(1).
     */
    "propose_curator": Anonymize<I42bqh279uf7oa>;
    /**
     * Unassign curator from a bounty.
     *
     * This function can only be called by the `RejectOrigin` a signed origin.
     *
     * If this function is called by the `RejectOrigin`, we assume that the curator is
     * malicious or inactive. As a result, we will slash the curator when possible.
     *
     * If the origin is the curator, we take this as a sign they are unable to do their job and
     * they willingly give up. We could slash them, but for now we allow them to recover their
     * deposit and exit without issue. (We may want to change this if it is abused.)
     *
     * Finally, the origin can be anyone if and only if the curator is "inactive". This allows
     * anyone in the community to call out that a curator is not doing their due diligence, and
     * we should pick a new curator. In this case the curator should also be slashed.
     *
     * ## Complexity
     * - O(1).
     */
    "unassign_curator": Anonymize<Ia9p5bg6p18r0i>;
    /**
     * Accept the curator role for a bounty.
     * A deposit will be reserved from curator and refund upon successful payout.
     *
     * May only be called from the curator.
     *
     * ## Complexity
     * - O(1).
     */
    "accept_curator": Anonymize<Ia9p5bg6p18r0i>;
    /**
     * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
     * after a delay.
     *
     * The dispatch origin for this call must be the curator of this bounty.
     *
     * - `bounty_id`: Bounty ID to award.
     * - `beneficiary`: The beneficiary account whom will receive the payout.
     *
     * ## Complexity
     * - O(1).
     */
    "award_bounty": Anonymize<I4p6v96cffstms>;
    /**
     * Claim the payout from an awarded bounty after payout delay.
     *
     * The dispatch origin for this call must be the beneficiary of this bounty.
     *
     * - `bounty_id`: Bounty ID to claim.
     *
     * ## Complexity
     * - O(1).
     */
    "claim_bounty": Anonymize<Ia9p5bg6p18r0i>;
    /**
     * Cancel a proposed or active bounty. All the funds will be sent to treasury and
     * the curator deposit will be unreserved if possible.
     *
     * Only `T::RejectOrigin` is able to cancel a bounty.
     *
     * - `bounty_id`: Bounty ID to cancel.
     *
     * ## Complexity
     * - O(1).
     */
    "close_bounty": Anonymize<Ia9p5bg6p18r0i>;
    /**
     * Extend the expiry time of an active bounty.
     *
     * The dispatch origin for this call must be the curator of this bounty.
     *
     * - `bounty_id`: Bounty ID to extend.
     * - `remark`: additional information.
     *
     * ## Complexity
     * - O(1).
     */
    "extend_bounty_expiry": Anonymize<I90n6nnkpdahrh>;
    /**
     * Approve bountry and propose a curator simultaneously.
     * This call is a shortcut to calling `approve_bounty` and `propose_curator` separately.
     *
     * May only be called from `T::SpendOrigin`.
     *
     * - `bounty_id`: Bounty ID to approve.
     * - `curator`: The curator account whom will manage this bounty.
     * - `fee`: The curator fee.
     *
     * ## Complexity
     * - O(1).
     */
    "approve_bounty_with_curator": Anonymize<I42bqh279uf7oa>;
}>;
export type I2a839vbf5817q = {
    "value": bigint;
    "description": Binary;
};
export type I42bqh279uf7oa = {
    "bounty_id": number;
    "curator": MultiAddress;
    "fee": bigint;
};
export type I4p6v96cffstms = {
    "bounty_id": number;
    "beneficiary": MultiAddress;
};
export type I90n6nnkpdahrh = {
    "bounty_id": number;
    "remark": Binary;
};
export type I1b6drdhvt5hl9 = AnonymousEnum<{
    /**
     * Add a new child-bounty.
     *
     * The dispatch origin for this call must be the curator of parent
     * bounty and the parent bounty must be in "active" state.
     *
     * Child-bounty gets added successfully & fund gets transferred from
     * parent bounty to child-bounty account, if parent bounty has enough
     * funds, else the call fails.
     *
     * Upper bound to maximum number of active  child bounties that can be
     * added are managed via runtime trait config
     * [`Config::MaxActiveChildBountyCount`].
     *
     * If the call is success, the status of child-bounty is updated to
     * "Added".
     *
     * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
     * - `value`: Value for executing the proposal.
     * - `description`: Text description for the child-bounty.
     */
    "add_child_bounty": Anonymize<I8mk5kjgn02hi8>;
    /**
     * Propose curator for funded child-bounty.
     *
     * The dispatch origin for this call must be curator of parent bounty.
     *
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     *
     * Child-bounty must be in "Added" state, for processing the call. And
     * state of child-bounty is moved to "CuratorProposed" on successful
     * call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     * - `curator`: Address of child-bounty curator.
     * - `fee`: payment fee to child-bounty curator for execution.
     */
    "propose_curator": Anonymize<Ieqvq91sbe02ko>;
    /**
     * Accept the curator role for the child-bounty.
     *
     * The dispatch origin for this call must be the curator of this
     * child-bounty.
     *
     * A deposit will be reserved from the curator and refund upon
     * successful payout or cancellation.
     *
     * Fee for curator is deducted from curator fee of parent bounty.
     *
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     *
     * Child-bounty must be in "CuratorProposed" state, for processing the
     * call. And state of child-bounty is moved to "Active" on successful
     * call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     */
    "accept_curator": Anonymize<I2gr10p66od9ch>;
    /**
     * Unassign curator from a child-bounty.
     *
     * The dispatch origin for this call can be either `RejectOrigin`, or
     * the curator of the parent bounty, or any signed origin.
     *
     * For the origin other than T::RejectOrigin and the child-bounty
     * curator, parent bounty must be in active state, for this call to
     * work. We allow child-bounty curator and T::RejectOrigin to execute
     * this call irrespective of the parent bounty state.
     *
     * If this function is called by the `RejectOrigin` or the
     * parent bounty curator, we assume that the child-bounty curator is
     * malicious or inactive. As a result, child-bounty curator deposit is
     * slashed.
     *
     * If the origin is the child-bounty curator, we take this as a sign
     * that they are unable to do their job, and are willingly giving up.
     * We could slash the deposit, but for now we allow them to unreserve
     * their deposit and exit without issue. (We may want to change this if
     * it is abused.)
     *
     * Finally, the origin can be anyone iff the child-bounty curator is
     * "inactive". Expiry update due of parent bounty is used to estimate
     * inactive state of child-bounty curator.
     *
     * This allows anyone in the community to call out that a child-bounty
     * curator is not doing their due diligence, and we should pick a new
     * one. In this case the child-bounty curator deposit is slashed.
     *
     * State of child-bounty is moved to Added state on successful call
     * completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     */
    "unassign_curator": Anonymize<I2gr10p66od9ch>;
    /**
     * Award child-bounty to a beneficiary.
     *
     * The beneficiary will be able to claim the funds after a delay.
     *
     * The dispatch origin for this call must be the parent curator or
     * curator of this child-bounty.
     *
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     *
     * Child-bounty must be in active state, for processing the call. And
     * state of child-bounty is moved to "PendingPayout" on successful call
     * completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     * - `beneficiary`: Beneficiary account.
     */
    "award_child_bounty": Anonymize<I9mcq66cm3gibo>;
    /**
     * Claim the payout from an awarded child-bounty after payout delay.
     *
     * The dispatch origin for this call may be any signed origin.
     *
     * Call works independent of parent bounty state, No need for parent
     * bounty to be in active state.
     *
     * The Beneficiary is paid out with agreed bounty value. Curator fee is
     * paid & curator deposit is unreserved.
     *
     * Child-bounty must be in "PendingPayout" state, for processing the
     * call. And instance of child-bounty is removed from the state on
     * successful call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     */
    "claim_child_bounty": Anonymize<I2gr10p66od9ch>;
    /**
     * Cancel a proposed or active child-bounty. Child-bounty account funds
     * are transferred to parent bounty account. The child-bounty curator
     * deposit may be unreserved if possible.
     *
     * The dispatch origin for this call must be either parent curator or
     * `T::RejectOrigin`.
     *
     * If the state of child-bounty is `Active`, curator deposit is
     * unreserved.
     *
     * If the state of child-bounty is `PendingPayout`, call fails &
     * returns `PendingPayout` error.
     *
     * For the origin other than T::RejectOrigin, parent bounty must be in
     * active state, for this child-bounty call to work. For origin
     * T::RejectOrigin execution is forced.
     *
     * Instance of child-bounty is removed from the state on successful
     * call completion.
     *
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     */
    "close_child_bounty": Anonymize<I2gr10p66od9ch>;
}>;
export type I8mk5kjgn02hi8 = {
    "parent_bounty_id": number;
    "value": bigint;
    "description": Binary;
};
export type Ieqvq91sbe02ko = {
    "parent_bounty_id": number;
    "child_bounty_id": number;
    "curator": MultiAddress;
    "fee": bigint;
};
export type I2gr10p66od9ch = {
    "parent_bounty_id": number;
    "child_bounty_id": number;
};
export type I9mcq66cm3gibo = {
    "parent_bounty_id": number;
    "child_bounty_id": number;
    "beneficiary": MultiAddress;
};
export type I15soeogelbbbh = AnonymousEnum<{
    /**
     * Submit a solution for the unsigned phase.
     *
     * The dispatch origin fo this call must be __none__.
     *
     * This submission is checked on the fly. Moreover, this unsigned solution is only
     * validated when submitted to the pool from the **local** node. Effectively, this means
     * that only active validators can submit this transaction when authoring a block (similar
     * to an inherent).
     *
     * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     * panic if the solution submitted by the validator is invalid in any way, effectively
     * putting their authoring reward at risk.
     *
     * No deposit or reward is associated with this submission.
     */
    "submit_unsigned": Anonymize<I31k9f0jol8ko4>;
    /**
     * Set a new value for `MinimumUntrustedScore`.
     *
     * Dispatch origin must be aligned with `T::ForceOrigin`.
     *
     * This check can be turned off by setting the value to `None`.
     */
    "set_minimum_untrusted_score": Anonymize<I80q14um2s2ckg>;
    /**
     * Set a solution in the queue, to be handed out to the client of this pallet in the next
     * call to `ElectionProvider::elect`.
     *
     * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
     *
     * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
     * feasibility check itself can in principle cause the election process to fail (due to
     * memory/weight constrains).
     */
    "set_emergency_election_result": Anonymize<I5qs1t1erfi7u8>;
    /**
     * Submit a solution for the signed phase.
     *
     * The dispatch origin fo this call must be __signed__.
     *
     * The solution is potentially queued, based on the claimed score and processed at the end
     * of the signed phase.
     *
     * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     * might be rewarded, slashed, or get all or a part of the deposit back.
     */
    "submit": Anonymize<I9et13knvdvgpb>;
    /**
     * Trigger the governance fallback.
     *
     * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
     * calling [`Call::set_emergency_election_result`].
     */
    "governance_fallback": Anonymize<Ifsme8miqq9006>;
}>;
export type I31k9f0jol8ko4 = {
    "raw_solution": Anonymize<I7je4n92ump862>;
    "witness": Anonymize<Iasd2iat48n080>;
};
export type I80q14um2s2ckg = {
    "maybe_next_score"?: (Anonymize<I8s6n43okuj2b1>) | undefined;
};
export type I5qs1t1erfi7u8 = {
    "supports": Anonymize<I4bboqsv44evel>;
};
export type I9et13knvdvgpb = {
    "raw_solution": Anonymize<I7je4n92ump862>;
};
export type Ifsme8miqq9006 = {
    "maybe_max_voters"?: Anonymize<I4arjljr6dpflb>;
    "maybe_max_targets"?: Anonymize<I4arjljr6dpflb>;
};
export type Ifvfo1l0vu2o7e = AnonymousEnum<{
    /**
     * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
     * changed its score that it should properly fall into a different bag than its current
     * one.
     *
     * Anyone can call this function about any potentially dislocated account.
     *
     * Will always update the stored score of `dislocated` to the correct score, based on
     * `ScoreProvider`.
     *
     * If `dislocated` does not exists, it returns an error.
     */
    "rebag": Anonymize<Id9js0aucdivjk>;
    /**
     * Move the caller's Id directly in front of `lighter`.
     *
     * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
     * the account going in front of `lighter`. Fee is payed by the origin under all
     * circumstances.
     *
     * Only works if:
     *
     * - both nodes are within the same bag,
     * - and `origin` has a greater `Score` than `lighter`.
     */
    "put_in_front_of": Anonymize<I1vj3e1a62je3o>;
    /**
     * Same as [`Pallet::put_in_front_of`], but it can be called by anyone.
     *
     * Fee is paid by the origin under all circumstances.
     */
    "put_in_front_of_other": Anonymize<I6c1t14l6giceg>;
}>;
export type Id9js0aucdivjk = {
    "dislocated": MultiAddress;
};
export type I1vj3e1a62je3o = {
    "lighter": MultiAddress;
};
export type I6c1t14l6giceg = {
    "heavier": MultiAddress;
    "lighter": MultiAddress;
};
export type I57mljkkr28m9p = AnonymousEnum<{
    /**
     * Stake funds with a pool. The amount to bond is delegated (or transferred based on
     * [`adapter::StakeStrategyType`]) from the member to the pool account and immediately
     * increases the pool's bond.
     *
     * The method of transferring the amount to the pool account is determined by
     * [`adapter::StakeStrategyType`]. If the pool is configured to use
     * [`adapter::StakeStrategyType::Delegate`], the funds remain in the account of
     * the `origin`, while the pool gains the right to use these funds for staking.
     *
     * # Note
     *
     * * An account can only be a member of a single pool.
     * * An account cannot join the same pool multiple times.
     * * This call will *not* dust the member account, so the member must have at least
     * `existential deposit + amount` in their account.
     * * Only a pool with [`PoolState::Open`] can be joined
     */
    "join": Anonymize<Ieg1oc56mamrl5>;
    /**
     * Bond `extra` more funds from `origin` into the pool to which they already belong.
     *
     * Additional funds can come from either the free balance of the account, of from the
     * accumulated rewards, see [`BondExtra`].
     *
     * Bonding extra funds implies an automatic payout of all pending rewards as well.
     * See `bond_extra_other` to bond pending rewards of `other` members.
     */
    "bond_extra": Anonymize<I2vu5vj7173ik9>;
    /**
     * A bonded member can use this to claim their payout based on the rewards that the pool
     * has accumulated since their last claimed payout (OR since joining if this is their first
     * time claiming rewards). The payout will be transferred to the member's account.
     *
     * The member will earn rewards pro rata based on the members stake vs the sum of the
     * members in the pools stake. Rewards do not "expire".
     *
     * See `claim_payout_other` to claim rewards on behalf of some `other` pool member.
     */
    "claim_payout": undefined;
    /**
     * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
     * implicitly collects the rewards one last time, since not doing so would mean some
     * rewards would be forfeited.
     *
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     *
     * # Conditions for a permissionless dispatch.
     *
     * * The pool is blocked and the caller is either the root or bouncer. This is refereed to
     * as a kick.
     * * The pool is destroying and the member is not the depositor.
     * * The pool is destroying, the member is the depositor and no other members are in the
     * pool.
     *
     * ## Conditions for permissioned dispatch (i.e. the caller is also the
     * `member_account`):
     *
     * * The caller is not the depositor.
     * * The caller is the depositor, the pool is destroying and no other members are in the
     * pool.
     *
     * # Note
     *
     * If there are too many unlocking chunks to unbond with the pool account,
     * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks.
     * The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]
     * to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks
     * are available). However, it may not be possible to release the current unlocking chunks,
     * in which case, the result of this call will likely be the `NoMoreChunks` error from the
     * staking system.
     */
    "unbond": Anonymize<I6galqkn58q3bl>;
    /**
     * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
     *
     * This is useful if there are too many unlocking chunks to call `unbond`, and some
     * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
     * would probably see an error like `NoMoreChunks` emitted from the staking system when
     * they attempt to unbond.
     */
    "pool_withdraw_unbonded": Anonymize<I36uoc8t9liv80>;
    /**
     * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
     * error is returned.
     *
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     *
     * # Conditions for a permissionless dispatch
     *
     * * The pool is in destroy mode and the target is not the depositor.
     * * The target is the depositor and they are the only member in the sub pools.
     * * The pool is blocked and the caller is either the root or bouncer.
     *
     * # Conditions for permissioned dispatch
     *
     * * The caller is the target and they are not the depositor.
     *
     * # Note
     *
     * - If the target is the depositor, the pool will be destroyed.
     * - If the pool has any pending slash, we also try to slash the member before letting them
     * withdraw. This calculation adds some weight overhead and is only defensive. In reality,
     * pool slashes must have been already applied via permissionless [`Call::apply_slash`].
     */
    "withdraw_unbonded": Anonymize<Ibunghsg9qa7f7>;
    /**
     * Create a new delegation pool.
     *
     * # Arguments
     *
     * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
     * deposit since the pools creator cannot fully unbond funds until the pool is being
     * destroyed.
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     * creating multiple pools in the same extrinsic.
     * * `root` - The account to set as [`PoolRoles::root`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * * `bouncer` - The account to set as the [`PoolRoles::bouncer`].
     *
     * # Note
     *
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferable.
     */
    "create": Anonymize<I8qnouj2c0igph>;
    /**
     * Create a new delegation pool with a previously used pool id
     *
     * # Arguments
     *
     * same as `create` with the inclusion of
     * * `pool_id` - `A valid PoolId.
     */
    "create_with_pool_id": Anonymize<Ic30e2k517a3ns>;
    /**
     * Nominate on behalf of the pool.
     *
     * The dispatch origin of this call must be signed by the pool nominator or the pool
     * root role.
     *
     * This directly forwards the call to an implementation of `StakingInterface` (e.g.,
     * `pallet-staking`) through [`Config::StakeAdapter`], on behalf of the bonded pool.
     *
     * # Note
     *
     * In addition to a `root` or `nominator` role of `origin`, the pool's depositor needs to
     * have at least `depositor_min_bond` in the pool to start nominating.
     */
    "nominate": Anonymize<I47a2tsd2o2b1c>;
    /**
     * Set a new state for the pool.
     *
     * If a pool is already in the `Destroying` state, then under no condition can its state
     * change again.
     *
     * The dispatch origin of this call must be either:
     *
     * 1. signed by the bouncer, or the root role of the pool,
     * 2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and
     * then the state of the pool can be permissionlessly changed to `Destroying`.
     */
    "set_state": Anonymize<Ifc9k1s0e9nv8e>;
    /**
     * Set a new metadata for the pool.
     *
     * The dispatch origin of this call must be signed by the bouncer, or the root role of the
     * pool.
     */
    "set_metadata": Anonymize<I4ihj26hl75e5p>;
    /**
     * Update configurations for the nomination pools. The origin for this call must be
     * [`Config::AdminOrigin`].
     *
     * # Arguments
     *
     * * `min_join_bond` - Set [`MinJoinBond`].
     * * `min_create_bond` - Set [`MinCreateBond`].
     * * `max_pools` - Set [`MaxPools`].
     * * `max_members` - Set [`MaxPoolMembers`].
     * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
     * * `global_max_commission` - Set [`GlobalMaxCommission`].
     */
    "set_configs": Anonymize<I2dl8ekhm2t22h>;
    /**
     * Update the roles of the pool.
     *
     * The root is the only entity that can change any of the roles, including itself,
     * excluding the depositor, who can never change.
     *
     * It emits an event, notifying UIs of the role change. This event is quite relevant to
     * most pool members and they should be informed of changes to pool roles.
     */
    "update_roles": Anonymize<I13us5e5h5645o>;
    /**
     * Chill on behalf of the pool.
     *
     * The dispatch origin of this call can be signed by the pool nominator or the pool
     * root role, same as [`Pallet::nominate`].
     *
     * This directly forwards the call to an implementation of `StakingInterface` (e.g.,
     * `pallet-staking`) through [`Config::StakeAdapter`], on behalf of the bonded pool.
     *
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     *
     * # Conditions for a permissionless dispatch:
     * * When pool depositor has less than `MinNominatorBond` staked, otherwise pool members
     * are unable to unbond.
     *
     * # Conditions for permissioned dispatch:
     * * The caller is the pool's nominator or root.
     */
    "chill": Anonymize<I931cottvong90>;
    /**
     * `origin` bonds funds from `extra` for some pool member `member` into their respective
     * pools.
     *
     * `origin` can bond extra funds from free balance or pending rewards when `origin ==
     * other`.
     *
     * In the case of `origin != other`, `origin` can only bond extra pending rewards of
     * `other` members assuming set_claim_permission for the given member is
     * `PermissionlessCompound` or `PermissionlessAll`.
     */
    "bond_extra_other": Anonymize<I7sujb8gfvuo7n>;
    /**
     * Allows a pool member to set a claim permission to allow or disallow permissionless
     * bonding and withdrawing.
     *
     * # Arguments
     *
     * * `origin` - Member of a pool.
     * * `permission` - The permission to be applied.
     */
    "set_claim_permission": Anonymize<I1ors0vru14it3>;
    /**
     * `origin` can claim payouts on some pool member `other`'s behalf.
     *
     * Pool member `other` must have a `PermissionlessWithdraw` or `PermissionlessAll` claim
     * permission for this call to be successful.
     */
    "claim_payout_other": Anonymize<I40s11r8nagn2g>;
    /**
     * Set the commission of a pool.
     * Both a commission percentage and a commission payee must be provided in the `current`
     * tuple. Where a `current` of `None` is provided, any current commission will be removed.
     *
     * - If a `None` is supplied to `new_commission`, existing commission will be removed.
     */
    "set_commission": Anonymize<I6bjj87fr5g9nl>;
    /**
     * Set the maximum commission of a pool.
     *
     * - Initial max can be set to any `Perbill`, and only smaller values thereafter.
     * - Current commission will be lowered in the event it is higher than a new max
     * commission.
     */
    "set_commission_max": Anonymize<I8cbluptqo8kbp>;
    /**
     * Set the commission change rate for a pool.
     *
     * Initial change rate is not bounded, whereas subsequent updates can only be more
     * restrictive than the current.
     */
    "set_commission_change_rate": Anonymize<I81cc4plffa1dm>;
    /**
     * Claim pending commission.
     *
     * The `root` role of the pool is _always_ allowed to claim the pool's commission.
     *
     * If the pool has set `CommissionClaimPermission::Permissionless`, then any account can
     * trigger the process of claiming the pool's commission.
     *
     * If the pool has set its `CommissionClaimPermission` to `Account(acc)`, then only
     * accounts
     * * `acc`, and
     * * the pool's root account
     *
     * may call this extrinsic on behalf of the pool.
     *
     * Pending commissions are paid out and added to the total claimed commission.
     * The total pending commission is reset to zero.
     */
    "claim_commission": Anonymize<I931cottvong90>;
    /**
     * Top up the deficit or withdraw the excess ED from the pool.
     *
     * When a pool is created, the pool depositor transfers ED to the reward account of the
     * pool. ED is subject to change and over time, the deposit in the reward account may be
     * insufficient to cover the ED deficit of the pool or vice-versa where there is excess
     * deposit to the pool. This call allows anyone to adjust the ED deposit of the
     * pool by either topping up the deficit or claiming the excess.
     */
    "adjust_pool_deposit": Anonymize<I931cottvong90>;
    /**
     * Set or remove a pool's commission claim permission.
     *
     * Determines who can claim the pool's pending commission. Only the `Root` role of the pool
     * is able to configure commission claim permissions.
     */
    "set_commission_claim_permission": Anonymize<I3ihan8icf0c5k>;
    /**
     * Apply a pending slash on a member.
     *
     * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
     * [`adapter::StakeStrategyType::Delegate`].
     *
     * The pending slash amount of the member must be equal or more than `ExistentialDeposit`.
     * This call can be dispatched permissionlessly (i.e. by any account). If the execution
     * is successful, fee is refunded and caller may be rewarded with a part of the slash
     * based on the [`crate::pallet::Config::StakeAdapter`] configuration.
     */
    "apply_slash": Anonymize<I7ibh0fckqou49>;
    /**
     * Migrates delegated funds from the pool account to the `member_account`.
     *
     * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
     * [`adapter::StakeStrategyType::Delegate`].
     *
     * This is a permission-less call and refunds any fee if claim is successful.
     *
     * If the pool has migrated to delegation based staking, the staked tokens of pool members
     * can be moved and held in their own account. See [`adapter::DelegateStake`]
     */
    "migrate_delegation": Anonymize<I7ibh0fckqou49>;
    /**
     * Migrate pool from [`adapter::StakeStrategyType::Transfer`] to
     * [`adapter::StakeStrategyType::Delegate`].
     *
     * Fails unless [`crate::pallet::Config::StakeAdapter`] is of strategy type:
     * [`adapter::StakeStrategyType::Delegate`].
     *
     * This call can be dispatched permissionlessly, and refunds any fee if successful.
     *
     * If the pool has already migrated to delegation based staking, this call will fail.
     */
    "migrate_pool_to_delegate_stake": Anonymize<I931cottvong90>;
}>;
export type I2vu5vj7173ik9 = {
    "extra": NominationPoolsBondExtra;
};
export type NominationPoolsBondExtra = Enum<{
    "FreeBalance": bigint;
    "Rewards": undefined;
}>;
export declare const NominationPoolsBondExtra: GetEnum<NominationPoolsBondExtra>;
export type I6galqkn58q3bl = {
    "member_account": MultiAddress;
    "unbonding_points": bigint;
};
export type I36uoc8t9liv80 = {
    "pool_id": number;
    "num_slashing_spans": number;
};
export type Ibunghsg9qa7f7 = {
    "member_account": MultiAddress;
    "num_slashing_spans": number;
};
export type I8qnouj2c0igph = {
    "amount": bigint;
    "root": MultiAddress;
    "nominator": MultiAddress;
    "bouncer": MultiAddress;
};
export type Ic30e2k517a3ns = {
    "amount": bigint;
    "root": MultiAddress;
    "nominator": MultiAddress;
    "bouncer": MultiAddress;
    "pool_id": number;
};
export type I47a2tsd2o2b1c = {
    "pool_id": number;
    "validators": Anonymize<Ia2lhg7l2hilo3>;
};
export type Ifc9k1s0e9nv8e = {
    "pool_id": number;
    "state": NominationPoolsPoolState;
};
export type I4ihj26hl75e5p = {
    "pool_id": number;
    "metadata": Binary;
};
export type I2dl8ekhm2t22h = {
    "min_join_bond": StakingPalletConfigOpBig;
    "min_create_bond": StakingPalletConfigOpBig;
    "max_pools": StakingPalletConfigOp;
    "max_members": StakingPalletConfigOp;
    "max_members_per_pool": StakingPalletConfigOp;
    "global_max_commission": StakingPalletConfigOp;
};
export type I13us5e5h5645o = {
    "pool_id": number;
    "new_root": NominationPoolsConfigOp;
    "new_nominator": NominationPoolsConfigOp;
    "new_bouncer": NominationPoolsConfigOp;
};
export type NominationPoolsConfigOp = Enum<{
    "Noop": undefined;
    "Set": SS58String;
    "Remove": undefined;
}>;
export declare const NominationPoolsConfigOp: GetEnum<NominationPoolsConfigOp>;
export type I7sujb8gfvuo7n = {
    "member": MultiAddress;
    "extra": NominationPoolsBondExtra;
};
export type I1ors0vru14it3 = {
    "permission": NominationPoolsClaimPermission;
};
export type I40s11r8nagn2g = {
    "other": SS58String;
};
export type I6bjj87fr5g9nl = {
    "pool_id": number;
    "new_commission"?: Anonymize<Ie8iutm7u02lmj>;
};
export type I7ibh0fckqou49 = {
    "member_account": MultiAddress;
};
export type I44snhj1gahvrd = AnonymousEnum<{
    /**
     * Register oneself for fast-unstake.
     *
     * ## Dispatch Origin
     *
     * The dispatch origin of this call must be *signed* by whoever is permitted to call
     * unbond funds by the staking system. See [`Config::Staking`].
     *
     * ## Details
     *
     * The stash associated with the origin must have no ongoing unlocking chunks. If
     * successful, this will fully unbond and chill the stash. Then, it will enqueue the stash
     * to be checked in further blocks.
     *
     * If by the time this is called, the stash is actually eligible for fast-unstake, then
     * they are guaranteed to remain eligible, because the call will chill them as well.
     *
     * If the check works, the entire staking data is removed, i.e. the stash is fully
     * unstaked.
     *
     * If the check fails, the stash remains chilled and waiting for being unbonded as in with
     * the normal staking system, but they lose part of their unbonding chunks due to consuming
     * the chain's resources.
     *
     * ## Events
     *
     * Some events from the staking and currency system might be emitted.
     */
    "register_fast_unstake": undefined;
    /**
     * Deregister oneself from the fast-unstake.
     *
     * ## Dispatch Origin
     *
     * The dispatch origin of this call must be *signed* by whoever is permitted to call
     * unbond funds by the staking system. See [`Config::Staking`].
     *
     * ## Details
     *
     * This is useful if one is registered, they are still waiting, and they change their mind.
     *
     * Note that the associated stash is still fully unbonded and chilled as a consequence of
     * calling [`Pallet::register_fast_unstake`]. Therefore, this should probably be followed
     * by a call to `rebond` in the staking system.
     *
     * ## Events
     *
     * Some events from the staking and currency system might be emitted.
     */
    "deregister": undefined;
    /**
     * Control the operation of this pallet.
     *
     * ## Dispatch Origin
     *
     * The dispatch origin of this call must be [`Config::ControlOrigin`].
     *
     * ## Details
     *
     * Can set the number of eras to check per block, and potentially other admin work.
     *
     * ## Events
     *
     * No events are emitted from this dispatch.
     */
    "control": Anonymize<I9j0ul7nh7b8jv>;
}>;
export type I9j0ul7nh7b8jv = {
    "eras_to_check": number;
};
export type I3ah0kpgrv4i88 = AnonymousEnum<{
    /**
     * Set the validation upgrade cooldown.
     */
    "set_validation_upgrade_cooldown": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the validation upgrade delay.
     */
    "set_validation_upgrade_delay": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the acceptance period for an included candidate.
     */
    "set_code_retention_period": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the max validation code size for incoming upgrades.
     */
    "set_max_code_size": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the max POV block size for incoming upgrades.
     */
    "set_max_pov_size": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the max head data size for paras.
     */
    "set_max_head_data_size": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the number of coretime execution cores.
     *
     * NOTE: that this configuration is managed by the coretime chain. Only manually change
     * this, if you really know what you are doing!
     */
    "set_coretime_cores": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the parachain validator-group rotation frequency
     */
    "set_group_rotation_frequency": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the availability period for paras.
     */
    "set_paras_availability_period": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the scheduling lookahead, in expected number of blocks at peak throughput.
     */
    "set_scheduling_lookahead": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the maximum number of validators to assign to any core.
     */
    "set_max_validators_per_core": Anonymize<Id581arok0b1nj>;
    /**
     * Set the maximum number of validators to use in parachain consensus.
     */
    "set_max_validators": Anonymize<Id581arok0b1nj>;
    /**
     * Set the dispute period, in number of sessions to keep for disputes.
     */
    "set_dispute_period": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the dispute post conclusion acceptance period.
     */
    "set_dispute_post_conclusion_acceptance_period": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the no show slots, in number of number of consensus slots.
     * Must be at least 1.
     */
    "set_no_show_slots": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the total number of delay tranches.
     */
    "set_n_delay_tranches": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the zeroth delay tranche width.
     */
    "set_zeroth_delay_tranche_width": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the number of validators needed to approve a block.
     */
    "set_needed_approvals": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the number of samples to do of the `RelayVRFModulo` approval assignment criterion.
     */
    "set_relay_vrf_modulo_samples": Anonymize<I3vh014cqgmrfd>;
    /**
     * Sets the maximum items that can present in a upward dispatch queue at once.
     */
    "set_max_upward_queue_count": Anonymize<I3vh014cqgmrfd>;
    /**
     * Sets the maximum total size of items that can present in a upward dispatch queue at
     * once.
     */
    "set_max_upward_queue_size": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the critical downward message size.
     */
    "set_max_downward_message_size": Anonymize<I3vh014cqgmrfd>;
    /**
     * Sets the maximum size of an upward message that can be sent by a candidate.
     */
    "set_max_upward_message_size": Anonymize<I3vh014cqgmrfd>;
    /**
     * Sets the maximum number of messages that a candidate can contain.
     */
    "set_max_upward_message_num_per_candidate": Anonymize<I3vh014cqgmrfd>;
    /**
     * Sets the number of sessions after which an HRMP open channel request expires.
     */
    "set_hrmp_open_request_ttl": Anonymize<I3vh014cqgmrfd>;
    /**
     * Sets the amount of funds that the sender should provide for opening an HRMP channel.
     */
    "set_hrmp_sender_deposit": Anonymize<I9jsikd1ghmc7l>;
    /**
     * Sets the amount of funds that the recipient should provide for accepting opening an HRMP
     * channel.
     */
    "set_hrmp_recipient_deposit": Anonymize<I9jsikd1ghmc7l>;
    /**
     * Sets the maximum number of messages allowed in an HRMP channel at once.
     */
    "set_hrmp_channel_max_capacity": Anonymize<I3vh014cqgmrfd>;
    /**
     * Sets the maximum total size of messages in bytes allowed in an HRMP channel at once.
     */
    "set_hrmp_channel_max_total_size": Anonymize<I3vh014cqgmrfd>;
    /**
     * Sets the maximum number of inbound HRMP channels a parachain is allowed to accept.
     */
    "set_hrmp_max_parachain_inbound_channels": Anonymize<I3vh014cqgmrfd>;
    /**
     * Sets the maximum size of a message that could ever be put into an HRMP channel.
     */
    "set_hrmp_channel_max_message_size": Anonymize<I3vh014cqgmrfd>;
    /**
     * Sets the maximum number of outbound HRMP channels a parachain is allowed to open.
     */
    "set_hrmp_max_parachain_outbound_channels": Anonymize<I3vh014cqgmrfd>;
    /**
     * Sets the maximum number of outbound HRMP messages can be sent by a candidate.
     */
    "set_hrmp_max_message_num_per_candidate": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the number of session changes after which a PVF pre-checking voting is rejected.
     */
    "set_pvf_voting_ttl": Anonymize<I3vh014cqgmrfd>;
    /**
     * Sets the minimum delay between announcing the upgrade block for a parachain until the
     * upgrade taking place.
     *
     * See the field documentation for information and constraints for the new value.
     */
    "set_minimum_validation_upgrade_delay": Anonymize<I3vh014cqgmrfd>;
    /**
     * Setting this to true will disable consistency checks for the configuration setters.
     * Use with caution.
     */
    "set_bypass_consistency_check": Anonymize<I2f6mha3v4ooda>;
    /**
     * Set the asynchronous backing parameters.
     */
    "set_async_backing_params": Anonymize<Iasqjdhasi408s>;
    /**
     * Set PVF executor parameters.
     */
    "set_executor_params": Anonymize<I6krn2lsleo87n>;
    /**
     * Set the on demand (parathreads) base fee.
     */
    "set_on_demand_base_fee": Anonymize<I9jsikd1ghmc7l>;
    /**
     * Set the on demand (parathreads) fee variability.
     */
    "set_on_demand_fee_variability": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the on demand (parathreads) queue max size.
     */
    "set_on_demand_queue_max_size": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the on demand (parathreads) fee variability.
     */
    "set_on_demand_target_queue_utilization": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the minimum backing votes threshold.
     */
    "set_minimum_backing_votes": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set/Unset a node feature.
     */
    "set_node_feature": Anonymize<Iaid4btmkr5thp>;
    /**
     * Set approval-voting-params.
     */
    "set_approval_voting_params": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set scheduler-params.
     */
    "set_scheduler_params": Anonymize<I559fv6um7nmhd>;
}>;
export type Id581arok0b1nj = {
    "new"?: Anonymize<I4arjljr6dpflb>;
};
export type I9jsikd1ghmc7l = {
    "new": bigint;
};
export type I2f6mha3v4ooda = {
    "new": boolean;
};
export type Iasqjdhasi408s = {
    "new": Anonymize<Iavuvfkop6318c>;
};
export type I6krn2lsleo87n = {
    "new": Anonymize<I80rnntpog8qp6>;
};
export type Iaid4btmkr5thp = {
    "index": number;
    "value": boolean;
};
export type I559fv6um7nmhd = {
    "new": Anonymize<I555j7pvb27qd5>;
};
export type I1nu19212e8egv = AnonymousEnum<{
    /**
     * Enter the paras inherent. This will process bitfields and backed candidates.
     */
    "enter": Anonymize<I5m2irgeihn4i4>;
}>;
export type I5m2irgeihn4i4 = {
    "data": {
        "bitfields": Array<{
            "payload": {
                bytes: Uint8Array;
                bitsLen: number;
            };
            "validator_index": number;
            "signature": FixedSizeBinary<64>;
        }>;
        "backed_candidates": Array<{
            "candidate": Anonymize<I35p841butcer2>;
            "validity_votes": Array<ValidityAttestation>;
            "validator_indices": {
                bytes: Uint8Array;
                bitsLen: number;
            };
        }>;
        "disputes": Anonymize<Ibt1op6l47p1r2>;
        "parent_header": Anonymize<Ic952bubvq4k7d>;
    };
};
export type I35p841butcer2 = {
    "descriptor": Anonymize<Ibnq2mkuf1plno>;
    "commitments": Anonymize<Ic1d4u2opv3fst>;
};
export type Ie2dden5k4kk7t = AnonymousEnum<{
    /**
     * Set the storage for the parachain validation code immediately.
     */
    "force_set_current_code": Anonymize<I1k3urvkqqshbc>;
    /**
     * Set the storage for the current parachain head data immediately.
     */
    "force_set_current_head": Anonymize<I2ff0ffsh15vej>;
    /**
     * Schedule an upgrade as if it was scheduled in the given relay parent block.
     */
    "force_schedule_code_upgrade": Anonymize<I1orfg86bkg123>;
    /**
     * Note a new block head for para within the context of the current block.
     */
    "force_note_new_head": Anonymize<I2ff0ffsh15vej>;
    /**
     * Put a parachain directly into the next session's action queue.
     * We can't queue it any sooner than this without going into the
     * initializer...
     */
    "force_queue_action": Anonymize<Iaus4cb3drhu9q>;
    /**
     * Adds the validation code to the storage.
     *
     * The code will not be added if it is already present. Additionally, if PVF pre-checking
     * is running for that code, it will be instantly accepted.
     *
     * Otherwise, the code will be added into the storage. Note that the code will be added
     * into storage with reference count 0. This is to account the fact that there are no users
     * for this code yet. The caller will have to make sure that this code eventually gets
     * used by some parachain or removed from the storage to avoid storage leaks. For the
     * latter prefer to use the `poke_unused_validation_code` dispatchable to raw storage
     * manipulation.
     *
     * This function is mainly meant to be used for upgrading parachains that do not follow
     * the go-ahead signal while the PVF pre-checking feature is enabled.
     */
    "add_trusted_validation_code": Anonymize<Ivnsat10lv9d6>;
    /**
     * Remove the validation code from the storage iff the reference count is 0.
     *
     * This is better than removing the storage directly, because it will not remove the code
     * that was suddenly got used by some parachain while this dispatchable was pending
     * dispatching.
     */
    "poke_unused_validation_code": Anonymize<Ibncli8qttt2c2>;
    /**
     * Includes a statement for a PVF pre-checking vote. Potentially, finalizes the vote and
     * enacts the results if that was the last vote before achieving the supermajority.
     */
    "include_pvf_check_statement": Anonymize<I33rft6ag34efs>;
    /**
     * Set the storage for the current parachain head data immediately.
     */
    "force_set_most_recent_context": Anonymize<I9tmok5kceg2bg>;
}>;
export type I1k3urvkqqshbc = {
    "para": number;
    "new_code": Binary;
};
export type I2ff0ffsh15vej = {
    "para": number;
    "new_head": Binary;
};
export type I1orfg86bkg123 = {
    "para": number;
    "new_code": Binary;
    "relay_parent_number": number;
};
export type Iaus4cb3drhu9q = {
    "para": number;
};
export type Ivnsat10lv9d6 = {
    "validation_code": Binary;
};
export type Ibncli8qttt2c2 = {
    "validation_code_hash": FixedSizeBinary<32>;
};
export type I33rft6ag34efs = {
    "stmt": Anonymize<I36e6rra3ikq65>;
    "signature": FixedSizeBinary<64>;
};
export type I36e6rra3ikq65 = {
    "accept": boolean;
    "subject": FixedSizeBinary<32>;
    "session_index": number;
    "validator_index": number;
};
export type I9tmok5kceg2bg = {
    "para": number;
    "context": number;
};
export type Ieggtnkc96vvt7 = AnonymousEnum<{
    /**
     * Issue a signal to the consensus engine to forcibly act as though all parachain
     * blocks in all relay chain blocks up to and including the given number in the current
     * chain are valid and should be finalized.
     */
    "force_approve": Anonymize<I85icj2qbjeqbe>;
}>;
export type I85icj2qbjeqbe = {
    "up_to": number;
};
export type I45adic8nko129 = AnonymousEnum<{
    /**
     * Initiate opening a channel from a parachain to a given recipient with given channel
     * parameters.
     *
     * - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
     * - `proposed_max_message_size` - specifies the maximum size of the messages.
     *
     * These numbers are a subject to the relay-chain configuration limits.
     *
     * The channel can be opened only after the recipient confirms it and only on a session
     * change.
     */
    "hrmp_init_open_channel": Anonymize<Ibuhbp68e6tkct>;
    /**
     * Accept a pending open channel request from the given sender.
     *
     * The channel will be opened only on the next session boundary.
     */
    "hrmp_accept_open_channel": Anonymize<Idrevppfiubhve>;
    /**
     * Initiate unilateral closing of a channel. The origin must be either the sender or the
     * recipient in the channel being closed.
     *
     * The closure can only happen on a session change.
     */
    "hrmp_close_channel": Anonymize<I9s2h36kr71vk9>;
    /**
     * This extrinsic triggers the cleanup of all the HRMP storage items that a para may have.
     * Normally this happens once per session, but this allows you to trigger the cleanup
     * immediately for a specific parachain.
     *
     * Number of inbound and outbound channels for `para` must be provided as witness data.
     *
     * Origin must be the `ChannelManager`.
     */
    "force_clean_hrmp": Anonymize<I4lkbiubo9ogq9>;
    /**
     * Force process HRMP open channel requests.
     *
     * If there are pending HRMP open channel requests, you can use this function to process
     * all of those requests immediately.
     *
     * Total number of opening channels must be provided as witness data.
     *
     * Origin must be the `ChannelManager`.
     */
    "force_process_hrmp_open": Anonymize<Id1baei7m8gkhk>;
    /**
     * Force process HRMP close channel requests.
     *
     * If there are pending HRMP close channel requests, you can use this function to process
     * all of those requests immediately.
     *
     * Total number of closing channels must be provided as witness data.
     *
     * Origin must be the `ChannelManager`.
     */
    "force_process_hrmp_close": Anonymize<Id1baei7m8gkhk>;
    /**
     * This cancels a pending open channel request. It can be canceled by either of the sender
     * or the recipient for that request. The origin must be either of those.
     *
     * The cancellation happens immediately. It is not possible to cancel the request if it is
     * already accepted.
     *
     * Total number of open requests (i.e. `HrmpOpenChannelRequestsList`) must be provided as
     * witness data.
     */
    "hrmp_cancel_open_request": Anonymize<I96ftepqm4vs7m>;
    /**
     * Open a channel from a `sender` to a `recipient` `ParaId`. Although opened by governance,
     * the `max_capacity` and `max_message_size` are still subject to the Relay Chain's
     * configured limits.
     *
     * Expected use is when one (and only one) of the `ParaId`s involved in the channel is
     * governed by the system, e.g. a system parachain.
     *
     * Origin must be the `ChannelManager`.
     */
    "force_open_hrmp_channel": Anonymize<Ic3430470j4mbv>;
    /**
     * Establish an HRMP channel between two system chains. If the channel does not already
     * exist, the transaction fees will be refunded to the caller. The system does not take
     * deposits for channels between system chains, and automatically sets the message number
     * and size limits to the maximum allowed by the network's configuration.
     *
     * Arguments:
     *
     * - `sender`: A system chain, `ParaId`.
     * - `recipient`: A system chain, `ParaId`.
     *
     * Any signed origin can call this function, but _both_ inputs MUST be system chains. If
     * the channel does not exist yet, there is no fee.
     */
    "establish_system_channel": Anonymize<I50mrcbubp554e>;
    /**
     * Update the deposits held for an HRMP channel to the latest `Configuration`. Channels
     * with system chains do not require a deposit.
     *
     * Arguments:
     *
     * - `sender`: A chain, `ParaId`.
     * - `recipient`: A chain, `ParaId`.
     *
     * Any signed origin can call this function.
     */
    "poke_channel_deposits": Anonymize<I50mrcbubp554e>;
    /**
     * Establish a bidirectional HRMP channel between a parachain and a system chain.
     *
     * Arguments:
     *
     * - `target_system_chain`: A system chain, `ParaId`.
     *
     * The origin needs to be the parachain origin.
     */
    "establish_channel_with_system": Anonymize<Ic3n7nqb6fffo0>;
}>;
export type Ibuhbp68e6tkct = {
    "recipient": number;
    "proposed_max_capacity": number;
    "proposed_max_message_size": number;
};
export type Idrevppfiubhve = {
    "sender": number;
};
export type I9s2h36kr71vk9 = {
    "channel_id": Anonymize<I50mrcbubp554e>;
};
export type I4lkbiubo9ogq9 = {
    "para": number;
    "num_inbound": number;
    "num_outbound": number;
};
export type Id1baei7m8gkhk = {
    "channels": number;
};
export type I96ftepqm4vs7m = {
    "channel_id": Anonymize<I50mrcbubp554e>;
    "open_requests": number;
};
export type Ic3430470j4mbv = {
    "sender": number;
    "recipient": number;
    "max_capacity": number;
    "max_message_size": number;
};
export type Ic3n7nqb6fffo0 = {
    "target_system_chain": number;
};
export type Ifkh1ep7g9h3rv = AnonymousEnum<{
    "force_unfreeze": undefined;
}>;
export type I7a6dbilbccifr = AnonymousEnum<{
    "report_dispute_lost_unsigned": Anonymize<I2ecddbrt3sjqn>;
}>;
export type I2ecddbrt3sjqn = {
    "dispute_proof": {
        "time_slot": Anonymize<Iee37emj23tmbu>;
        "kind": Anonymize<I9ng4p85mim3lc>;
        "validator_index": number;
        "validator_id": FixedSizeBinary<32>;
    };
    "key_owner_proof": Anonymize<I3ia7aufsoj0l1>;
};
export type Iee37emj23tmbu = {
    "session_index": number;
    "candidate_hash": FixedSizeBinary<32>;
};
export type I1qq9dc763kccf = AnonymousEnum<{
    /**
     * Create a single on demand core order.
     * Will use the spot price for the current block and will reap the account if needed.
     *
     * Parameters:
     * - `origin`: The sender of the call, funds will be withdrawn from this account.
     * - `max_amount`: The maximum balance to withdraw from the origin to place an order.
     * - `para_id`: A `ParaId` the origin wants to provide blockspace for.
     *
     * Errors:
     * - `InsufficientBalance`: from the Currency implementation
     * - `QueueFull`
     * - `SpotPriceHigherThanMaxAmount`
     *
     * Events:
     * - `OnDemandOrderPlaced`
     */
    "place_order_allow_death": Anonymize<Iaa7g3f5tlv3gf>;
    /**
     * Same as the [`place_order_allow_death`](Self::place_order_allow_death) call , but with a
     * check that placing the order will not reap the account.
     *
     * Parameters:
     * - `origin`: The sender of the call, funds will be withdrawn from this account.
     * - `max_amount`: The maximum balance to withdraw from the origin to place an order.
     * - `para_id`: A `ParaId` the origin wants to provide blockspace for.
     *
     * Errors:
     * - `InsufficientBalance`: from the Currency implementation
     * - `QueueFull`
     * - `SpotPriceHigherThanMaxAmount`
     *
     * Events:
     * - `OnDemandOrderPlaced`
     */
    "place_order_keep_alive": Anonymize<Iaa7g3f5tlv3gf>;
    /**
     * Create a single on demand core order with credits.
     * Will charge the owner's on-demand credit account the spot price for the current block.
     *
     * Parameters:
     * - `origin`: The sender of the call, on-demand credits will be withdrawn from this
     * account.
     * - `max_amount`: The maximum number of credits to spend from the origin to place an
     * order.
     * - `para_id`: A `ParaId` the origin wants to provide blockspace for.
     *
     * Errors:
     * - `InsufficientCredits`
     * - `QueueFull`
     * - `SpotPriceHigherThanMaxAmount`
     *
     * Events:
     * - `OnDemandOrderPlaced`
     */
    "place_order_with_credits": Anonymize<Iaa7g3f5tlv3gf>;
}>;
export type Iaa7g3f5tlv3gf = {
    "max_amount": bigint;
    "para_id": number;
};
export type Icclqj5sge2nc7 = AnonymousEnum<{
    /**
     * Register head data and validation code for a reserved Para Id.
     *
     * ## Arguments
     * - `origin`: Must be called by a `Signed` origin.
     * - `id`: The para ID. Must be owned/managed by the `origin` signing account.
     * - `genesis_head`: The genesis head data of the parachain/thread.
     * - `validation_code`: The initial validation code of the parachain/thread.
     *
     * ## Deposits/Fees
     * The account with the originating signature must reserve a deposit.
     *
     * The deposit is required to cover the costs associated with storing the genesis head
     * data and the validation code.
     * This accounts for the potential to store validation code of a size up to the
     * `max_code_size`, as defined in the configuration pallet
     *
     * Anything already reserved previously for this para ID is accounted for.
     *
     * ## Events
     * The `Registered` event is emitted in case of success.
     */
    "register": Anonymize<I7mf0sij342109>;
    /**
     * Force the registration of a Para Id on the relay chain.
     *
     * This function must be called by a Root origin.
     *
     * The deposit taken can be specified for this registration. Any `ParaId`
     * can be registered, including sub-1000 IDs which are System Parachains.
     */
    "force_register": Anonymize<Ibvirp862qkkup>;
    /**
     * Deregister a Para Id, freeing all data and returning any deposit.
     *
     * The caller must be Root, the `para` owner, or the `para` itself. The para must be an
     * on-demand parachain.
     */
    "deregister": Anonymize<Ic5b47dj4coa3r>;
    /**
     * Swap a lease holding parachain with another parachain, either on-demand or lease
     * holding.
     *
     * The origin must be Root, the `para` owner, or the `para` itself.
     *
     * The swap will happen only if there is already an opposite swap pending. If there is not,
     * the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
     *
     * The `ParaId`s remain mapped to the same head data and code so external code can rely on
     * `ParaId` to be a long-term identifier of a notional "parachain". However, their
     * scheduling info (i.e. whether they're an on-demand parachain or lease holding
     * parachain), auction information and the auction deposit are switched.
     */
    "swap": Anonymize<Idehabrqi23sc0>;
    /**
     * Remove a manager lock from a para. This will allow the manager of a
     * previously locked para to deregister or swap a para without using governance.
     *
     * Can only be called by the Root origin or the parachain.
     */
    "remove_lock": Anonymize<Iaus4cb3drhu9q>;
    /**
     * Reserve a Para Id on the relay chain.
     *
     * This function will reserve a new Para Id to be owned/managed by the origin account.
     * The origin account is able to register head data and validation code using `register` to
     * create an on-demand parachain. Using the Slots pallet, an on-demand parachain can then
     * be upgraded to a lease holding parachain.
     *
     * ## Arguments
     * - `origin`: Must be called by a `Signed` origin. Becomes the manager/owner of the new
     * para ID.
     *
     * ## Deposits/Fees
     * The origin must reserve a deposit of `ParaDeposit` for the registration.
     *
     * ## Events
     * The `Reserved` event is emitted in case of success, which provides the ID reserved for
     * use.
     */
    "reserve": undefined;
    /**
     * Add a manager lock from a para. This will prevent the manager of a
     * para to deregister or swap a para.
     *
     * Can be called by Root, the parachain, or the parachain manager if the parachain is
     * unlocked.
     */
    "add_lock": Anonymize<Iaus4cb3drhu9q>;
    /**
     * Schedule a parachain upgrade.
     *
     * This will kick off a check of `new_code` by all validators. After the majority of the
     * validators have reported on the validity of the code, the code will either be enacted
     * or the upgrade will be rejected. If the code will be enacted, the current code of the
     * parachain will be overwritten directly. This means that any PoV will be checked by this
     * new code. The parachain itself will not be informed explicitly that the validation code
     * has changed.
     *
     * Can be called by Root, the parachain, or the parachain manager if the parachain is
     * unlocked.
     */
    "schedule_code_upgrade": Anonymize<I1k3urvkqqshbc>;
    /**
     * Set the parachain's current head.
     *
     * Can be called by Root, the parachain, or the parachain manager if the parachain is
     * unlocked.
     */
    "set_current_head": Anonymize<I2ff0ffsh15vej>;
}>;
export type I7mf0sij342109 = {
    "id": number;
    "genesis_head": Binary;
    "validation_code": Binary;
};
export type Ibvirp862qkkup = {
    "who": SS58String;
    "deposit": bigint;
    "id": number;
    "genesis_head": Binary;
    "validation_code": Binary;
};
export type Ic5b47dj4coa3r = {
    "id": number;
};
export type Idehabrqi23sc0 = {
    "id": number;
    "other": number;
};
export type Iafhis924j14hg = AnonymousEnum<{
    /**
     * Just a connect into the `lease_out` call, in case Root wants to force some lease to
     * happen independently of any other on-chain mechanism to use it.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     */
    "force_lease": Anonymize<Idfpo6162k0hq>;
    /**
     * Clear all leases for a Para Id, refunding any deposits back to the original owners.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     */
    "clear_all_leases": Anonymize<Iaus4cb3drhu9q>;
    /**
     * Try to onboard a parachain that has a lease for the current lease period.
     *
     * This function can be useful if there was some state issue with a para that should
     * have onboarded, but was unable to. As long as they have a lease period, we can
     * let them onboard from here.
     *
     * Origin must be signed, but can be called by anyone.
     */
    "trigger_onboard": Anonymize<Iaus4cb3drhu9q>;
}>;
export type Idfpo6162k0hq = {
    "para": number;
    "leaser": SS58String;
    "amount": bigint;
    "period_begin": number;
    "period_count": number;
};
export type I4a8qeimc5p3qn = AnonymousEnum<{
    /**
     * Create a new auction.
     *
     * This can only happen when there isn't already an auction in progress and may only be
     * called by the root origin. Accepts the `duration` of this auction and the
     * `lease_period_index` of the initial lease period of the four that are to be auctioned.
     */
    "new_auction": Anonymize<I19hvnphoaj44l>;
    /**
     * Make a new bid from an account (including a parachain account) for deploying a new
     * parachain.
     *
     * Multiple simultaneous bids from the same bidder are allowed only as long as all active
     * bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
     *
     * - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
     * funded by) the same account.
     * - `auction_index` is the index of the auction to bid on. Should just be the present
     * value of `AuctionCounter`.
     * - `first_slot` is the first lease period index of the range to bid on. This is the
     * absolute lease period index value, not an auction-specific offset.
     * - `last_slot` is the last lease period index of the range to bid on. This is the
     * absolute lease period index value, not an auction-specific offset.
     * - `amount` is the amount to bid to be held as deposit for the parachain should the
     * bid win. This amount is held throughout the range.
     */
    "bid": Anonymize<I1ng31ej27mh4k>;
    /**
     * Cancel an in-progress auction.
     *
     * Can only be called by Root origin.
     */
    "cancel_auction": undefined;
}>;
export type I19hvnphoaj44l = {
    "duration": number;
    "lease_period_index": number;
};
export type I1ng31ej27mh4k = {
    "para": number;
    "auction_index": number;
    "first_slot": number;
    "last_slot": number;
    "amount": bigint;
};
export type Iaj4q75nu5v2i2 = AnonymousEnum<{
    /**
     * Create a new crowdloaning campaign for a parachain slot with the given lease period
     * range.
     *
     * This applies a lock to your parachain configuration, ensuring that it cannot be changed
     * by the parachain manager.
     */
    "create": Anonymize<I85qkvekflgteq>;
    /**
     * Contribute to a crowd sale. This will transfer some balance over to fund a parachain
     * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
     */
    "contribute": Anonymize<I1qt5nua7ua655>;
    /**
     * Withdraw full balance of a specific contributor.
     *
     * Origin must be signed, but can come from anyone.
     *
     * The fund must be either in, or ready for, retirement. For a fund to be *in* retirement,
     * then the retirement flag must be set. For a fund to be ready for retirement, then:
     * - it must not already be in retirement;
     * - the amount of raised funds must be bigger than the _free_ balance of the account;
     * - and either:
     * - the block number must be at least `end`; or
     * - the current lease period must be greater than the fund's `last_period`.
     *
     * In this case, the fund's retirement flag is set and its `end` is reset to the current
     * block number.
     *
     * - `who`: The account whose contribution should be withdrawn.
     * - `index`: The parachain to whose crowdloan the contribution was made.
     */
    "withdraw": Anonymize<Ia1u3jll6a06ae>;
    /**
     * Automatically refund contributors of an ended crowdloan.
     * Due to weight restrictions, this function may need to be called multiple
     * times to fully refund all users. We will refund `RemoveKeysLimit` users at a time.
     *
     * Origin must be signed, but can come from anyone.
     */
    "refund": Anonymize<I666bl2fqjkejo>;
    /**
     * Remove a fund after the retirement period has ended and all funds have been returned.
     */
    "dissolve": Anonymize<I666bl2fqjkejo>;
    /**
     * Edit the configuration for an in-progress crowdloan.
     *
     * Can only be called by Root origin.
     */
    "edit": Anonymize<I85qkvekflgteq>;
    /**
     * Add an optional memo to an existing crowdloan contribution.
     *
     * Origin must be Signed, and the user must have contributed to the crowdloan.
     */
    "add_memo": Anonymize<I7cl9esn1l72m7>;
    /**
     * Poke the fund into `NewRaise`
     *
     * Origin must be Signed, and the fund has non-zero raise.
     */
    "poke": Anonymize<I666bl2fqjkejo>;
    /**
     * Contribute your entire balance to a crowd sale. This will transfer the entire balance of
     * a user over to fund a parachain slot. It will be withdrawable when the crowdloan has
     * ended and the funds are unused.
     */
    "contribute_all": Anonymize<Id68sq6o2gm8qi>;
}>;
export type I85qkvekflgteq = {
    "index": number;
    "cap": bigint;
    "first_period": number;
    "last_period": number;
    "end": number;
    "verifier"?: Anonymize<I21lmi57mmu91l>;
};
export type I1qt5nua7ua655 = {
    "index": number;
    "value": bigint;
    "signature"?: Anonymize<I86cdjmsf3a81s>;
};
export type I86cdjmsf3a81s = (MultiSignature) | undefined;
export type MultiSignature = Enum<{
    "Ed25519": FixedSizeBinary<64>;
    "Sr25519": FixedSizeBinary<64>;
    "Ecdsa": FixedSizeBinary<65>;
}>;
export declare const MultiSignature: GetEnum<MultiSignature>;
export type I7cl9esn1l72m7 = {
    "index": number;
    "memo": Binary;
};
export type Id68sq6o2gm8qi = {
    "index": number;
    "signature"?: Anonymize<I86cdjmsf3a81s>;
};
export type Ifr31g56am9igr = AnonymousEnum<{
    /**
     * Request the configuration to be updated with the specified number of cores. Warning:
     * Since this only schedules a configuration update, it takes two sessions to come into
     * effect.
     *
     * - `origin`: Root or the Coretime Chain
     * - `count`: total number of cores
     */
    "request_core_count": Anonymize<Iafscmv8tjf0ou>;
    /**
     * Request to claim the instantaneous coretime sales revenue starting from the block it was
     * last claimed until and up to the block specified. The claimed amount value is sent back
     * to the Coretime chain in a `notify_revenue` message. At the same time, the amount is
     * teleported to the Coretime chain.
     */
    "request_revenue_at": Anonymize<Ibtsa3docbr9el>;
    "credit_account": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * Receive instructions from the `ExternalBrokerOrigin`, detailing how a specific core is
     * to be used.
     *
     * Parameters:
     * -`origin`: The `ExternalBrokerOrigin`, assumed to be the coretime chain.
     * -`core`: The core that should be scheduled.
     * -`begin`: The starting blockheight of the instruction.
     * -`assignment`: How the blockspace should be utilised.
     * -`end_hint`: An optional hint as to when this particular set of instructions will end.
     */
    "assign_core": Anonymize<I2gpmmfdqv3cdc>;
}>;
export type I2gpmmfdqv3cdc = {
    "core": number;
    "begin": number;
    "assignment": Anonymize<Idt36labebpqsd>;
    "end_hint"?: Anonymize<I4arjljr6dpflb>;
};
export type I39l72gdmkk30t = AnonymousEnum<{
    /**
     * Control the automatic migration.
     *
     * The dispatch origin of this call must be [`Config::ControlOrigin`].
     */
    "control_auto_migration": Anonymize<I7psec5e6ghc64>;
    /**
     * Continue the migration for the given `limits`.
     *
     * The dispatch origin of this call can be any signed account.
     *
     * This transaction has NO MONETARY INCENTIVES. calling it will not reward anyone. Albeit,
     * Upon successful execution, the transaction fee is returned.
     *
     * The (potentially over-estimated) of the byte length of all the data read must be
     * provided for up-front fee-payment and weighing. In essence, the caller is guaranteeing
     * that executing the current `MigrationTask` with the given `limits` will not exceed
     * `real_size_upper` bytes of read data.
     *
     * The `witness_task` is merely a helper to prevent the caller from being slashed or
     * generally trigger a migration that they do not intend. This parameter is just a message
     * from caller, saying that they believed `witness_task` was the last state of the
     * migration, and they only wish for their transaction to do anything, if this assumption
     * holds. In case `witness_task` does not match, the transaction fails.
     *
     * Based on the documentation of [`MigrationTask::migrate_until_exhaustion`], the
     * recommended way of doing this is to pass a `limit` that only bounds `count`, as the
     * `size` limit can always be overwritten.
     */
    "continue_migrate": Anonymize<I2psb0sladd863>;
    /**
     * Migrate the list of top keys by iterating each of them one by one.
     *
     * This does not affect the global migration process tracker ([`MigrationProcess`]), and
     * should only be used in case any keys are leftover due to a bug.
     */
    "migrate_custom_top": Anonymize<I585tk8khua0gk>;
    /**
     * Migrate the list of child keys by iterating each of them one by one.
     *
     * All of the given child keys must be present under one `child_root`.
     *
     * This does not affect the global migration process tracker ([`MigrationProcess`]), and
     * should only be used in case any keys are leftover due to a bug.
     */
    "migrate_custom_child": Anonymize<I3ut99di214ru2>;
    /**
     * Set the maximum limit of the signed migration.
     */
    "set_signed_max_limits": Anonymize<Iemkp87d26vsbh>;
    /**
     * Forcefully set the progress the running migration.
     *
     * This is only useful in one case: the next key to migrate is too big to be migrated with
     * a signed account, in a parachain context, and we simply want to skip it. A reasonable
     * example of this would be `:code:`, which is both very expensive to migrate, and commonly
     * used, so probably it is already migrated.
     *
     * In case you mess things up, you can also, in principle, use this to reset the migration
     * process.
     */
    "force_set_progress": Anonymize<I4ahfrt5dscf6q>;
}>;
export type I7psec5e6ghc64 = {
    "maybe_config"?: Anonymize<Ib17t3992hb64n>;
};
export type I2psb0sladd863 = {
    "limits": Anonymize<I215mkl885p4da>;
    "real_size_upper": number;
    "witness_task": Anonymize<If354jrdedj0pj>;
};
export type I585tk8khua0gk = {
    "keys": Anonymize<Itom7fk49o0c9>;
    "witness_size": number;
};
export type I3ut99di214ru2 = {
    "root": Binary;
    "child_keys": Anonymize<Itom7fk49o0c9>;
    "total_size": number;
};
export type Iemkp87d26vsbh = {
    "limits": Anonymize<I215mkl885p4da>;
};
export type I4ahfrt5dscf6q = {
    "progress_top": Anonymize<I1ufmh6d8psvik>;
    "progress_child": Anonymize<I1ufmh6d8psvik>;
};
export type I6k1inef986368 = AnonymousEnum<{
    "send": Anonymize<Ia5cotcvi888ln>;
    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * **This function is deprecated: Use `limited_teleport_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     */
    "teleport_assets": Anonymize<I21jsa919m88fd>;
    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     */
    "reserve_transfer_assets": Anonymize<I21jsa919m88fd>;
    /**
     * Execute an XCM message from a local, signed, origin.
     *
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     *
     * No more than `max_weight` will be used in its attempted execution. If this is less than
     * the maximum amount of weight that the message could take to be executed, then no
     * execution attempt will be made.
     */
    "execute": Anonymize<Iegif7m3upfe1k>;
    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    "force_xcm_version": Anonymize<I9kt8c221c83ln>;
    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     */
    "force_default_xcm_version": Anonymize<Ic76kfh5ebqkpl>;
    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    "force_subscribe_version_notify": Anonymize<Icscpmubum33bq>;
    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we are currently subscribed for XCM version
     * notifications which we no longer desire.
     */
    "force_unsubscribe_version_notify": Anonymize<Icscpmubum33bq>;
    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    "limited_reserve_transfer_assets": Anonymize<I21d2olof7eb60>;
    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    "limited_teleport_assets": Anonymize<I21d2olof7eb60>;
    /**
     * Set or unset the global suspension state of the XCM executor.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     */
    "force_suspension": Anonymize<Ibgm4rnf22lal1>;
    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve, or through teleports.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
     * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
     * operation will fail and the sent assets may be at risk.
     *
     * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
     * to `dest`, no limitations imposed on `fees`.
     * - for local reserve: transfer assets to sovereign account of destination chain and
     * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
     * `beneficiary`.
     * - for destination reserve: burn local assets and forward a notification to `dest` chain
     * to withdraw the reserve assets from this chain's sovereign account and deposit them
     * to `beneficiary`.
     * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
     * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
     * and deposit reserve-based assets to `beneficiary`.
     * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
     * assets and deposit them to `beneficiary`.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
     * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
     * from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    "transfer_assets": Anonymize<I21d2olof7eb60>;
    /**
     * Claims assets trapped on this pallet because of leftover assets during XCM execution.
     *
     * - `origin`: Anyone can call this extrinsic.
     * - `assets`: The exact assets that were trapped. Use the version to specify what version
     * was the latest when they were trapped.
     * - `beneficiary`: The location/account where the claimed assets will be deposited.
     */
    "claim_assets": Anonymize<Ie68np0vpihith>;
    /**
     * Transfer assets from the local chain to the destination chain using explicit transfer
     * types for assets and fees.
     *
     * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
     * provide the `assets_transfer_type` to be used for `assets`:
     * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
     * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
     * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
     * the remote `reserve` is Asset Hub.
     * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
     * mint/teleport assets and deposit them to `beneficiary`.
     *
     * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
     * buy execution using transferred `assets` identified by `remote_fees_id`.
     * Make sure enough of the specified `remote_fees_id` asset is included in the given list
     * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * `remote_fees_id` may use different transfer type than rest of `assets` and can be
     * specified through `fees_transfer_type`.
     *
     * The caller needs to specify what should happen to the transferred assets once they reach
     * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
     * contains the instructions to execute on `dest` as a final step.
     * This is usually as simple as:
     * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
     * but could be something more exotic like sending the `assets` even further.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
     * parachain across a bridge to another ecosystem destination.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
     * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
     * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
     * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
     * transfer, which also determines what happens to the assets on the destination chain.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    "transfer_assets_using_type_and_then": Anonymize<I9bnv6lu0crf1q>;
    /**
     * Authorize another `aliaser` location to alias into the local `origin` making this call.
     * The `aliaser` is only authorized until the provided `expiry` block number.
     * The call can also be used for a previously authorized alias in order to update its
     * `expiry` block number.
     *
     * Usually useful to allow your local account to be aliased into from a remote location
     * also under your control (like your account on another chain).
     *
     * WARNING: make sure the caller `origin` (you) trusts the `aliaser` location to act in
     * their/your name. Once authorized using this call, the `aliaser` can freely impersonate
     * `origin` in XCM programs executed on the local chain.
     */
    "add_authorized_alias": Anonymize<Iauhjqifrdklq7>;
    /**
     * Remove a previously authorized `aliaser` from the list of locations that can alias into
     * the local `origin` making this call.
     */
    "remove_authorized_alias": Anonymize<Ie1uso9m8rt5cf>;
    /**
     * Remove all previously authorized `aliaser`s that can alias into the local `origin`
     * making this call.
     */
    "remove_all_authorized_aliases": undefined;
}>;
export type Ia5cotcvi888ln = {
    "dest": XcmVersionedLocation;
    "message": XcmVersionedXcm;
};
export type XcmVersionedXcm = Enum<{
    "V3": Anonymize<Ianvng4e08j9ii>;
    "V4": Anonymize<Iegrepoo0c1jc5>;
    "V5": Anonymize<Ict03eedr8de9s>;
}>;
export declare const XcmVersionedXcm: GetEnum<XcmVersionedXcm>;
export type Ianvng4e08j9ii = Array<XcmV3Instruction>;
export type XcmV3Instruction = Enum<{
    "WithdrawAsset": Anonymize<Iai6dhqiq3bach>;
    "ReserveAssetDeposited": Anonymize<Iai6dhqiq3bach>;
    "ReceiveTeleportedAsset": Anonymize<Iai6dhqiq3bach>;
    "QueryResponse": {
        "query_id": bigint;
        "response": XcmV3Response;
        "max_weight": Anonymize<I4q39t5hn830vp>;
        "querier"?: Anonymize<Ia9cgf4r40b26h>;
    };
    "TransferAsset": {
        "assets": Anonymize<Iai6dhqiq3bach>;
        "beneficiary": Anonymize<I4c0s5cioidn76>;
    };
    "TransferReserveAsset": {
        "assets": Anonymize<Iai6dhqiq3bach>;
        "dest": Anonymize<I4c0s5cioidn76>;
        "xcm": Anonymize<Ianvng4e08j9ii>;
    };
    "Transact": Anonymize<I92p6l5cs3fr50>;
    "HrmpNewChannelOpenRequest": Anonymize<I5uhhrjqfuo4e5>;
    "HrmpChannelAccepted": Anonymize<Ifij4jam0o7sub>;
    "HrmpChannelClosing": Anonymize<Ieeb4svd9i8fji>;
    "ClearOrigin": undefined;
    "DescendOrigin": XcmV3Junctions;
    "ReportError": Anonymize<I4r3v6e91d1qbs>;
    "DepositAsset": {
        "assets": XcmV3MultiassetMultiAssetFilter;
        "beneficiary": Anonymize<I4c0s5cioidn76>;
    };
    "DepositReserveAsset": {
        "assets": XcmV3MultiassetMultiAssetFilter;
        "dest": Anonymize<I4c0s5cioidn76>;
        "xcm": Anonymize<Ianvng4e08j9ii>;
    };
    "ExchangeAsset": {
        "give": XcmV3MultiassetMultiAssetFilter;
        "want": Anonymize<Iai6dhqiq3bach>;
        "maximal": boolean;
    };
    "InitiateReserveWithdraw": {
        "assets": XcmV3MultiassetMultiAssetFilter;
        "reserve": Anonymize<I4c0s5cioidn76>;
        "xcm": Anonymize<Ianvng4e08j9ii>;
    };
    "InitiateTeleport": {
        "assets": XcmV3MultiassetMultiAssetFilter;
        "dest": Anonymize<I4c0s5cioidn76>;
        "xcm": Anonymize<Ianvng4e08j9ii>;
    };
    "ReportHolding": {
        "response_info": Anonymize<I4r3v6e91d1qbs>;
        "assets": XcmV3MultiassetMultiAssetFilter;
    };
    "BuyExecution": {
        "fees": Anonymize<Idcm24504c8bkk>;
        "weight_limit": XcmV3WeightLimit;
    };
    "RefundSurplus": undefined;
    "SetErrorHandler": Anonymize<Ianvng4e08j9ii>;
    "SetAppendix": Anonymize<Ianvng4e08j9ii>;
    "ClearError": undefined;
    "ClaimAsset": {
        "assets": Anonymize<Iai6dhqiq3bach>;
        "ticket": Anonymize<I4c0s5cioidn76>;
    };
    "Trap": bigint;
    "SubscribeVersion": Anonymize<Ieprdqqu7ildvr>;
    "UnsubscribeVersion": undefined;
    "BurnAsset": Anonymize<Iai6dhqiq3bach>;
    "ExpectAsset": Anonymize<Iai6dhqiq3bach>;
    "ExpectOrigin"?: Anonymize<Ia9cgf4r40b26h>;
    "ExpectError"?: Anonymize<I7sltvf8v2nure>;
    "ExpectTransactStatus": XcmV3MaybeErrorCode;
    "QueryPallet": Anonymize<Iba5bdbapp16oo>;
    "ExpectPallet": Anonymize<Id7mf37dkpgfjs>;
    "ReportTransactStatus": Anonymize<I4r3v6e91d1qbs>;
    "ClearTransactStatus": undefined;
    "UniversalOrigin": XcmV3Junction;
    "ExportMessage": {
        "network": XcmV3JunctionNetworkId;
        "destination": XcmV3Junctions;
        "xcm": Anonymize<Ianvng4e08j9ii>;
    };
    "LockAsset": {
        "asset": Anonymize<Idcm24504c8bkk>;
        "unlocker": Anonymize<I4c0s5cioidn76>;
    };
    "UnlockAsset": {
        "asset": Anonymize<Idcm24504c8bkk>;
        "target": Anonymize<I4c0s5cioidn76>;
    };
    "NoteUnlockable": {
        "asset": Anonymize<Idcm24504c8bkk>;
        "owner": Anonymize<I4c0s5cioidn76>;
    };
    "RequestUnlock": {
        "asset": Anonymize<Idcm24504c8bkk>;
        "locker": Anonymize<I4c0s5cioidn76>;
    };
    "SetFeesMode": Anonymize<I4nae9rsql8fa7>;
    "SetTopic": FixedSizeBinary<32>;
    "ClearTopic": undefined;
    "AliasOrigin": Anonymize<I4c0s5cioidn76>;
    "UnpaidExecution": Anonymize<I40d50jeai33oq>;
}>;
export declare const XcmV3Instruction: GetEnum<XcmV3Instruction>;
export type Ia9cgf4r40b26h = (Anonymize<I4c0s5cioidn76>) | undefined;
export type I92p6l5cs3fr50 = {
    "origin_kind": XcmV2OriginKind;
    "require_weight_at_most": Anonymize<I4q39t5hn830vp>;
    "call": Binary;
};
export type I4r3v6e91d1qbs = {
    "destination": Anonymize<I4c0s5cioidn76>;
    "query_id": bigint;
    "max_weight": Anonymize<I4q39t5hn830vp>;
};
export type XcmV3MultiassetMultiAssetFilter = Enum<{
    "Definite": Anonymize<Iai6dhqiq3bach>;
    "Wild": XcmV3MultiassetWildMultiAsset;
}>;
export declare const XcmV3MultiassetMultiAssetFilter: GetEnum<XcmV3MultiassetMultiAssetFilter>;
export type XcmV3MultiassetWildMultiAsset = Enum<{
    "All": undefined;
    "AllOf": {
        "id": XcmV3MultiassetAssetId;
        "fun": XcmV2MultiassetWildFungibility;
    };
    "AllCounted": number;
    "AllOfCounted": {
        "id": XcmV3MultiassetAssetId;
        "fun": XcmV2MultiassetWildFungibility;
        "count": number;
    };
}>;
export declare const XcmV3MultiassetWildMultiAsset: GetEnum<XcmV3MultiassetWildMultiAsset>;
export type Iba5bdbapp16oo = {
    "module_name": Binary;
    "response_info": Anonymize<I4r3v6e91d1qbs>;
};
export type I40d50jeai33oq = {
    "weight_limit": XcmV3WeightLimit;
    "check_origin"?: Anonymize<Ia9cgf4r40b26h>;
};
export type Iegrepoo0c1jc5 = Array<XcmV4Instruction>;
export type XcmV4Instruction = Enum<{
    "WithdrawAsset": Anonymize<I50mli3hb64f9b>;
    "ReserveAssetDeposited": Anonymize<I50mli3hb64f9b>;
    "ReceiveTeleportedAsset": Anonymize<I50mli3hb64f9b>;
    "QueryResponse": {
        "query_id": bigint;
        "response": XcmV4Response;
        "max_weight": Anonymize<I4q39t5hn830vp>;
        "querier"?: Anonymize<Ia9cgf4r40b26h>;
    };
    "TransferAsset": {
        "assets": Anonymize<I50mli3hb64f9b>;
        "beneficiary": Anonymize<I4c0s5cioidn76>;
    };
    "TransferReserveAsset": {
        "assets": Anonymize<I50mli3hb64f9b>;
        "dest": Anonymize<I4c0s5cioidn76>;
        "xcm": Anonymize<Iegrepoo0c1jc5>;
    };
    "Transact": Anonymize<I92p6l5cs3fr50>;
    "HrmpNewChannelOpenRequest": Anonymize<I5uhhrjqfuo4e5>;
    "HrmpChannelAccepted": Anonymize<Ifij4jam0o7sub>;
    "HrmpChannelClosing": Anonymize<Ieeb4svd9i8fji>;
    "ClearOrigin": undefined;
    "DescendOrigin": XcmV3Junctions;
    "ReportError": Anonymize<I4r3v6e91d1qbs>;
    "DepositAsset": {
        "assets": XcmV4AssetAssetFilter;
        "beneficiary": Anonymize<I4c0s5cioidn76>;
    };
    "DepositReserveAsset": {
        "assets": XcmV4AssetAssetFilter;
        "dest": Anonymize<I4c0s5cioidn76>;
        "xcm": Anonymize<Iegrepoo0c1jc5>;
    };
    "ExchangeAsset": {
        "give": XcmV4AssetAssetFilter;
        "want": Anonymize<I50mli3hb64f9b>;
        "maximal": boolean;
    };
    "InitiateReserveWithdraw": {
        "assets": XcmV4AssetAssetFilter;
        "reserve": Anonymize<I4c0s5cioidn76>;
        "xcm": Anonymize<Iegrepoo0c1jc5>;
    };
    "InitiateTeleport": {
        "assets": XcmV4AssetAssetFilter;
        "dest": Anonymize<I4c0s5cioidn76>;
        "xcm": Anonymize<Iegrepoo0c1jc5>;
    };
    "ReportHolding": {
        "response_info": Anonymize<I4r3v6e91d1qbs>;
        "assets": XcmV4AssetAssetFilter;
    };
    "BuyExecution": {
        "fees": Anonymize<Ia5l7mu5a6v49o>;
        "weight_limit": XcmV3WeightLimit;
    };
    "RefundSurplus": undefined;
    "SetErrorHandler": Anonymize<Iegrepoo0c1jc5>;
    "SetAppendix": Anonymize<Iegrepoo0c1jc5>;
    "ClearError": undefined;
    "ClaimAsset": {
        "assets": Anonymize<I50mli3hb64f9b>;
        "ticket": Anonymize<I4c0s5cioidn76>;
    };
    "Trap": bigint;
    "SubscribeVersion": Anonymize<Ieprdqqu7ildvr>;
    "UnsubscribeVersion": undefined;
    "BurnAsset": Anonymize<I50mli3hb64f9b>;
    "ExpectAsset": Anonymize<I50mli3hb64f9b>;
    "ExpectOrigin"?: Anonymize<Ia9cgf4r40b26h>;
    "ExpectError"?: Anonymize<I7sltvf8v2nure>;
    "ExpectTransactStatus": XcmV3MaybeErrorCode;
    "QueryPallet": Anonymize<Iba5bdbapp16oo>;
    "ExpectPallet": Anonymize<Id7mf37dkpgfjs>;
    "ReportTransactStatus": Anonymize<I4r3v6e91d1qbs>;
    "ClearTransactStatus": undefined;
    "UniversalOrigin": XcmV3Junction;
    "ExportMessage": {
        "network": XcmV3JunctionNetworkId;
        "destination": XcmV3Junctions;
        "xcm": Anonymize<Iegrepoo0c1jc5>;
    };
    "LockAsset": {
        "asset": Anonymize<Ia5l7mu5a6v49o>;
        "unlocker": Anonymize<I4c0s5cioidn76>;
    };
    "UnlockAsset": {
        "asset": Anonymize<Ia5l7mu5a6v49o>;
        "target": Anonymize<I4c0s5cioidn76>;
    };
    "NoteUnlockable": {
        "asset": Anonymize<Ia5l7mu5a6v49o>;
        "owner": Anonymize<I4c0s5cioidn76>;
    };
    "RequestUnlock": {
        "asset": Anonymize<Ia5l7mu5a6v49o>;
        "locker": Anonymize<I4c0s5cioidn76>;
    };
    "SetFeesMode": Anonymize<I4nae9rsql8fa7>;
    "SetTopic": FixedSizeBinary<32>;
    "ClearTopic": undefined;
    "AliasOrigin": Anonymize<I4c0s5cioidn76>;
    "UnpaidExecution": Anonymize<I40d50jeai33oq>;
}>;
export declare const XcmV4Instruction: GetEnum<XcmV4Instruction>;
export type XcmV4AssetAssetFilter = Enum<{
    "Definite": Anonymize<I50mli3hb64f9b>;
    "Wild": XcmV4AssetWildAsset;
}>;
export declare const XcmV4AssetAssetFilter: GetEnum<XcmV4AssetAssetFilter>;
export type XcmV4AssetWildAsset = Enum<{
    "All": undefined;
    "AllOf": {
        "id": Anonymize<I4c0s5cioidn76>;
        "fun": XcmV2MultiassetWildFungibility;
    };
    "AllCounted": number;
    "AllOfCounted": {
        "id": Anonymize<I4c0s5cioidn76>;
        "fun": XcmV2MultiassetWildFungibility;
        "count": number;
    };
}>;
export declare const XcmV4AssetWildAsset: GetEnum<XcmV4AssetWildAsset>;
export type I21jsa919m88fd = {
    "dest": XcmVersionedLocation;
    "beneficiary": XcmVersionedLocation;
    "assets": XcmVersionedAssets;
    "fee_asset_item": number;
};
export type Iegif7m3upfe1k = {
    "message": XcmVersionedXcm;
    "max_weight": Anonymize<I4q39t5hn830vp>;
};
export type Ic76kfh5ebqkpl = {
    "maybe_xcm_version"?: Anonymize<I4arjljr6dpflb>;
};
export type Icscpmubum33bq = {
    "location": XcmVersionedLocation;
};
export type I21d2olof7eb60 = {
    "dest": XcmVersionedLocation;
    "beneficiary": XcmVersionedLocation;
    "assets": XcmVersionedAssets;
    "fee_asset_item": number;
    "weight_limit": XcmV3WeightLimit;
};
export type Ibgm4rnf22lal1 = {
    "suspended": boolean;
};
export type Ie68np0vpihith = {
    "assets": XcmVersionedAssets;
    "beneficiary": XcmVersionedLocation;
};
export type I9bnv6lu0crf1q = {
    "dest": XcmVersionedLocation;
    "assets": XcmVersionedAssets;
    "assets_transfer_type": Enum<{
        "Teleport": undefined;
        "LocalReserve": undefined;
        "DestinationReserve": undefined;
        "RemoteReserve": XcmVersionedLocation;
    }>;
    "remote_fees_id": XcmVersionedAssetId;
    "fees_transfer_type": Enum<{
        "Teleport": undefined;
        "LocalReserve": undefined;
        "DestinationReserve": undefined;
        "RemoteReserve": XcmVersionedLocation;
    }>;
    "custom_xcm_on_dest": XcmVersionedXcm;
    "weight_limit": XcmV3WeightLimit;
};
export type Iauhjqifrdklq7 = {
    "aliaser": XcmVersionedLocation;
    "expires"?: Anonymize<I35p85j063s0il>;
};
export type Ie1uso9m8rt5cf = {
    "aliaser": XcmVersionedLocation;
};
export type I3lic4llm6egbr = AnonymousEnum<{
    /**
     * Remove a page which has no more messages remaining to be processed or is stale.
     */
    "reap_page": Anonymize<Ibv4ep0hngvn9e>;
    /**
     * Execute an overweight message.
     *
     * Temporary processing errors will be propagated whereas permanent errors are treated
     * as success condition.
     *
     * - `origin`: Must be `Signed`.
     * - `message_origin`: The origin from which the message to be executed arrived.
     * - `page`: The page in the queue in which the message to be executed is sitting.
     * - `index`: The index into the queue of the message to be executed.
     * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
     * of the message.
     *
     * Benchmark complexity considerations: O(index + weight_limit).
     */
    "execute_overweight": Anonymize<Ieoqregtp7b00>;
}>;
export type Ibv4ep0hngvn9e = {
    "message_origin": ParachainsInclusionAggregateMessageOrigin;
    "page_index": number;
};
export type Ieoqregtp7b00 = {
    "message_origin": ParachainsInclusionAggregateMessageOrigin;
    "page": number;
    "index": number;
    "weight_limit": Anonymize<I4q39t5hn830vp>;
};
export type If582h5gr5gh6f = AnonymousEnum<{
    /**
     * Initialize a conversion rate to native balance for the given asset.
     *
     * ## Complexity
     * - O(1)
     */
    "create": Anonymize<I9c4d50jrp7as1>;
    /**
     * Update the conversion rate to native balance for the given asset.
     *
     * ## Complexity
     * - O(1)
     */
    "update": Anonymize<I9c4d50jrp7as1>;
    /**
     * Remove an existing conversion rate to native balance for the given asset.
     *
     * ## Complexity
     * - O(1)
     */
    "remove": Anonymize<Ifplevr9hp8jo3>;
}>;
export type Idmcmrk34p8gic = AnonymousEnum<{
    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     */
    "report_double_voting": Anonymize<I3pirohb0sp3ic>;
    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    "report_double_voting_unsigned": Anonymize<I3pirohb0sp3ic>;
    /**
     * Reset BEEFY consensus by setting a new BEEFY genesis at `delay_in_blocks` blocks in the
     * future.
     *
     * Note: `delay_in_blocks` has to be at least 1.
     */
    "set_new_genesis": Anonymize<Iemqna2uucuei9>;
    /**
     * Report fork voting equivocation. This method will verify the equivocation proof
     * and validate the given key ownership proof against the extracted offender.
     * If both are valid, the offence will be reported.
     */
    "report_fork_voting": Anonymize<Idrvp50hbkv2k2>;
    /**
     * Report fork voting equivocation. This method will verify the equivocation proof
     * and validate the given key ownership proof against the extracted offender.
     * If both are valid, the offence will be reported.
     *
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    "report_fork_voting_unsigned": Anonymize<Idrvp50hbkv2k2>;
    /**
     * Report future block voting equivocation. This method will verify the equivocation proof
     * and validate the given key ownership proof against the extracted offender.
     * If both are valid, the offence will be reported.
     */
    "report_future_block_voting": Anonymize<Ie11u326g2gsj3>;
    /**
     * Report future block voting equivocation. This method will verify the equivocation proof
     * and validate the given key ownership proof against the extracted offender.
     * If both are valid, the offence will be reported.
     *
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    "report_future_block_voting_unsigned": Anonymize<Ie11u326g2gsj3>;
}>;
export type I3pirohb0sp3ic = {
    "equivocation_proof": Anonymize<Ifiofttj73fsk1>;
    "key_owner_proof": Anonymize<I3ia7aufsoj0l1>;
};
export type Ifiofttj73fsk1 = {
    "first": Anonymize<I3eao7ea0kppv8>;
    "second": Anonymize<I3eao7ea0kppv8>;
};
export type I3eao7ea0kppv8 = {
    "commitment": {
        "payload": Array<[FixedSizeBinary<2>, Binary]>;
        "block_number": number;
        "validator_set_id": bigint;
    };
    "id": FixedSizeBinary<33>;
    "signature": FixedSizeBinary<65>;
};
export type Iemqna2uucuei9 = {
    "delay_in_blocks": number;
};
export type Idrvp50hbkv2k2 = {
    "equivocation_proof": {
        "vote": Anonymize<I3eao7ea0kppv8>;
        "ancestry_proof": {
            "prev_peaks": Anonymize<Ic5m5lp1oioo8r>;
            "prev_leaf_count": bigint;
            "leaf_count": bigint;
            "items": Array<[bigint, FixedSizeBinary<32>]>;
        };
        "header": Anonymize<Ic952bubvq4k7d>;
    };
    "key_owner_proof": Anonymize<I3ia7aufsoj0l1>;
};
export type Ie11u326g2gsj3 = {
    "equivocation_proof": Anonymize<I3eao7ea0kppv8>;
    "key_owner_proof": Anonymize<I3ia7aufsoj0l1>;
};
export type I3he5stuuhiokq = {
    "inflation": bigint;
    "next_mint": Anonymize<I200n1ov5tbcvr>;
};
export type Iaqet9jc3ihboe = {
    "header": Anonymize<Ic952bubvq4k7d>;
    "extrinsics": Anonymize<Itom7fk49o0c9>;
};
export type I2v50gu3s1aqk6 = AnonymousEnum<{
    "AllExtrinsics": undefined;
    "OnlyInherents": undefined;
}>;
export type I18snogr7stc3e = ResultPayload<Anonymize<I7jgmvdrn822de>, Anonymize<I5nrjkj9qumobs>>;
export type I5nrjkj9qumobs = AnonymousEnum<{
    "Invalid": Enum<{
        "Call": undefined;
        "Payment": undefined;
        "Future": undefined;
        "Stale": undefined;
        "BadProof": undefined;
        "AncientBirthBlock": undefined;
        "ExhaustsResources": undefined;
        "Custom": number;
        "BadMandatory": undefined;
        "MandatoryValidation": undefined;
        "BadSigner": undefined;
        "IndeterminateImplicit": undefined;
        "UnknownOrigin": undefined;
    }>;
    "Unknown": TransactionValidityUnknownTransaction;
}>;
export type TransactionValidityUnknownTransaction = Enum<{
    "CannotLookup": undefined;
    "NoUnsignedValidator": undefined;
    "Custom": number;
}>;
export declare const TransactionValidityUnknownTransaction: GetEnum<TransactionValidityUnknownTransaction>;
export type If7uv525tdvv7a = Array<[FixedSizeBinary<8>, Binary]>;
export type I2an1fs2eiebjp = {
    "okay": boolean;
    "fatal_error": boolean;
    "errors": Anonymize<If7uv525tdvv7a>;
};
export type TransactionValidityTransactionSource = Enum<{
    "InBlock": undefined;
    "Local": undefined;
    "External": undefined;
}>;
export declare const TransactionValidityTransactionSource: GetEnum<TransactionValidityTransactionSource>;
export type I9ask1o4tfvcvs = ResultPayload<{
    "priority": bigint;
    "requires": Anonymize<Itom7fk49o0c9>;
    "provides": Anonymize<Itom7fk49o0c9>;
    "longevity": bigint;
    "propagate": boolean;
}, Anonymize<I5nrjkj9qumobs>>;
export type I5985kfq7sspta = [Anonymize<Iarlj3qd8u1v13>, {
    "session_start_block": number;
    "group_rotation_frequency": number;
    "now": number;
}];
export type I1v2gv5pb5e508 = Array<Enum<{
    "Occupied": {
        "next_up_on_available"?: (Anonymize<I4fn9prq249c92>) | undefined;
        "occupied_since": number;
        "time_out_at": number;
        "next_up_on_time_out"?: (Anonymize<I4fn9prq249c92>) | undefined;
        "availability": {
            bytes: Uint8Array;
            bitsLen: number;
        };
        "group_responsible": number;
        "candidate_hash": FixedSizeBinary<32>;
        "candidate_descriptor": Anonymize<Ibnq2mkuf1plno>;
    };
    "Scheduled": Anonymize<I4fn9prq249c92>;
    "Free": undefined;
}>>;
export type I4fn9prq249c92 = {
    "para_id": number;
    "collator"?: Anonymize<I4s6vifaf8k998>;
};
export type OccupiedCoreAssumption = Enum<{
    "Included": undefined;
    "TimedOut": undefined;
    "Free": undefined;
}>;
export declare const OccupiedCoreAssumption: GetEnum<OccupiedCoreAssumption>;
export type I9kavsa730sjfr = (Anonymize<Ifn6q3equiq9qi>) | undefined;
export type Ifn6q3equiq9qi = {
    "parent_head": Binary;
    "relay_parent_number": number;
    "relay_parent_storage_root": FixedSizeBinary<32>;
    "max_pov_size": number;
};
export type Ifn3gc8nc1jruq = ([Anonymize<Ifn6q3equiq9qi>, FixedSizeBinary<32>]) | undefined;
export type I92i81n5kpcgte = (Anonymize<I35p841butcer2>) | undefined;
export type Ifb5bd3f9a1lu8 = Array<Enum<{
    "CandidateBacked": Anonymize<I4s0gvfhejmdp2>;
    "CandidateIncluded": Anonymize<I4s0gvfhejmdp2>;
    "CandidateTimedOut": Anonymize<I9njsgm2qsgnil>;
}>>;
export type I2pf0b05mc7sdr = Array<[number, Anonymize<Iev3u09i2vqn93>]>;
export type I9aev4k6tfeeom = (Anonymize<Ia1viqq9k85bv1>) | undefined;
export type Ialuks4a6iupcs = (Anonymize<I9m4rd2a7lc9md>) | undefined;
export type Idv6tqqnmb3i1j = Array<[number, FixedSizeBinary<32>, Anonymize<I87u7jalc0lhah>]>;
export type Iekan13fn586c2 = (Anonymize<I80rnntpog8qp6>) | undefined;
export type Idrp5a1qbbi2au = Array<[number, FixedSizeBinary<32>, {
    "keys": Anonymize<Iqnbvitf7a7l3>;
    "kind": SlashingOffenceKind;
}]>;
export type SlashingOffenceKind = Enum<{
    "ForInvalid": undefined;
    "AgainstValid": undefined;
}>;
export declare const SlashingOffenceKind: GetEnum<SlashingOffenceKind>;
export type I943rhn463avqr = {
    "time_slot": Anonymize<Iee37emj23tmbu>;
    "kind": SlashingOffenceKind;
    "validator_index": number;
    "validator_id": FixedSizeBinary<32>;
};
export type I2eq6ah7t620fb = ({
    "constraints": {
        "min_relay_parent_number": number;
        "max_pov_size": number;
        "max_code_size": number;
        "ump_remaining": number;
        "ump_remaining_bytes": number;
        "max_ump_num_per_candidate": number;
        "dmp_remaining_messages": Anonymize<Icgljjb6j82uhn>;
        "hrmp_inbound": Anonymize<Icgljjb6j82uhn>;
        "hrmp_channels_out": Anonymize<I1ilbeu6195gbh>;
        "max_hrmp_num_per_candidate": number;
        "required_parent": Binary;
        "validation_code_hash": FixedSizeBinary<32>;
        "upgrade_restriction"?: Anonymize<Ia3sb0vgvovhtg>;
        "future_validation_code"?: Anonymize<I7gtb9g2qv4r10>;
    };
    "pending_availability": Array<{
        "candidate_hash": FixedSizeBinary<32>;
        "descriptor": Anonymize<Ibnq2mkuf1plno>;
        "commitments": Anonymize<Ic1d4u2opv3fst>;
        "relay_parent_number": number;
        "max_pov_size": number;
    }>;
}) | undefined;
export type I1ilbeu6195gbh = Array<[number, {
    "bytes_remaining": number;
    "messages_remaining": number;
}]>;
export type Ia3sb0vgvovhtg = (UpgradeRestriction) | undefined;
export type I7gtb9g2qv4r10 = (Anonymize<I4p5t2krb1gmvp>) | undefined;
export type Ieskfd0vl6pk5b = Array<Anonymize<I35p841butcer2>>;
export type I56054ohcnjknc = ({
    "min_relay_parent_number": number;
    "max_pov_size": number;
    "max_code_size": number;
    "max_head_data_size": number;
    "ump_remaining": number;
    "ump_remaining_bytes": number;
    "max_ump_num_per_candidate": number;
    "dmp_remaining_messages": Anonymize<Icgljjb6j82uhn>;
    "hrmp_inbound": Anonymize<Icgljjb6j82uhn>;
    "hrmp_channels_out": Anonymize<I1ilbeu6195gbh>;
    "max_hrmp_num_per_candidate": number;
    "required_parent": Binary;
    "validation_code_hash": FixedSizeBinary<32>;
    "upgrade_restriction"?: Anonymize<Ia3sb0vgvovhtg>;
    "future_validation_code"?: Anonymize<I7gtb9g2qv4r10>;
}) | undefined;
export type Ifogo2hpqpe6b4 = ({
    "validators": Anonymize<I2fb54desdqd9n>;
    "id": bigint;
}) | undefined;
export type I25plekc1moieu = {
    "vote": Anonymize<I3eao7ea0kppv8>;
    "ancestry_proof": Binary;
    "header": Anonymize<Ic952bubvq4k7d>;
};
export type I7rj2bnb76oko1 = ResultPayload<FixedSizeBinary<32>, MmrPrimitivesError>;
export type MmrPrimitivesError = Enum<{
    "InvalidNumericOp": undefined;
    "Push": undefined;
    "GetRoot": undefined;
    "Commit": undefined;
    "GenerateProof": undefined;
    "Verify": undefined;
    "LeafNotFound": undefined;
    "PalletNotIncluded": undefined;
    "InvalidLeafIndex": undefined;
    "InvalidBestKnownBlock": undefined;
}>;
export declare const MmrPrimitivesError: GetEnum<MmrPrimitivesError>;
export type I4o356o7eq06ms = ResultPayload<bigint, MmrPrimitivesError>;
export type I46e127tr8ma2h = ResultPayload<[Anonymize<Itom7fk49o0c9>, Anonymize<I38ee9is0n4jn9>], MmrPrimitivesError>;
export type I38ee9is0n4jn9 = {
    "leaf_indices": Anonymize<Iafqnechp3omqg>;
    "leaf_count": bigint;
    "items": Anonymize<Ic5m5lp1oioo8r>;
};
export type Ie88mmnuvmuvp5 = ResultPayload<undefined, MmrPrimitivesError>;
export type Iems84l8lk2v0c = {
    "slot_duration": bigint;
    "epoch_length": bigint;
    "c": Anonymize<I200n1ov5tbcvr>;
    "authorities": Anonymize<I3geksg000c171>;
    "randomness": FixedSizeBinary<32>;
    "allowed_slots": BabeAllowedSlots;
};
export type I1r5ke30ueqo0r = {
    "epoch_index": bigint;
    "start_slot": bigint;
    "duration": bigint;
    "authorities": Anonymize<I3geksg000c171>;
    "randomness": FixedSizeBinary<32>;
    "config": Anonymize<I8jnd4d8ip6djo>;
};
export type Icerf8h8pdu8ss = (Array<[Binary, FixedSizeBinary<4>]>) | undefined;
export type I6spmpef2c7svf = {
    "weight": Anonymize<I4q39t5hn830vp>;
    "class": DispatchClass;
    "partial_fee": bigint;
};
export type Iei2mvq0mjvt81 = {
    "inclusion_fee"?: ({
        "base_fee": bigint;
        "len_fee": bigint;
        "adjusted_weight_fee": bigint;
    }) | undefined;
    "tip": bigint;
};
export type Ic2a7pon8ahsec = AnonymousEnum<{
    "System": Anonymize<Iekve0i6djpd9f>;
    "Scheduler": Anonymize<Idmih7a3dohotq>;
    "Preimage": Anonymize<If81ks88t5mpk5>;
    "Babe": Anonymize<I1jeo0dpbkma5g>;
    "Timestamp": Anonymize<I7d75gqfg6jh9c>;
    "Indices": Anonymize<I67ac6i6ihmvpt>;
    "Balances": Anonymize<I9svldsp29mh87>;
    "Staking": Anonymize<Icm294co91mkfj>;
    "Session": Anonymize<Iceajactc9a8pc>;
    "Grandpa": Anonymize<I5u9ggmn8umfqm>;
    "Treasury": Anonymize<I6jnp85onk3m8j>;
    "ConvictionVoting": Anonymize<Ie5kd08tutk56t>;
    "Referenda": Anonymize<I8tu311hskajnl>;
    "Whitelist": Anonymize<Icqvg77845cnfe>;
    "Claims": Anonymize<Id0dj18ct09hlp>;
    "Vesting": Anonymize<Icgf8vmtkbnu4u>;
    "Utility": Anonymize<I9hqnknd58s34t>;
    "Proxy": Anonymize<Ibhvuekbs2l561>;
    "Multisig": Anonymize<I9oe8lfo3d66rb>;
    "Bounties": Anonymize<I1nnef4ljub6d0>;
    "ChildBounties": Anonymize<I1b6drdhvt5hl9>;
    "ElectionProviderMultiPhase": Anonymize<I15soeogelbbbh>;
    "VoterList": Anonymize<Ifvfo1l0vu2o7e>;
    "NominationPools": Anonymize<I57mljkkr28m9p>;
    "FastUnstake": Anonymize<I44snhj1gahvrd>;
    "Configuration": Anonymize<I3ah0kpgrv4i88>;
    "ParasShared": undefined;
    "ParaInclusion": undefined;
    "ParaInherent": Anonymize<I1nu19212e8egv>;
    "Paras": Anonymize<Ie2dden5k4kk7t>;
    "Initializer": Anonymize<Ieggtnkc96vvt7>;
    "Hrmp": Anonymize<I45adic8nko129>;
    "ParasDisputes": Anonymize<Ifkh1ep7g9h3rv>;
    "ParasSlashing": Anonymize<I7a6dbilbccifr>;
    "OnDemand": Anonymize<I1qq9dc763kccf>;
    "Registrar": Anonymize<Icclqj5sge2nc7>;
    "Slots": Anonymize<Iafhis924j14hg>;
    "Auctions": Anonymize<I4a8qeimc5p3qn>;
    "Crowdloan": Anonymize<Iaj4q75nu5v2i2>;
    "Coretime": Anonymize<Ifr31g56am9igr>;
    "StateTrieMigration": Anonymize<I39l72gdmkk30t>;
    "XcmPallet": Anonymize<I6k1inef986368>;
    "MessageQueue": Anonymize<I3lic4llm6egbr>;
    "AssetRate": Anonymize<If582h5gr5gh6f>;
    "Beefy": Anonymize<Idmcmrk34p8gic>;
}>;
export type Iftvbctbo05fu4 = ResultPayload<Array<XcmVersionedAssetId>, Anonymize<Iavct6f844hfju>>;
export type Iavct6f844hfju = AnonymousEnum<{
    "Unimplemented": undefined;
    "VersionedConversionFailed": undefined;
    "WeightNotComputable": undefined;
    "UnhandledXcmVersion": undefined;
    "AssetNotFound": undefined;
    "Unroutable": undefined;
}>;
export type Ic0c3req3mlc1l = ResultPayload<Anonymize<I4q39t5hn830vp>, Anonymize<Iavct6f844hfju>>;
export type I7ocn4njqde3v5 = ResultPayload<bigint, Anonymize<Iavct6f844hfju>>;
export type Iek7ha36da9mf5 = ResultPayload<XcmVersionedAssets, Anonymize<Iavct6f844hfju>>;
export type I990rh9s22nr3n = ResultPayload<{
    "execution_result": Anonymize<I5d7bc003ki6lp>;
    "emitted_events": Anonymize<Ibu7ekhe050qg5>;
    "local_xcm"?: Anonymize<Ieqgqma27vbupd>;
    "forwarded_xcms": Anonymize<Ialhmrpub9sefe>;
}, Anonymize<I55ku9c5gk50hb>>;
export type Ibu7ekhe050qg5 = Array<Anonymize<I6argrunpb283o>>;
export type Ieqgqma27vbupd = (XcmVersionedXcm) | undefined;
export type Ialhmrpub9sefe = Array<[XcmVersionedLocation, Array<XcmVersionedXcm>]>;
export type I55ku9c5gk50hb = AnonymousEnum<{
    "Unimplemented": undefined;
    "VersionedConversionFailed": undefined;
}>;
export type I81kqmc6ciiem1 = ResultPayload<{
    "execution_result": Anonymize<I6uq5gb4s805s7>;
    "emitted_events": Anonymize<Ibu7ekhe050qg5>;
    "forwarded_xcms": Anonymize<Ialhmrpub9sefe>;
}, Anonymize<I55ku9c5gk50hb>>;
export type Ieh6nis3hdbtgi = ResultPayload<SS58String, Anonymize<Ibaohq34aedndv>>;
export type Ibaohq34aedndv = AnonymousEnum<{
    "Unsupported": undefined;
    "VersionedConversionFailed": undefined;
}>;
export type Ie9sr1iqcg3cgm = ResultPayload<undefined, string>;
export type I1mqgk2tmnn9i2 = (string) | undefined;
export type I6lr8sctk0bi4e = Array<string>;
export type Ifjt5n168dqvjr = Array<{
    "phase": Phase;
    "event": Anonymize<I6lsdonc548n1k>;
    "topics": Anonymize<Ic5m5lp1oioo8r>;
}>;
export type I6lsdonc548n1k = AnonymousEnum<{
    "System": Anonymize<I9ushindbc92pr>;
    "ParachainSystem": Anonymize<Icbsekf57miplo>;
    "RootTesting": RootTestingEvent;
    "Balances": Anonymize<Ia7dcv14t183mr>;
    "TransactionPayment": Anonymize<Ie5dbofecudee7>;
    "ParachainStaking": Anonymize<I9577i6u47v6lh>;
    "AuthorFilter": Anonymize<I5bnfp30l6pckt>;
    "AuthorMapping": Anonymize<Ia10guihti0p5o>;
    "MoonbeamOrbiters": Anonymize<I5aqrfqq5edsc4>;
    "Utility": Anonymize<Idon02n0b5ot2q>;
    "Proxy": Anonymize<I4siqj0d555e55>;
    "MaintenanceMode": Anonymize<Iasp0s95mcru2e>;
    "Identity": Anonymize<Ie06p890f230de>;
    "Migrations": Anonymize<If9t4he614soun>;
    "Multisig": Anonymize<I792aphuk2reca>;
    "Parameters": Anonymize<Ibm6tc4nsqbfv2>;
    "EVM": Anonymize<I9k071kk4cn1u8>;
    "Ethereum": Anonymize<I510u4q1qqh897>;
    "Scheduler": Anonymize<Ie0l88bqsjarft>;
    "Preimage": PreimageEvent;
    "ConvictionVoting": Anonymize<I3n6c4456jluo4>;
    "Referenda": Anonymize<I1rmulho2k04le>;
    "Whitelist": Anonymize<Ifm7fpth9i6ptp>;
    "TreasuryCouncilCollective": Anonymize<I5h2o3ndahavg8>;
    "OpenTechCommitteeCollective": Anonymize<I5h2o3ndahavg8>;
    "Treasury": Anonymize<Ifu4dro40k0eu1>;
    "CrowdloanRewards": Anonymize<I4k3v1jn280snc>;
    "XcmpQueue": Anonymize<Idsqc7mhp6nnle>;
    "CumulusXcm": Anonymize<Ihpdgvt7vs2cb>;
    "PolkadotXcm": Anonymize<Iel5f66clbekc3>;
    "Assets": Anonymize<I64ops44uf7inr>;
    "AssetManager": Anonymize<I2ql1p3qbtsfeo>;
    "XcmTransactor": Anonymize<Icnbh4vp7l3kna>;
    "EthereumXcm": Anonymize<Id747bemfev6ju>;
    "MessageQueue": Anonymize<I2kosejppk3jon>;
    "EvmForeignAssets": Anonymize<I6sk30irag0rj6>;
    "XcmWeightTrader": Anonymize<I97lmcp19lo158>;
    "EmergencyParaXcm": Anonymize<Iaakhspsugfd34>;
    "MultiBlockMigrations": Anonymize<I94co7vj7h6bo>;
    "Randomness": Anonymize<Idb6rt29f52h0r>;
    "BridgeKusamaGrandpa": Anonymize<I9kq3t3h4e6cgp>;
    "BridgeKusamaParachains": Anonymize<I4icsif27kbhhg>;
    "BridgeKusamaMessages": Anonymize<I5fvsm0mnhja4b>;
    "BridgeXcmOverMoonriver": Anonymize<Icq1j4dp95np9v>;
}>;
export type I9ushindbc92pr = AnonymousEnum<{
    /**
     * An extrinsic completed successfully.
     */
    "ExtrinsicSuccess": Anonymize<Ia82mnkmeo2rhc>;
    /**
     * An extrinsic failed.
     */
    "ExtrinsicFailed": Anonymize<Iun9l0lrnqvtt>;
    /**
     * `:code` was updated.
     */
    "CodeUpdated": undefined;
    /**
     * A new account was created.
     */
    "NewAccount": Anonymize<I64i34r0tn439a>;
    /**
     * An account was reaped.
     */
    "KilledAccount": Anonymize<I64i34r0tn439a>;
    /**
     * On on-chain remark happened.
     */
    "Remarked": Anonymize<Ift7k6k1vpbi63>;
    /**
     * An upgrade was authorized.
     */
    "UpgradeAuthorized": Anonymize<Ibgl04rn6nbfm6>;
}>;
export type Iun9l0lrnqvtt = {
    "dispatch_error": Anonymize<I68l22felg5oio>;
    "dispatch_info": Anonymize<Ic9s8f85vjtncc>;
};
export type I68l22felg5oio = AnonymousEnum<{
    "Other": undefined;
    "CannotLookup": undefined;
    "BadOrigin": undefined;
    "Module": Enum<{
        "System": Anonymize<I5o0s7c8q1cc9b>;
        "ParachainSystem": Anonymize<I9p95gln24a0rn>;
        "Timestamp": undefined;
        "ParachainInfo": undefined;
        "RootTesting": undefined;
        "Balances": Anonymize<Idj13i7adlomht>;
        "TransactionPayment": undefined;
        "ParachainStaking": Anonymize<I6hcbj1ree5rsi>;
        "AuthorInherent": Anonymize<I5c3gg38pjmqhh>;
        "AuthorFilter": undefined;
        "AuthorMapping": Anonymize<Ichov9c3f3r3rv>;
        "MoonbeamOrbiters": Anonymize<Iepqugsiqq6imb>;
        "AsyncBacking": undefined;
        "Utility": Anonymize<I8dt2g2hcrgh36>;
        "Proxy": Anonymize<Iuvt54ei4cehc>;
        "MaintenanceMode": Anonymize<I8s7vfljrnbv2h>;
        "Identity": Anonymize<Ib8gja1crqq8kd>;
        "Migrations": Anonymize<I6s9tdseg6im74>;
        "ProxyGenesisCompanion": undefined;
        "Multisig": Anonymize<Ia76qmhhg4jvb9>;
        "MoonbeamLazyMigrations": Anonymize<Idhl1engopvp6a>;
        "Parameters": undefined;
        "EthereumChainId": undefined;
        "EVM": Anonymize<I4pkfap0t7vk0t>;
        "Ethereum": Anonymize<I1mp6vnoh32l4q>;
        "Scheduler": Anonymize<If7oa8fprnilo5>;
        "Preimage": Anonymize<I4cfhml1prt4lu>;
        "ConvictionVoting": Anonymize<Idfa8k8ikssbsf>;
        "Referenda": Anonymize<I84u4ul208g742>;
        "Whitelist": Anonymize<I15nctscutpbeh>;
        "TreasuryCouncilCollective": Anonymize<I7n7mcmnnfjfl2>;
        "OpenTechCommitteeCollective": Anonymize<I7n7mcmnnfjfl2>;
        "Treasury": Anonymize<I36uss0m9fpcsf>;
        "CrowdloanRewards": Anonymize<I2706qiiphdcau>;
        "XcmpQueue": Anonymize<Idnnbndsjjeqqs>;
        "CumulusXcm": undefined;
        "PolkadotXcm": Anonymize<I87j95aq93d7dq>;
        "Assets": Anonymize<Iapedqb0veh71>;
        "AssetManager": Anonymize<I92qmgektithad>;
        "XcmTransactor": Anonymize<I9pec2tat0b1sl>;
        "EthereumXcm": Anonymize<I56l2vckpgl5af>;
        "Erc20XcmBridge": undefined;
        "MessageQueue": Anonymize<I5iupade5ag2dp>;
        "EvmForeignAssets": Anonymize<I9anko43uhagj7>;
        "XcmWeightTrader": Anonymize<If3q1473tk8erv>;
        "EmergencyParaXcm": Anonymize<Icbr66vmtvbshn>;
        "MultiBlockMigrations": Anonymize<Iaaqq5jevtahm8>;
        "RelayStorageRoots": undefined;
        "PrecompileBenchmarks": Anonymize<Iddk0c4t42r294>;
        "Randomness": Anonymize<I20bvui08h13pf>;
        "BridgeKusamaGrandpa": Anonymize<I8dk2jmk95gk46>;
        "BridgeKusamaParachains": Anonymize<I74ucapvsteups>;
        "BridgeKusamaMessages": Anonymize<Iebf0p0uiquo3o>;
        "BridgeXcmOverMoonriver": Anonymize<I33kod71r5qeg9>;
    }>;
    "ConsumerRemaining": undefined;
    "NoProviders": undefined;
    "TooManyConsumers": undefined;
    "Token": TokenError;
    "Arithmetic": ArithmeticError;
    "Transactional": TransactionalError;
    "Exhausted": undefined;
    "Corruption": undefined;
    "Unavailable": undefined;
    "RootNotAllowed": undefined;
    "Trie": Anonymize<Idh4cj79bvroj8>;
}>;
export type I9p95gln24a0rn = AnonymousEnum<{
    /**
     * Attempt to upgrade validation function while existing upgrade pending.
     */
    "OverlappingUpgrades": undefined;
    /**
     * Polkadot currently prohibits this parachain from upgrading its validation function.
     */
    "ProhibitedByPolkadot": undefined;
    /**
     * The supplied validation function has compiled into a blob larger than Polkadot is
     * willing to run.
     */
    "TooBig": undefined;
    /**
     * The inherent which supplies the validation data did not run this block.
     */
    "ValidationDataNotAvailable": undefined;
    /**
     * The inherent which supplies the host configuration did not run this block.
     */
    "HostConfigurationNotAvailable": undefined;
    /**
     * No validation function upgrade is currently scheduled.
     */
    "NotScheduled": undefined;
    /**
     * No code upgrade has been authorized.
     */
    "NothingAuthorized": undefined;
    /**
     * The given code upgrade has not been authorized.
     */
    "Unauthorized": undefined;
}>;
export type I6hcbj1ree5rsi = AnonymousEnum<{
    "DelegatorDNE": undefined;
    "DelegatorDNEinTopNorBottom": undefined;
    "DelegatorDNEInDelegatorSet": undefined;
    "CandidateDNE": undefined;
    "DelegationDNE": undefined;
    "DelegatorExists": undefined;
    "CandidateExists": undefined;
    "CandidateBondBelowMin": undefined;
    "InsufficientBalance": undefined;
    "DelegatorBondBelowMin": undefined;
    "DelegationBelowMin": undefined;
    "AlreadyOffline": undefined;
    "AlreadyActive": undefined;
    "DelegatorAlreadyLeaving": undefined;
    "DelegatorNotLeaving": undefined;
    "DelegatorCannotLeaveYet": undefined;
    "CannotDelegateIfLeaving": undefined;
    "CandidateAlreadyLeaving": undefined;
    "CandidateNotLeaving": undefined;
    "CandidateCannotLeaveYet": undefined;
    "CannotGoOnlineIfLeaving": undefined;
    "ExceedMaxDelegationsPerDelegator": undefined;
    "AlreadyDelegatedCandidate": undefined;
    "InvalidSchedule": undefined;
    "CannotSetBelowMin": undefined;
    "RoundLengthMustBeGreaterThanTotalSelectedCollators": undefined;
    "NoWritingSameValue": undefined;
    "TotalInflationDistributionPercentExceeds100": undefined;
    "TooLowCandidateCountWeightHintJoinCandidates": undefined;
    "TooLowCandidateCountWeightHintCancelLeaveCandidates": undefined;
    "TooLowCandidateCountToLeaveCandidates": undefined;
    "TooLowDelegationCountToDelegate": undefined;
    "TooLowCandidateDelegationCountToDelegate": undefined;
    "TooLowCandidateDelegationCountToLeaveCandidates": undefined;
    "TooLowDelegationCountToLeaveDelegators": undefined;
    "PendingCandidateRequestsDNE": undefined;
    "PendingCandidateRequestAlreadyExists": undefined;
    "PendingCandidateRequestNotDueYet": undefined;
    "PendingDelegationRequestDNE": undefined;
    "PendingDelegationRequestAlreadyExists": undefined;
    "PendingDelegationRequestNotDueYet": undefined;
    "CannotDelegateLessThanOrEqualToLowestBottomWhenFull": undefined;
    "PendingDelegationRevoke": undefined;
    "TooLowDelegationCountToAutoCompound": undefined;
    "TooLowCandidateAutoCompoundingDelegationCountToAutoCompound": undefined;
    "TooLowCandidateAutoCompoundingDelegationCountToDelegate": undefined;
    "TooLowCollatorCountToNotifyAsInactive": undefined;
    "CannotBeNotifiedAsInactive": undefined;
    "TooLowCandidateAutoCompoundingDelegationCountToLeaveCandidates": undefined;
    "TooLowCandidateCountWeightHint": undefined;
    "TooLowCandidateCountWeightHintGoOffline": undefined;
    "CandidateLimitReached": undefined;
    "CannotSetAboveMaxCandidates": undefined;
    "MarkingOfflineNotEnabled": undefined;
    "CurrentRoundTooLow": undefined;
}>;
export type I5c3gg38pjmqhh = AnonymousEnum<{
    /**
     * Author already set in block.
     */
    "AuthorAlreadySet": undefined;
    /**
     * No AccountId was found to be associated with this author
     */
    "NoAccountId": undefined;
    /**
     * The author in the inherent is not an eligible author.
     */
    "CannotBeAuthor": undefined;
}>;
export type Ichov9c3f3r3rv = AnonymousEnum<{
    /**
     * The association can't be cleared because it is not found.
     */
    "AssociationNotFound": undefined;
    /**
     * The association can't be cleared because it belongs to another account.
     */
    "NotYourAssociation": undefined;
    /**
     * This account cannot set an author because it cannon afford the security deposit
     */
    "CannotAffordSecurityDeposit": undefined;
    /**
     * The NimbusId in question is already associated and cannot be overwritten
     */
    "AlreadyAssociated": undefined;
    /**
     * No existing NimbusId can be found for the account
     */
    "OldAuthorIdNotFound": undefined;
    /**
     * Keys have wrong size
     */
    "WrongKeySize": undefined;
    /**
     * Failed to decode NimbusId for `set_keys`
     */
    "DecodeNimbusFailed": undefined;
    /**
     * Failed to decode T::Keys for `set_keys`
     */
    "DecodeKeysFailed": undefined;
}>;
export type Iepqugsiqq6imb = AnonymousEnum<{
    /**
     * The collator is already added in orbiters program.
     */
    "CollatorAlreadyAdded": undefined;
    /**
     * This collator is not in orbiters program.
     */
    "CollatorNotFound": undefined;
    /**
     * There are already too many orbiters associated with this collator.
     */
    "CollatorPoolTooLarge": undefined;
    /**
     * There are more collator pools than the number specified in the parameter.
     */
    "CollatorsPoolCountTooLow": undefined;
    /**
     * The minimum deposit required to register as an orbiter has not yet been included in the
     * onchain storage
     */
    "MinOrbiterDepositNotSet": undefined;
    /**
     * This orbiter is already associated with this collator.
     */
    "OrbiterAlreadyInPool": undefined;
    /**
     * This orbiter has not made a deposit
     */
    "OrbiterDepositNotFound": undefined;
    /**
     * This orbiter is not found
     */
    "OrbiterNotFound": undefined;
    /**
     * The orbiter is still at least in one pool
     */
    "OrbiterStillInAPool": undefined;
}>;
export type I8s7vfljrnbv2h = AnonymousEnum<{
    /**
     * The chain cannot enter maintenance mode because it is already in maintenance mode
     */
    "AlreadyInMaintenanceMode": undefined;
    /**
     * The chain cannot resume normal operation because it is not in maintenance mode
     */
    "NotInMaintenanceMode": undefined;
}>;
export type Ib8gja1crqq8kd = AnonymousEnum<{
    /**
     * Too many subs-accounts.
     */
    "TooManySubAccounts": undefined;
    /**
     * Account isn't found.
     */
    "NotFound": undefined;
    /**
     * Account isn't named.
     */
    "NotNamed": undefined;
    /**
     * Empty index.
     */
    "EmptyIndex": undefined;
    /**
     * Fee is changed.
     */
    "FeeChanged": undefined;
    /**
     * No identity found.
     */
    "NoIdentity": undefined;
    /**
     * Sticky judgement.
     */
    "StickyJudgement": undefined;
    /**
     * Judgement given.
     */
    "JudgementGiven": undefined;
    /**
     * Invalid judgement.
     */
    "InvalidJudgement": undefined;
    /**
     * The index is invalid.
     */
    "InvalidIndex": undefined;
    /**
     * The target is invalid.
     */
    "InvalidTarget": undefined;
    /**
     * Maximum amount of registrars reached. Cannot add any more.
     */
    "TooManyRegistrars": undefined;
    /**
     * Account ID is already named.
     */
    "AlreadyClaimed": undefined;
    /**
     * Sender is not a sub-account.
     */
    "NotSub": undefined;
    /**
     * Sub-account isn't owned by sender.
     */
    "NotOwned": undefined;
    /**
     * The provided judgement was for a different identity.
     */
    "JudgementForDifferentIdentity": undefined;
    /**
     * Error that occurs when there is an issue paying for judgement.
     */
    "JudgementPaymentFailed": undefined;
    /**
     * The provided suffix is too long.
     */
    "InvalidSuffix": undefined;
    /**
     * The sender does not have permission to issue a username.
     */
    "NotUsernameAuthority": undefined;
    /**
     * The authority cannot allocate any more usernames.
     */
    "NoAllocation": undefined;
    /**
     * The signature on a username was not valid.
     */
    "InvalidSignature": undefined;
    /**
     * Setting this username requires a signature, but none was provided.
     */
    "RequiresSignature": undefined;
    /**
     * The username does not meet the requirements.
     */
    "InvalidUsername": undefined;
    /**
     * The username is already taken.
     */
    "UsernameTaken": undefined;
    /**
     * The requested username does not exist.
     */
    "NoUsername": undefined;
    /**
     * The username cannot be forcefully removed because it can still be accepted.
     */
    "NotExpired": undefined;
    /**
     * The username cannot be removed because it's still in the grace period.
     */
    "TooEarly": undefined;
    /**
     * The username cannot be removed because it is not unbinding.
     */
    "NotUnbinding": undefined;
    /**
     * The username cannot be unbound because it is already unbinding.
     */
    "AlreadyUnbinding": undefined;
    /**
     * The action cannot be performed because of insufficient privileges (e.g. authority
     * trying to unbind a username provided by the system).
     */
    "InsufficientPrivileges": undefined;
}>;
export type I6s9tdseg6im74 = AnonymousEnum<{
    /**
     * Missing preimage in original democracy storage
     */
    "PreimageMissing": undefined;
    /**
     * Provided upper bound is too low.
     */
    "WrongUpperBound": undefined;
    /**
     * Preimage is larger than the new max size.
     */
    "PreimageIsTooBig": undefined;
    /**
     * Preimage already exists in the new storage.
     */
    "PreimageAlreadyExists": undefined;
}>;
export type Idhl1engopvp6a = AnonymousEnum<{
    /**
     * The contract already have metadata
     */
    "ContractMetadataAlreadySet": undefined;
    /**
     * Contract not exist
     */
    "ContractNotExist": undefined;
}>;
export type I4pkfap0t7vk0t = AnonymousEnum<{
    /**
     * Not enough balance to perform action
     */
    "BalanceLow": undefined;
    /**
     * Calculating total fee overflowed
     */
    "FeeOverflow": undefined;
    /**
     * Calculating total payment overflowed
     */
    "PaymentOverflow": undefined;
    /**
     * Withdraw fee failed
     */
    "WithdrawFailed": undefined;
    /**
     * Gas price is too low.
     */
    "GasPriceTooLow": undefined;
    /**
     * Nonce is invalid
     */
    "InvalidNonce": undefined;
    /**
     * Gas limit is too low.
     */
    "GasLimitTooLow": undefined;
    /**
     * Gas limit is too high.
     */
    "GasLimitTooHigh": undefined;
    /**
     * The chain id is invalid.
     */
    "InvalidChainId": undefined;
    /**
     * the signature is invalid.
     */
    "InvalidSignature": undefined;
    /**
     * EVM reentrancy
     */
    "Reentrancy": undefined;
    /**
     * EIP-3607,
     */
    "TransactionMustComeFromEOA": undefined;
    /**
     * Undefined error.
     */
    "Undefined": undefined;
}>;
export type I1mp6vnoh32l4q = AnonymousEnum<{
    /**
     * Signature is invalid.
     */
    "InvalidSignature": undefined;
    /**
     * Pre-log is present, therefore transact is not allowed.
     */
    "PreLogExists": undefined;
}>;
export type I7n7mcmnnfjfl2 = AnonymousEnum<{
    /**
     * Account is not a member
     */
    "NotMember": undefined;
    /**
     * Duplicate proposals not allowed
     */
    "DuplicateProposal": undefined;
    /**
     * Proposal must exist
     */
    "ProposalMissing": undefined;
    /**
     * Mismatched index
     */
    "WrongIndex": undefined;
    /**
     * Duplicate vote ignored
     */
    "DuplicateVote": undefined;
    /**
     * Members are already initialized!
     */
    "AlreadyInitialized": undefined;
    /**
     * The close call was made too early, before the end of the voting.
     */
    "TooEarly": undefined;
    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     */
    "TooManyProposals": undefined;
    /**
     * The given weight bound for the proposal was too low.
     */
    "WrongProposalWeight": undefined;
    /**
     * The given length bound for the proposal was too low.
     */
    "WrongProposalLength": undefined;
    /**
     * Prime account is not a member
     */
    "PrimeAccountNotMember": undefined;
    /**
     * Proposal is still active.
     */
    "ProposalActive": undefined;
}>;
export type I2706qiiphdcau = AnonymousEnum<{
    /**
     * User trying to associate a native identity with a relay chain identity for posterior
     * reward claiming provided an already associated relay chain identity
     */
    "AlreadyAssociated": undefined;
    /**
     * Trying to introduce a batch that goes beyond the limits of the funds
     */
    "BatchBeyondFundPot": undefined;
    /**
     * First claim already done
     */
    "FirstClaimAlreadyDone": undefined;
    /**
     * The contribution is not high enough to be eligible for rewards
     */
    "RewardNotHighEnough": undefined;
    /**
     * User trying to associate a native identity with a relay chain identity for posterior
     * reward claiming provided a wrong signature
     */
    "InvalidClaimSignature": undefined;
    /**
     * User trying to claim the first free reward provided the wrong signature
     */
    "InvalidFreeClaimSignature": undefined;
    /**
     * User trying to claim an award did not have an claim associated with it. This may mean
     * they did not contribute to the crowdloan, or they have not yet associated a native id
     * with their contribution
     */
    "NoAssociatedClaim": undefined;
    /**
     * User trying to claim rewards has already claimed all rewards associated with its
     * identity and contribution
     */
    "RewardsAlreadyClaimed": undefined;
    /**
     * Reward vec has already been initialized
     */
    "RewardVecAlreadyInitialized": undefined;
    /**
     * Reward vec has not yet been fully initialized
     */
    "RewardVecNotFullyInitializedYet": undefined;
    /**
     * Rewards should match funds of the pallet
     */
    "RewardsDoNotMatchFund": undefined;
    /**
     * Initialize_reward_vec received too many contributors
     */
    "TooManyContributors": undefined;
    /**
     * Provided vesting period is not valid
     */
    "VestingPeriodNonValid": undefined;
    /**
     * User provided a signature from a non-contributor relay account
     */
    "NonContributedAddressProvided": undefined;
    /**
     * User submitted an unsifficient number of proofs to change the reward address
     */
    "InsufficientNumberOfValidProofs": undefined;
}>;
export type Idnnbndsjjeqqs = AnonymousEnum<{
    /**
     * Setting the queue config failed since one of its values was invalid.
     */
    "BadQueueConfig": undefined;
    /**
     * The execution is already suspended.
     */
    "AlreadySuspended": undefined;
    /**
     * The execution is already resumed.
     */
    "AlreadyResumed": undefined;
    /**
     * There are too many active outbound channels.
     */
    "TooManyActiveOutboundChannels": undefined;
    /**
     * The message is too big.
     */
    "TooBig": undefined;
}>;
export type I87j95aq93d7dq = AnonymousEnum<{
    /**
     * The desired destination was unreachable, generally because there is a no way of routing
     * to it.
     */
    "Unreachable": undefined;
    /**
     * There was some other issue (i.e. not to do with routing) in sending the message.
     * Perhaps a lack of space for buffering the message.
     */
    "SendFailure": undefined;
    /**
     * The message execution fails the filter.
     */
    "Filtered": undefined;
    /**
     * The message's weight could not be determined.
     */
    "UnweighableMessage": undefined;
    /**
     * The destination `Location` provided cannot be inverted.
     */
    "DestinationNotInvertible": undefined;
    /**
     * The assets to be sent are empty.
     */
    "Empty": undefined;
    /**
     * Could not re-anchor the assets to declare the fees for the destination chain.
     */
    "CannotReanchor": undefined;
    /**
     * Too many assets have been attempted for transfer.
     */
    "TooManyAssets": undefined;
    /**
     * Origin is invalid for sending.
     */
    "InvalidOrigin": undefined;
    /**
     * The version of the `Versioned` value used is not able to be interpreted.
     */
    "BadVersion": undefined;
    /**
     * The given location could not be used (e.g. because it cannot be expressed in the
     * desired version of XCM).
     */
    "BadLocation": undefined;
    /**
     * The referenced subscription could not be found.
     */
    "NoSubscription": undefined;
    /**
     * The location is invalid since it already has a subscription from us.
     */
    "AlreadySubscribed": undefined;
    /**
     * Could not check-out the assets for teleportation to the destination chain.
     */
    "CannotCheckOutTeleport": undefined;
    /**
     * The owner does not own (all) of the asset that they wish to do the operation on.
     */
    "LowBalance": undefined;
    /**
     * The asset owner has too many locks on the asset.
     */
    "TooManyLocks": undefined;
    /**
     * The given account is not an identifiable sovereign account for any location.
     */
    "AccountNotSovereign": undefined;
    /**
     * The operation required fees to be paid which the initiator could not meet.
     */
    "FeesNotMet": undefined;
    /**
     * A remote lock with the corresponding data could not be found.
     */
    "LockNotFound": undefined;
    /**
     * The unlock operation cannot succeed because there are still consumers of the lock.
     */
    "InUse": undefined;
    /**
     * Invalid asset, reserve chain could not be determined for it.
     */
    "InvalidAssetUnknownReserve": undefined;
    /**
     * Invalid asset, do not support remote asset reserves with different fees reserves.
     */
    "InvalidAssetUnsupportedReserve": undefined;
    /**
     * Too many assets with different reserve locations have been attempted for transfer.
     */
    "TooManyReserves": undefined;
    /**
     * Local XCM execution incomplete.
     */
    "LocalExecutionIncomplete": undefined;
}>;
export type Iapedqb0veh71 = AnonymousEnum<{
    /**
     * Account balance must be greater than or equal to the transfer amount.
     */
    "BalanceLow": undefined;
    /**
     * The account to alter does not exist.
     */
    "NoAccount": undefined;
    /**
     * The signing account has no permission to do the operation.
     */
    "NoPermission": undefined;
    /**
     * The given asset ID is unknown.
     */
    "Unknown": undefined;
    /**
     * The origin account is frozen.
     */
    "Frozen": undefined;
    /**
     * The asset ID is already taken.
     */
    "InUse": undefined;
    /**
     * Invalid witness data given.
     */
    "BadWitness": undefined;
    /**
     * Minimum balance should be non-zero.
     */
    "MinBalanceZero": undefined;
    /**
     * Unable to increment the consumer reference counters on the account. Either no provider
     * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
     * fewer then the maximum number of consumers has been reached.
     */
    "UnavailableConsumer": undefined;
    /**
     * Invalid metadata given.
     */
    "BadMetadata": undefined;
    /**
     * No approval exists that would allow the transfer.
     */
    "Unapproved": undefined;
    /**
     * The source account would not survive the transfer and it needs to stay alive.
     */
    "WouldDie": undefined;
    /**
     * The asset-account already exists.
     */
    "AlreadyExists": undefined;
    /**
     * The asset-account doesn't have an associated deposit.
     */
    "NoDeposit": undefined;
    /**
     * The operation would result in funds being burned.
     */
    "WouldBurn": undefined;
    /**
     * The asset is a live asset and is actively being used. Usually emit for operations such
     * as `start_destroy` which require the asset to be in a destroying state.
     */
    "LiveAsset": undefined;
    /**
     * The asset is not live, and likely being destroyed.
     */
    "AssetNotLive": undefined;
    /**
     * The asset status is not the expected status.
     */
    "IncorrectStatus": undefined;
    /**
     * The asset should be frozen before the given operation.
     */
    "NotFrozen": undefined;
    /**
     * Callback action resulted in error
     */
    "CallbackFailed": undefined;
    /**
     * The asset ID must be equal to the [`NextAssetId`].
     */
    "BadAssetId": undefined;
}>;
export type I92qmgektithad = AnonymousEnum<{
    "ErrorCreatingAsset": undefined;
    "AssetAlreadyExists": undefined;
    "AssetDoesNotExist": undefined;
    "TooLowNumAssetsWeightHint": undefined;
    "LocalAssetLimitReached": undefined;
    "ErrorDestroyingAsset": undefined;
    "NotSufficientDeposit": undefined;
    "NonExistentLocalAsset": undefined;
}>;
export type I9pec2tat0b1sl = AnonymousEnum<{
    "IndexAlreadyClaimed": undefined;
    "UnclaimedIndex": undefined;
    "NotOwner": undefined;
    "UnweighableMessage": undefined;
    "CannotReanchor": undefined;
    "AssetHasNoReserve": undefined;
    "InvalidDest": undefined;
    "NotCrossChainTransfer": undefined;
    "AssetIsNotReserveInDestination": undefined;
    "DestinationNotInvertible": undefined;
    "ErrorDelivering": undefined;
    "DispatchWeightBiggerThanTotalWeight": undefined;
    "WeightOverflow": undefined;
    "AmountOverflow": undefined;
    "TransactorInfoNotSet": undefined;
    "NotCrossChainTransferableCurrency": undefined;
    "XcmExecuteError": undefined;
    "BadVersion": undefined;
    "MaxWeightTransactReached": undefined;
    "UnableToWithdrawAsset": undefined;
    "FeePerSecondNotSet": undefined;
    "SignedTransactNotAllowedForDestination": undefined;
    "FailedMultiLocationToJunction": undefined;
    "HrmpHandlerNotImplemented": undefined;
    "TooMuchFeeUsed": undefined;
    "ErrorValidating": undefined;
    "RefundNotSupportedWithTransactInfo": undefined;
}>;
export type I56l2vckpgl5af = AnonymousEnum<{
    /**
     * Xcm to Ethereum execution is suspended
     */
    "EthereumXcmExecutionSuspended": undefined;
}>;
export type I9anko43uhagj7 = AnonymousEnum<{
    "AssetAlreadyExists": undefined;
    "AssetAlreadyFrozen": undefined;
    "AssetDoesNotExist": undefined;
    "AssetIdFiltered": undefined;
    "AssetNotFrozen": undefined;
    "CorruptedStorageOrphanLocation": undefined;
    "Erc20ContractCreationFail": undefined;
    "EvmCallPauseFail": undefined;
    "EvmCallUnpauseFail": undefined;
    "EvmCallMintIntoFail": undefined;
    "EvmCallTransferFail": undefined;
    "EvmInternalError": undefined;
    /**
     * Account has insufficient balance for locking
     */
    "InsufficientBalance": undefined;
    "CannotConvertLocationToAccount": undefined;
    "LocationOutsideOfOrigin": undefined;
    "AssetNotInSiblingPara": undefined;
    "InvalidSymbol": undefined;
    "InvalidTokenName": undefined;
    "LocationAlreadyExists": undefined;
    "TooManyForeignAssets": undefined;
}>;
export type If3q1473tk8erv = AnonymousEnum<{
    /**
     * The given asset was already added
     */
    "AssetAlreadyAdded": undefined;
    /**
     * The given asset was already paused
     */
    "AssetAlreadyPaused": undefined;
    /**
     * The given asset was not found
     */
    "AssetNotFound": undefined;
    /**
     * The given asset is not paused
     */
    "AssetNotPaused": undefined;
    /**
     * XCM location filtered
     */
    "XcmLocationFiltered": undefined;
    /**
     * The relative price cannot be zero
     */
    "PriceCannotBeZero": undefined;
    /**
     * The relative price calculation overflowed
     */
    "PriceOverflow": undefined;
}>;
export type Icbr66vmtvbshn = AnonymousEnum<{
    /**
     * The current XCM Mode is not Paused
     */
    "NotInPausedMode": undefined;
}>;
export type Iaaqq5jevtahm8 = AnonymousEnum<{
    /**
     * The operation cannot complete since some MBMs are ongoing.
     */
    "Ongoing": undefined;
}>;
export type Iddk0c4t42r294 = AnonymousEnum<{
    "BenchmarkError": undefined;
}>;
export type I20bvui08h13pf = AnonymousEnum<{
    "RequestCounterOverflowed": undefined;
    "RequestFeeOverflowed": undefined;
    "MustRequestAtLeastOneWord": undefined;
    "CannotRequestMoreWordsThanMax": undefined;
    "CannotRequestRandomnessAfterMaxDelay": undefined;
    "CannotRequestRandomnessBeforeMinDelay": undefined;
    "RequestDNE": undefined;
    "RequestCannotYetBeFulfilled": undefined;
    "OnlyRequesterCanIncreaseFee": undefined;
    "RequestHasNotExpired": undefined;
    "RandomnessResultDNE": undefined;
    "RandomnessResultNotFilled": undefined;
}>;
export type I8dk2jmk95gk46 = AnonymousEnum<{
    /**
     * The given justification is invalid for the given header.
     */
    "InvalidJustification": undefined;
    /**
     * The authority set from the underlying header chain is invalid.
     */
    "InvalidAuthoritySet": undefined;
    /**
     * The header being imported is older than the best finalized header known to the pallet.
     */
    "OldHeader": undefined;
    /**
     * The scheduled authority set change found in the header is unsupported by the pallet.
     *
     * This is the case for non-standard (e.g forced) authority set changes.
     */
    "UnsupportedScheduledChange": undefined;
    /**
     * The pallet is not yet initialized.
     */
    "NotInitialized": undefined;
    /**
     * The pallet has already been initialized.
     */
    "AlreadyInitialized": undefined;
    /**
     * Too many authorities in the set.
     */
    "TooManyAuthoritiesInSet": undefined;
    /**
     * Error generated by the `OwnedBridgeModule` trait.
     */
    "BridgeModule": Anonymize<I8ih4atobnlo2v>;
    /**
     * The `current_set_id` argument of the `submit_finality_proof_ex` doesn't match
     * the id of the current set, known to the pallet.
     */
    "InvalidAuthoritySetId": undefined;
    /**
     * The submitter wanted free execution, but we can't fit more free transactions
     * to the block.
     */
    "FreeHeadersLimitExceded": undefined;
    /**
     * The submitter wanted free execution, but the difference between best known and
     * bundled header numbers is below the `FreeHeadersInterval`.
     */
    "BelowFreeHeaderInterval": undefined;
    /**
     * The header (and its finality) submission overflows hardcoded chain limits: size
     * and/or weight are larger than expected.
     */
    "HeaderOverflowLimits": undefined;
}>;
export type I8ih4atobnlo2v = AnonymousEnum<{
    "Halted": undefined;
}>;
export type I74ucapvsteups = AnonymousEnum<{
    /**
     * Relay chain block hash is unknown to us.
     */
    "UnknownRelayChainBlock": undefined;
    /**
     * The number of stored relay block is different from what the relayer has provided.
     */
    "InvalidRelayChainBlockNumber": undefined;
    /**
     * Parachain heads storage proof is invalid.
     */
    "HeaderChainStorageProof": Anonymize<Ic2a7mmhqckbbo>;
    /**
     * Error generated by the `OwnedBridgeModule` trait.
     */
    "BridgeModule": Anonymize<I8ih4atobnlo2v>;
}>;
export type Ic2a7mmhqckbbo = AnonymousEnum<{
    "UnknownHeader": undefined;
    "StorageProof": Anonymize<Ilk3qa2m9gh0s>;
}>;
export type Ilk3qa2m9gh0s = AnonymousEnum<{
    "UnableToGenerateTrieProof": undefined;
    "InvalidProof": undefined;
    "UnsortedEntries": undefined;
    "UnavailableKey": undefined;
    "EmptyVal": undefined;
    "DecodeError": undefined;
    "UnusedKey": undefined;
    "StorageRootMismatch": undefined;
    "StorageValueUnavailable": undefined;
    "DuplicateNodes": undefined;
}>;
export type Iebf0p0uiquo3o = AnonymousEnum<{
    /**
     * Pallet is not in Normal operating mode.
     */
    "NotOperatingNormally": undefined;
    /**
     * Error that is reported by the lanes manager.
     */
    "LanesManager": Anonymize<I8ac87iu4gllf7>;
    /**
     * Message has been treated as invalid by the pallet logic.
     */
    "MessageRejectedByPallet": Anonymize<I9l4i4j74aic6u>;
    /**
     * The transaction brings too many messages.
     */
    "TooManyMessagesInTheProof": undefined;
    /**
     * Invalid messages has been submitted.
     */
    "InvalidMessagesProof": undefined;
    /**
     * Invalid messages delivery proof has been submitted.
     */
    "InvalidMessagesDeliveryProof": undefined;
    /**
     * The relayer has declared invalid unrewarded relayers state in the
     * `receive_messages_delivery_proof` call.
     */
    "InvalidUnrewardedRelayersState": undefined;
    /**
     * The cumulative dispatch weight, passed by relayer is not enough to cover dispatch
     * of all bundled messages.
     */
    "InsufficientDispatchWeight": undefined;
    /**
     * Error confirming messages receival.
     */
    "ReceptionConfirmation": Anonymize<I6usvuval5ataj>;
    /**
     * Error generated by the `OwnedBridgeModule` trait.
     */
    "BridgeModule": Anonymize<I8ih4atobnlo2v>;
}>;
export type I8ac87iu4gllf7 = AnonymousEnum<{
    "InboundLaneAlreadyExists": undefined;
    "OutboundLaneAlreadyExists": undefined;
    "UnknownInboundLane": undefined;
    "UnknownOutboundLane": undefined;
    "ClosedInboundLane": undefined;
    "ClosedOutboundLane": undefined;
    "LaneDispatcherInactive": undefined;
}>;
export type I9l4i4j74aic6u = AnonymousEnum<{
    "EmptyMessageProof": undefined;
    "HeaderChain": Anonymize<Ic2a7mmhqckbbo>;
    "InboundLaneStorage": Anonymize<Ilk3qa2m9gh0s>;
    "InvalidMessageWeight": undefined;
    "MessagesCountMismatch": undefined;
    "MessageStorage": Anonymize<Ilk3qa2m9gh0s>;
    "MessageTooLarge": undefined;
    "OutboundLaneStorage": Anonymize<Ilk3qa2m9gh0s>;
    "StorageProof": Anonymize<Ilk3qa2m9gh0s>;
    "Other": undefined;
}>;
export type I6usvuval5ataj = AnonymousEnum<{
    "FailedToConfirmFutureMessages": undefined;
    "EmptyUnrewardedRelayerEntry": undefined;
    "NonConsecutiveUnrewardedRelayerEntries": undefined;
    "TryingToConfirmMoreMessagesThanExpected": undefined;
}>;
export type I33kod71r5qeg9 = AnonymousEnum<{
    /**
     * Bridge locations error.
     */
    "BridgeLocations": Anonymize<Idcd89crotr3go>;
    /**
     * Invalid local bridge origin account.
     */
    "InvalidBridgeOriginAccount": undefined;
    /**
     * The bridge is already registered in this pallet.
     */
    "BridgeAlreadyExists": undefined;
    /**
     * The local origin already owns a maximal number of bridges.
     */
    "TooManyBridgesForLocalOrigin": undefined;
    /**
     * Trying to close already closed bridge.
     */
    "BridgeAlreadyClosed": undefined;
    /**
     * Lanes manager error.
     */
    "LanesManager": Anonymize<I8ac87iu4gllf7>;
    /**
     * Trying to access unknown bridge.
     */
    "UnknownBridge": undefined;
    /**
     * The bridge origin can't pay the required amount for opening the bridge.
     */
    "FailedToReserveBridgeDeposit": undefined;
    /**
     * The version of XCM location argument is unsupported.
     */
    "UnsupportedXcmVersion": undefined;
}>;
export type Idcd89crotr3go = AnonymousEnum<{
    "NonUniversalLocation": undefined;
    "InvalidBridgeOrigin": undefined;
    "InvalidBridgeDestination": undefined;
    "DestinationIsLocal": undefined;
    "UnreachableDestination": undefined;
    "UnsupportedDestinationLocation": undefined;
    "UnsupportedXcmVersion": undefined;
    "UnsupportedLaneIdType": undefined;
}>;
export type I64i34r0tn439a = {
    "account": HexString;
};
export type Ift7k6k1vpbi63 = {
    "sender": HexString;
    "hash": FixedSizeBinary<32>;
};
export type Icbsekf57miplo = AnonymousEnum<{
    /**
     * The validation function has been scheduled to apply.
     */
    "ValidationFunctionStored": undefined;
    /**
     * The validation function was applied as of the contained relay chain block number.
     */
    "ValidationFunctionApplied": Anonymize<Idd7hd99u0ho0n>;
    /**
     * The relay-chain aborted the upgrade process.
     */
    "ValidationFunctionDiscarded": undefined;
    /**
     * Some downward messages have been received and will be processed.
     */
    "DownwardMessagesReceived": Anonymize<Iafscmv8tjf0ou>;
    /**
     * Downward messages were processed using the given weight.
     */
    "DownwardMessagesProcessed": Anonymize<I100l07kaehdlp>;
    /**
     * An upward message was sent to the relay chain.
     */
    "UpwardMessageSent": Anonymize<I6gnbnvip5vvdi>;
}>;
export type Idd7hd99u0ho0n = {
    "relay_chain_block_num": number;
};
export type I100l07kaehdlp = {
    "weight_used": Anonymize<I4q39t5hn830vp>;
    "dmq_head": FixedSizeBinary<32>;
};
export type I6gnbnvip5vvdi = {
    "message_hash"?: Anonymize<I4s6vifaf8k998>;
};
export type RootTestingEvent = Enum<{
    /**
     * Event dispatched when the trigger_defensive extrinsic is called.
     */
    "DefensiveTestCall": undefined;
}>;
export declare const RootTestingEvent: GetEnum<RootTestingEvent>;
export type Ia7dcv14t183mr = AnonymousEnum<{
    /**
     * An account was created with some free balance.
     */
    "Endowed": Anonymize<I3ecpih42i9ued>;
    /**
     * An account was removed whose balance was non-zero but below ExistentialDeposit,
     * resulting in an outright loss.
     */
    "DustLost": Anonymize<Idagmf1s3t818e>;
    /**
     * Transfer succeeded.
     */
    "Transfer": Anonymize<Iata20h6b309vv>;
    /**
     * A balance was set by root.
     */
    "BalanceSet": Anonymize<I2933v5hnardc0>;
    /**
     * Some balance was reserved (moved from free to reserved).
     */
    "Reserved": Anonymize<Ibnba9cres7tu>;
    /**
     * Some balance was unreserved (moved from reserved to free).
     */
    "Unreserved": Anonymize<Ibnba9cres7tu>;
    /**
     * Some balance was moved from the reserve of the first account to the second account.
     * Final argument indicates the destination balance type.
     */
    "ReserveRepatriated": Anonymize<Ibvv65jm0gurrm>;
    /**
     * Some amount was deposited (e.g. for transaction fees).
     */
    "Deposit": Anonymize<Ibnba9cres7tu>;
    /**
     * Some amount was withdrawn from the account (e.g. for transaction fees).
     */
    "Withdraw": Anonymize<Ibnba9cres7tu>;
    /**
     * Some amount was removed from the account (e.g. for misbehavior).
     */
    "Slashed": Anonymize<Ibnba9cres7tu>;
    /**
     * Some amount was minted into an account.
     */
    "Minted": Anonymize<Ibnba9cres7tu>;
    /**
     * Some amount was burned from an account.
     */
    "Burned": Anonymize<Ibnba9cres7tu>;
    /**
     * Some amount was suspended from an account (it can be restored later).
     */
    "Suspended": Anonymize<Ibnba9cres7tu>;
    /**
     * Some amount was restored into an account.
     */
    "Restored": Anonymize<Ibnba9cres7tu>;
    /**
     * An account was upgraded.
     */
    "Upgraded": Anonymize<I4rsmslqkgb8qr>;
    /**
     * Total issuance was increased by `amount`, creating a credit to be balanced.
     */
    "Issued": Anonymize<I3qt1hgg4djhgb>;
    /**
     * Total issuance was decreased by `amount`, creating a debt to be balanced.
     */
    "Rescinded": Anonymize<I3qt1hgg4djhgb>;
    /**
     * Some balance was locked.
     */
    "Locked": Anonymize<Ibnba9cres7tu>;
    /**
     * Some balance was unlocked.
     */
    "Unlocked": Anonymize<Ibnba9cres7tu>;
    /**
     * Some balance was frozen.
     */
    "Frozen": Anonymize<Ibnba9cres7tu>;
    /**
     * Some balance was thawed.
     */
    "Thawed": Anonymize<Ibnba9cres7tu>;
    /**
     * The `TotalIssuance` was forcefully changed.
     */
    "TotalIssuanceForced": Anonymize<I4fooe9dun9o0t>;
}>;
export type I3ecpih42i9ued = {
    "account": HexString;
    "free_balance": bigint;
};
export type Idagmf1s3t818e = {
    "account": HexString;
    "amount": bigint;
};
export type Iata20h6b309vv = {
    "from": HexString;
    "to": HexString;
    "amount": bigint;
};
export type I2933v5hnardc0 = {
    "who": HexString;
    "free": bigint;
};
export type Ibnba9cres7tu = {
    "who": HexString;
    "amount": bigint;
};
export type Ibvv65jm0gurrm = {
    "from": HexString;
    "to": HexString;
    "amount": bigint;
    "destination_status": BalanceStatus;
};
export type I4rsmslqkgb8qr = {
    "who": HexString;
};
export type Ie5dbofecudee7 = AnonymousEnum<{
    /**
     * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
     * has been paid by `who`.
     */
    "TransactionFeePaid": Anonymize<I97pnebnn4tkhc>;
}>;
export type I97pnebnn4tkhc = {
    "who": HexString;
    "actual_fee": bigint;
    "tip": bigint;
};
export type I9577i6u47v6lh = AnonymousEnum<{
    /**
     * Started new round.
     */
    "NewRound": Anonymize<I68vefv6bi40pm>;
    /**
     * Account joined the set of collator candidates.
     */
    "JoinedCollatorCandidates": Anonymize<Iftkfae30kugcq>;
    /**
     * Candidate selected for collators. Total Exposed Amount includes all delegations.
     */
    "CollatorChosen": Anonymize<I17ukutvof0ve2>;
    /**
     * Candidate requested to decrease a self bond.
     */
    "CandidateBondLessRequested": Anonymize<Ibvvl72jn681iq>;
    /**
     * Candidate has increased a self bond.
     */
    "CandidateBondedMore": Anonymize<Ie613ancv0jknl>;
    /**
     * Candidate has decreased a self bond.
     */
    "CandidateBondedLess": Anonymize<I5sm0lt4vndrm9>;
    /**
     * Candidate temporarily leave the set of collator candidates without unbonding.
     */
    "CandidateWentOffline": Anonymize<Ifcg60143soedq>;
    /**
     * Candidate rejoins the set of collator candidates.
     */
    "CandidateBackOnline": Anonymize<Ifcg60143soedq>;
    /**
     * Candidate has requested to leave the set of candidates.
     */
    "CandidateScheduledExit": Anonymize<I3llnd78pv2h9v>;
    /**
     * Cancelled request to leave the set of candidates.
     */
    "CancelledCandidateExit": Anonymize<Ifcg60143soedq>;
    /**
     * Cancelled request to decrease candidate's bond.
     */
    "CancelledCandidateBondLess": Anonymize<Idl5sk5t49u4vk>;
    /**
     * Candidate has left the set of candidates.
     */
    "CandidateLeft": Anonymize<I3c0ak1g99r7mq>;
    /**
     * Delegator requested to decrease a bond for the collator candidate.
     */
    "DelegationDecreaseScheduled": Anonymize<Ifc77bq577konn>;
    "DelegationIncreased": Anonymize<Idh9lqfad8a2aq>;
    "DelegationDecreased": Anonymize<Idh9lqfad8a2aq>;
    /**
     * Delegator requested to leave the set of delegators.
     */
    "DelegatorExitScheduled": Anonymize<I1p078p7cgor9k>;
    /**
     * Delegator requested to revoke delegation.
     */
    "DelegationRevocationScheduled": Anonymize<Ifsfg9vjdv536v>;
    /**
     * Delegator has left the set of delegators.
     */
    "DelegatorLeft": Anonymize<I4hf4jr1nooq2i>;
    /**
     * Delegation revoked.
     */
    "DelegationRevoked": Anonymize<I8q8go5ssttd5d>;
    /**
     * Delegation kicked.
     */
    "DelegationKicked": Anonymize<I8q8go5ssttd5d>;
    /**
     * Cancelled a pending request to exit the set of delegators.
     */
    "DelegatorExitCancelled": Anonymize<I6a9r4se514q6d>;
    /**
     * Cancelled request to change an existing delegation.
     */
    "CancelledDelegationRequest": Anonymize<Ibjcii86jf2m74>;
    /**
     * New delegation (increase of the existing one).
     */
    "Delegation": Anonymize<I4jpr41fkr2iv2>;
    /**
     * Delegation from candidate state has been remove.
     */
    "DelegatorLeftCandidate": Anonymize<I4ktb62ucg8r8v>;
    /**
     * Paid the account (delegator or collator) the balance as liquid rewards.
     */
    "Rewarded": Anonymize<I2l9i7suo53kao>;
    /**
     * Transferred to account which holds funds reserved for parachain bond.
     */
    "InflationDistributed": Anonymize<I2mcpbv0ik4rbq>;
    "InflationDistributionConfigUpdated": Anonymize<Icrvh9hsc9dfs0>;
    /**
     * Annual inflation input (first 3) was used to derive new per-round inflation (last 3)
     */
    "InflationSet": Anonymize<I8jjc8aeseo568>;
    /**
     * Staking expectations set.
     */
    "StakeExpectationsSet": Anonymize<Ia48s8or178ack>;
    /**
     * Set total selected candidates to this value.
     */
    "TotalSelectedSet": Anonymize<I6fomjr8ghrs40>;
    /**
     * Set collator commission to this value.
     */
    "CollatorCommissionSet": Anonymize<I6fomjr8ghrs40>;
    /**
     * Set blocks per round
     */
    "BlocksPerRoundSet": Anonymize<I25jemnddpsl99>;
    /**
     * Auto-compounding reward percent was set for a delegation.
     */
    "AutoCompoundSet": Anonymize<I39l6hn1m2g7p1>;
    /**
     * Compounded a portion of rewards towards the delegation.
     */
    "Compounded": Anonymize<I91f3georfm7vn>;
}>;
export type I68vefv6bi40pm = {
    "starting_block": number;
    "round": number;
    "selected_collators_number": number;
    "total_balance": bigint;
};
export type Iftkfae30kugcq = {
    "account": HexString;
    "amount_locked": bigint;
    "new_total_amt_locked": bigint;
};
export type I17ukutvof0ve2 = {
    "round": number;
    "collator_account": HexString;
    "total_exposed_amount": bigint;
};
export type Ibvvl72jn681iq = {
    "candidate": HexString;
    "amount_to_decrease": bigint;
    "execute_round": number;
};
export type Ie613ancv0jknl = {
    "candidate": HexString;
    "amount": bigint;
    "new_total_bond": bigint;
};
export type I5sm0lt4vndrm9 = {
    "candidate": HexString;
    "amount": bigint;
    "new_bond": bigint;
};
export type Ifcg60143soedq = {
    "candidate": HexString;
};
export type I3llnd78pv2h9v = {
    "exit_allowed_round": number;
    "candidate": HexString;
    "scheduled_exit": number;
};
export type Idl5sk5t49u4vk = {
    "candidate": HexString;
    "amount": bigint;
    "execute_round": number;
};
export type I3c0ak1g99r7mq = {
    "ex_candidate": HexString;
    "unlocked_amount": bigint;
    "new_total_amt_locked": bigint;
};
export type Ifc77bq577konn = {
    "delegator": HexString;
    "candidate": HexString;
    "amount_to_decrease": bigint;
    "execute_round": number;
};
export type Idh9lqfad8a2aq = {
    "delegator": HexString;
    "candidate": HexString;
    "amount": bigint;
    "in_top": boolean;
};
export type I1p078p7cgor9k = {
    "round": number;
    "delegator": HexString;
    "scheduled_exit": number;
};
export type Ifsfg9vjdv536v = {
    "round": number;
    "delegator": HexString;
    "candidate": HexString;
    "scheduled_exit": number;
};
export type I4hf4jr1nooq2i = {
    "delegator": HexString;
    "unstaked_amount": bigint;
};
export type I8q8go5ssttd5d = {
    "delegator": HexString;
    "candidate": HexString;
    "unstaked_amount": bigint;
};
export type I6a9r4se514q6d = {
    "delegator": HexString;
};
export type Ibjcii86jf2m74 = {
    "delegator": HexString;
    "cancelled_request": Anonymize<I99jrare3vnf02>;
    "collator": HexString;
};
export type I99jrare3vnf02 = {
    "when_executable": number;
    "action": Anonymize<Ibtq25m1pbdmfs>;
};
export type Ibtq25m1pbdmfs = AnonymousEnum<{
    "Revoke": bigint;
    "Decrease": bigint;
}>;
export type I4jpr41fkr2iv2 = {
    "delegator": HexString;
    "locked_amount": bigint;
    "candidate": HexString;
    "delegator_position": Anonymize<Ibml0ipjqum8cv>;
    "auto_compound": number;
};
export type Ibml0ipjqum8cv = AnonymousEnum<{
    "AddedToTop": {
        "new_total": bigint;
    };
    "AddedToBottom": undefined;
}>;
export type I4ktb62ucg8r8v = {
    "delegator": HexString;
    "candidate": HexString;
    "unstaked_amount": bigint;
    "total_candidate_staked": bigint;
};
export type I2l9i7suo53kao = {
    "account": HexString;
    "rewards": bigint;
};
export type I2mcpbv0ik4rbq = {
    "index": number;
    "account": HexString;
    "value": bigint;
};
export type Icrvh9hsc9dfs0 = {
    "old": Anonymize<I35tvldomfrgo6>;
    "new": Anonymize<I35tvldomfrgo6>;
};
export type I35tvldomfrgo6 = FixedSizeArray<2, {
    "account": HexString;
    "percent": number;
}>;
export type I8jjc8aeseo568 = {
    "annual_min": number;
    "annual_ideal": number;
    "annual_max": number;
    "round_min": number;
    "round_ideal": number;
    "round_max": number;
};
export type Ia48s8or178ack = {
    "expect_min": bigint;
    "expect_ideal": bigint;
    "expect_max": bigint;
};
export type I6fomjr8ghrs40 = {
    "old": number;
    "new": number;
};
export type I25jemnddpsl99 = {
    "current_round": number;
    "first_block": number;
    "old": number;
    "new": number;
    "new_per_round_inflation_min": number;
    "new_per_round_inflation_ideal": number;
    "new_per_round_inflation_max": number;
};
export type I39l6hn1m2g7p1 = {
    "candidate": HexString;
    "delegator": HexString;
    "value": number;
};
export type I91f3georfm7vn = {
    "candidate": HexString;
    "delegator": HexString;
    "amount": bigint;
};
export type I5bnfp30l6pckt = AnonymousEnum<{
    /**
     * The amount of eligible authors for the filter to select has been changed.
     */
    "EligibleUpdated": number;
}>;
export type Ia10guihti0p5o = AnonymousEnum<{
    /**
     * A NimbusId has been registered and mapped to an AccountId.
     */
    "KeysRegistered": Anonymize<I1d9e1b2lo88g3>;
    /**
     * An NimbusId has been de-registered, and its AccountId mapping removed.
     */
    "KeysRemoved": Anonymize<I1d9e1b2lo88g3>;
    /**
     * An NimbusId has been registered, replacing a previous registration and its mapping.
     */
    "KeysRotated": Anonymize<Idhmv574kgr1en>;
}>;
export type I1d9e1b2lo88g3 = {
    "nimbus_id": FixedSizeBinary<32>;
    "account_id": HexString;
    "keys": FixedSizeBinary<32>;
};
export type Idhmv574kgr1en = {
    "new_nimbus_id": FixedSizeBinary<32>;
    "account_id": HexString;
    "new_keys": FixedSizeBinary<32>;
};
export type I5aqrfqq5edsc4 = AnonymousEnum<{
    /**
     * An orbiter join a collator pool
     */
    "OrbiterJoinCollatorPool": Anonymize<Iamgbscgq9tk2s>;
    /**
     * An orbiter leave a collator pool
     */
    "OrbiterLeaveCollatorPool": Anonymize<Iamgbscgq9tk2s>;
    /**
     * Paid the orbiter account the balance as liquid rewards.
     */
    "OrbiterRewarded": Anonymize<I2l9i7suo53kao>;
    "OrbiterRotation": Anonymize<Irqmq32c6bt43>;
    /**
     * An orbiter has registered
     */
    "OrbiterRegistered": Anonymize<I5aaf7rm6pdsdh>;
    /**
     * An orbiter has unregistered
     */
    "OrbiterUnregistered": Anonymize<I64i34r0tn439a>;
}>;
export type Iamgbscgq9tk2s = {
    "collator": HexString;
    "orbiter": HexString;
};
export type Irqmq32c6bt43 = {
    "collator": HexString;
    "old_orbiter"?: Anonymize<I36nb9b8a306lm>;
    "new_orbiter"?: Anonymize<I36nb9b8a306lm>;
};
export type I36nb9b8a306lm = (HexString) | undefined;
export type I5aaf7rm6pdsdh = {
    "account": HexString;
    "deposit": bigint;
};
export type Idon02n0b5ot2q = AnonymousEnum<{
    /**
     * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
     * well as the error.
     */
    "BatchInterrupted": Anonymize<Iclnv1rm3j1ibs>;
    /**
     * Batch of dispatches completed fully with no error.
     */
    "BatchCompleted": undefined;
    /**
     * Batch of dispatches completed but has errors.
     */
    "BatchCompletedWithErrors": undefined;
    /**
     * A single item within a Batch of dispatches has completed with no error.
     */
    "ItemCompleted": undefined;
    /**
     * A single item within a Batch of dispatches has completed with error.
     */
    "ItemFailed": Anonymize<I8u7aielas35pf>;
    /**
     * A call was dispatched.
     */
    "DispatchedAs": Anonymize<Ifs4v0043l9sa5>;
}>;
export type Iclnv1rm3j1ibs = {
    "index": number;
    "error": Anonymize<I68l22felg5oio>;
};
export type I8u7aielas35pf = {
    "error": Anonymize<I68l22felg5oio>;
};
export type Ifs4v0043l9sa5 = {
    "result": Anonymize<Id16ku1poe7q51>;
};
export type Id16ku1poe7q51 = ResultPayload<undefined, Anonymize<I68l22felg5oio>>;
export type I4siqj0d555e55 = AnonymousEnum<{
    /**
     * A proxy was executed correctly, with the given.
     */
    "ProxyExecuted": Anonymize<Ifs4v0043l9sa5>;
    /**
     * A pure account has been created by new proxy with given
     * disambiguation index and proxy type.
     */
    "PureCreated": Anonymize<Ic41o5tfkjki24>;
    /**
     * An announcement was placed to make a call in the future.
     */
    "Announced": Anonymize<I9qviu560vg4dt>;
    /**
     * A proxy was added.
     */
    "ProxyAdded": Anonymize<Ifuev5pidklrr3>;
    /**
     * A proxy was removed.
     */
    "ProxyRemoved": Anonymize<Ifuev5pidklrr3>;
}>;
export type Ic41o5tfkjki24 = {
    "pure": HexString;
    "who": HexString;
    "proxy_type": Anonymize<Ifmiop0mj0oacq>;
    "disambiguation_index": number;
};
export type Ifmiop0mj0oacq = AnonymousEnum<{
    "Any": undefined;
    "NonTransfer": undefined;
    "Governance": undefined;
    "Staking": undefined;
    "CancelProxy": undefined;
    "Balances": undefined;
    "AuthorMapping": undefined;
    "IdentityJudgement": undefined;
}>;
export type I9qviu560vg4dt = {
    "real": HexString;
    "proxy": HexString;
    "call_hash": FixedSizeBinary<32>;
};
export type Ifuev5pidklrr3 = {
    "delegator": HexString;
    "delegatee": HexString;
    "proxy_type": Anonymize<Ifmiop0mj0oacq>;
    "delay": number;
};
export type Iasp0s95mcru2e = AnonymousEnum<{
    /**
     * The chain was put into Maintenance Mode
     */
    "EnteredMaintenanceMode": undefined;
    /**
     * The chain returned to its normal operating state
     */
    "NormalOperationResumed": undefined;
    /**
     * The call to suspend on_idle XCM execution failed with inner error
     */
    "FailedToSuspendIdleXcmExecution": Anonymize<I8u7aielas35pf>;
    /**
     * The call to resume on_idle XCM execution failed with inner error
     */
    "FailedToResumeIdleXcmExecution": Anonymize<I8u7aielas35pf>;
}>;
export type Ie06p890f230de = AnonymousEnum<{
    /**
     * A name was set or reset (which will remove all judgements).
     */
    "IdentitySet": Anonymize<I4rsmslqkgb8qr>;
    /**
     * A name was cleared, and the given balance returned.
     */
    "IdentityCleared": Anonymize<I1v10g1nq7dong>;
    /**
     * A name was removed and the given balance slashed.
     */
    "IdentityKilled": Anonymize<I1v10g1nq7dong>;
    /**
     * A judgement was asked from a registrar.
     */
    "JudgementRequested": Anonymize<I9i38hjanm6j9f>;
    /**
     * A judgement request was retracted.
     */
    "JudgementUnrequested": Anonymize<I9i38hjanm6j9f>;
    /**
     * A judgement was given by a registrar.
     */
    "JudgementGiven": Anonymize<Ic2pdjj0snhgp1>;
    /**
     * A registrar was added.
     */
    "RegistrarAdded": Anonymize<Itvt1jsipv0lc>;
    /**
     * A sub-identity was added to an identity and the deposit paid.
     */
    "SubIdentityAdded": Anonymize<I26b3hgj509l2q>;
    /**
     * An account's sub-identities were set (in bulk).
     */
    "SubIdentitiesSet": Anonymize<Iabvuost5sn5bf>;
    /**
     * A given sub-account's associated name was changed by its super-identity.
     */
    "SubIdentityRenamed": Anonymize<If6gpndc4hkjk>;
    /**
     * A sub-identity was removed from an identity and the deposit freed.
     */
    "SubIdentityRemoved": Anonymize<I26b3hgj509l2q>;
    /**
     * A sub-identity was cleared, and the given deposit repatriated from the
     * main identity account to the sub-identity account.
     */
    "SubIdentityRevoked": Anonymize<I26b3hgj509l2q>;
    /**
     * A username authority was added.
     */
    "AuthorityAdded": Anonymize<I980npvt4ko2oj>;
    /**
     * A username authority was removed.
     */
    "AuthorityRemoved": Anonymize<I980npvt4ko2oj>;
    /**
     * A username was set for `who`.
     */
    "UsernameSet": Anonymize<Icojbcdrmo8g9n>;
    /**
     * A username was queued, but `who` must accept it prior to `expiration`.
     */
    "UsernameQueued": Anonymize<I4tp79beg36bon>;
    /**
     * A queued username passed its expiration without being claimed and was removed.
     */
    "PreapprovalExpired": Anonymize<I46oelk9rchag6>;
    /**
     * A username was set as a primary and can be looked up from `who`.
     */
    "PrimaryUsernameSet": Anonymize<Icojbcdrmo8g9n>;
    /**
     * A dangling username (as in, a username corresponding to an account that has removed its
     * identity) has been removed.
     */
    "DanglingUsernameRemoved": Anonymize<Icojbcdrmo8g9n>;
    /**
     * A username has been unbound.
     */
    "UsernameUnbound": Anonymize<Ie5l999tf7t2te>;
    /**
     * A username has been removed.
     */
    "UsernameRemoved": Anonymize<Ie5l999tf7t2te>;
    /**
     * A username has been killed.
     */
    "UsernameKilled": Anonymize<Ie5l999tf7t2te>;
}>;
export type I1v10g1nq7dong = {
    "who": HexString;
    "deposit": bigint;
};
export type I9i38hjanm6j9f = {
    "who": HexString;
    "registrar_index": number;
};
export type Ic2pdjj0snhgp1 = {
    "target": HexString;
    "registrar_index": number;
};
export type Itvt1jsipv0lc = {
    "registrar_index": number;
};
export type I26b3hgj509l2q = {
    "sub": HexString;
    "main": HexString;
    "deposit": bigint;
};
export type Iabvuost5sn5bf = {
    "main": HexString;
    "number_of_subs": number;
    "new_deposit": bigint;
};
export type If6gpndc4hkjk = {
    "sub": HexString;
    "main": HexString;
};
export type I980npvt4ko2oj = {
    "authority": HexString;
};
export type Icojbcdrmo8g9n = {
    "who": HexString;
    "username": Binary;
};
export type I4tp79beg36bon = {
    "who": HexString;
    "username": Binary;
    "expiration": number;
};
export type I46oelk9rchag6 = {
    "whose": HexString;
};
export type Ie5l999tf7t2te = {
    "username": Binary;
};
export type If9t4he614soun = AnonymousEnum<{
    /**
     * Runtime upgrade started
     */
    "RuntimeUpgradeStarted": undefined;
    /**
     * Runtime upgrade completed
     */
    "RuntimeUpgradeCompleted": Anonymize<Iffoqstodvgb9c>;
    /**
     * Migration started
     */
    "MigrationStarted": Anonymize<Iavnfpaburegqq>;
    /**
     * Migration completed
     */
    "MigrationCompleted": Anonymize<If198fd3vrqn7u>;
    /**
     * XCM execution suspension failed with inner error
     */
    "FailedToSuspendIdleXcmExecution": Anonymize<I8u7aielas35pf>;
    /**
     * XCM execution resume failed with inner error
     */
    "FailedToResumeIdleXcmExecution": Anonymize<I8u7aielas35pf>;
}>;
export type Iffoqstodvgb9c = {
    "weight": Anonymize<I4q39t5hn830vp>;
};
export type Iavnfpaburegqq = {
    "migration_name": Binary;
};
export type If198fd3vrqn7u = {
    "migration_name": Binary;
    "consumed_weight": Anonymize<I4q39t5hn830vp>;
};
export type I792aphuk2reca = AnonymousEnum<{
    /**
     * A new multisig operation has begun.
     */
    "NewMultisig": Anonymize<Ib1i3vscnt2kp4>;
    /**
     * A multisig operation has been approved by someone.
     */
    "MultisigApproval": Anonymize<Ia55fgto645bva>;
    /**
     * A multisig operation has been executed.
     */
    "MultisigExecuted": Anonymize<I35njf1jhf1ie8>;
    /**
     * A multisig operation has been cancelled.
     */
    "MultisigCancelled": Anonymize<I8isor8208eull>;
}>;
export type Ib1i3vscnt2kp4 = {
    "approving": HexString;
    "multisig": HexString;
    "call_hash": FixedSizeBinary<32>;
};
export type Ia55fgto645bva = {
    "approving": HexString;
    "timepoint": Anonymize<Itvprrpb0nm3o>;
    "multisig": HexString;
    "call_hash": FixedSizeBinary<32>;
};
export type I35njf1jhf1ie8 = {
    "approving": HexString;
    "timepoint": Anonymize<Itvprrpb0nm3o>;
    "multisig": HexString;
    "call_hash": FixedSizeBinary<32>;
    "result": Anonymize<Id16ku1poe7q51>;
};
export type I8isor8208eull = {
    "cancelling": HexString;
    "timepoint": Anonymize<Itvprrpb0nm3o>;
    "multisig": HexString;
    "call_hash": FixedSizeBinary<32>;
};
export type Ibm6tc4nsqbfv2 = AnonymousEnum<{
    /**
     * A Parameter was set.
     *
     * Is also emitted when the value was not changed.
     */
    "Updated": Anonymize<I5nnh4168qqjsk>;
}>;
export type I5nnh4168qqjsk = {
    /**
     * The key that was updated.
     */
    "key": Anonymize<I7afhi9d8kt8k>;
    /**
     * The old value before this call.
     */
    "old_value"?: (Anonymize<I78cuhvqqvjqpp>) | undefined;
    /**
     * The new value after this call.
     */
    "new_value"?: (Anonymize<I78cuhvqqvjqpp>) | undefined;
};
export type I7afhi9d8kt8k = AnonymousEnum<{
    "RuntimeConfig": Enum<{
        "FeesTreasuryProportion": undefined;
    }>;
    "PalletRandomness": Enum<{
        "Deposit": undefined;
    }>;
    "XcmConfig": Enum<{
        "ForeignAssetCreationDeposit": undefined;
    }>;
}>;
export type I78cuhvqqvjqpp = AnonymousEnum<{
    "RuntimeConfig": Enum<{
        "FeesTreasuryProportion": number;
    }>;
    "PalletRandomness": Enum<{
        "Deposit": bigint;
    }>;
    "XcmConfig": Enum<{
        "ForeignAssetCreationDeposit": bigint;
    }>;
}>;
export type I9k071kk4cn1u8 = AnonymousEnum<{
    /**
     * Ethereum events from contracts.
     */
    "Log": Anonymize<Ifmc9boeeia623>;
    /**
     * A contract has been created at given address.
     */
    "Created": Anonymize<Itmchvgqfl28g>;
    /**
     * A contract was attempted to be created, but the execution failed.
     */
    "CreatedFailed": Anonymize<Itmchvgqfl28g>;
    /**
     * A contract has been executed successfully with states applied.
     */
    "Executed": Anonymize<Itmchvgqfl28g>;
    /**
     * A contract has been executed with errors. States are reverted with only gas fees applied.
     */
    "ExecutedFailed": Anonymize<Itmchvgqfl28g>;
}>;
export type Ifmc9boeeia623 = {
    "log": Anonymize<I10qb03fpuk6em>;
};
export type I10qb03fpuk6em = {
    "address": FixedSizeBinary<20>;
    "topics": Anonymize<Ic5m5lp1oioo8r>;
    "data": Binary;
};
export type Itmchvgqfl28g = {
    "address": FixedSizeBinary<20>;
};
export type I510u4q1qqh897 = AnonymousEnum<{
    /**
     * An ethereum transaction was successfully executed.
     */
    "Executed": Anonymize<Iea4g5ovhnolus>;
}>;
export type Iea4g5ovhnolus = {
    "from": FixedSizeBinary<20>;
    "to": FixedSizeBinary<20>;
    "transaction_hash": FixedSizeBinary<32>;
    "exit_reason": Anonymize<Iag9iovb9j5ijo>;
    "extra_data": Binary;
};
export type Iag9iovb9j5ijo = AnonymousEnum<{
    "Succeed": Enum<{
        "Stopped": undefined;
        "Returned": undefined;
        "Suicided": undefined;
    }>;
    "Error": Anonymize<I5ksr7ru2gk4nh>;
    "Revert": Enum<{
        "Reverted": undefined;
    }>;
    "Fatal": Enum<{
        "NotSupported": undefined;
        "UnhandledInterrupt": undefined;
        "CallErrorAsFatal": Anonymize<I5ksr7ru2gk4nh>;
        "Other": string;
    }>;
}>;
export type I5ksr7ru2gk4nh = AnonymousEnum<{
    "StackUnderflow": undefined;
    "StackOverflow": undefined;
    "InvalidJump": undefined;
    "InvalidRange": undefined;
    "DesignatedInvalid": undefined;
    "CallTooDeep": undefined;
    "CreateCollision": undefined;
    "CreateContractLimit": undefined;
    "InvalidCode": number;
    "OutOfOffset": undefined;
    "OutOfGas": undefined;
    "OutOfFund": undefined;
    "PCUnderflow": undefined;
    "CreateEmpty": undefined;
    "Other": string;
    "MaxNonce": undefined;
}>;
export type Ie0l88bqsjarft = AnonymousEnum<{
    /**
     * Scheduled some task.
     */
    "Scheduled": Anonymize<I5n4sebgkfr760>;
    /**
     * Canceled some task.
     */
    "Canceled": Anonymize<I5n4sebgkfr760>;
    /**
     * Dispatched some task.
     */
    "Dispatched": Anonymize<Ifo07lib6rv8j3>;
    /**
     * Set a retry configuration for some task.
     */
    "RetrySet": Anonymize<Ia3c82eadg79bj>;
    /**
     * Cancel a retry configuration for some task.
     */
    "RetryCancelled": Anonymize<Ienusoeb625ftq>;
    /**
     * The call for the provided hash was not found so the task has been aborted.
     */
    "CallUnavailable": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task was unable to be renewed since the agenda is full at that block.
     */
    "PeriodicFailed": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task was unable to be retried since the agenda is full at that block or there
     * was not enough weight to reschedule it.
     */
    "RetryFailed": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task can never be executed since it is overweight.
     */
    "PermanentlyOverweight": Anonymize<Ienusoeb625ftq>;
}>;
export type Ifo07lib6rv8j3 = {
    "task": Anonymize<I9jd27rnpm8ttv>;
    "id"?: Anonymize<I4s6vifaf8k998>;
    "result": Anonymize<Id16ku1poe7q51>;
};
export type I3n6c4456jluo4 = AnonymousEnum<{
    /**
     * An account has delegated their vote to another account. \[who, target\]
     */
    "Delegated": Anonymize<I5b6sd80djbc64>;
    /**
     * An \[account\] has cancelled a previous delegation operation.
     */
    "Undelegated": HexString;
    /**
     * An account that has voted
     */
    "Voted": Anonymize<Ibhldvmubmjth2>;
    /**
     * A vote that been removed
     */
    "VoteRemoved": Anonymize<Ibhldvmubmjth2>;
}>;
export type I5b6sd80djbc64 = FixedSizeArray<2, HexString>;
export type Ibhldvmubmjth2 = {
    "who": HexString;
    "vote": ConvictionVotingVoteAccountVote;
};
export type I1rmulho2k04le = AnonymousEnum<{
    /**
     * A referendum has been submitted.
     */
    "Submitted": Anonymize<I229ijht536qdu>;
    /**
     * The decision deposit has been placed.
     */
    "DecisionDepositPlaced": Anonymize<Iepmkf5d8a0b7i>;
    /**
     * The decision deposit has been refunded.
     */
    "DecisionDepositRefunded": Anonymize<Iepmkf5d8a0b7i>;
    /**
     * A deposit has been slashed.
     */
    "DepositSlashed": Anonymize<Ibnba9cres7tu>;
    /**
     * A referendum has moved into the deciding phase.
     */
    "DecisionStarted": Anonymize<I9cg2delv92pvq>;
    "ConfirmStarted": Anonymize<I666bl2fqjkejo>;
    "ConfirmAborted": Anonymize<I666bl2fqjkejo>;
    /**
     * A referendum has ended its confirmation phase and is ready for approval.
     */
    "Confirmed": Anonymize<Ilhp45uime5tp>;
    /**
     * A referendum has been approved and its proposal has been scheduled.
     */
    "Approved": Anonymize<I666bl2fqjkejo>;
    /**
     * A proposal has been rejected by referendum.
     */
    "Rejected": Anonymize<Ilhp45uime5tp>;
    /**
     * A referendum has been timed out without being decided.
     */
    "TimedOut": Anonymize<Ilhp45uime5tp>;
    /**
     * A referendum has been cancelled.
     */
    "Cancelled": Anonymize<Ilhp45uime5tp>;
    /**
     * A referendum has been killed.
     */
    "Killed": Anonymize<Ilhp45uime5tp>;
    /**
     * The submission deposit has been refunded.
     */
    "SubmissionDepositRefunded": Anonymize<Iepmkf5d8a0b7i>;
    /**
     * Metadata for a referendum has been set.
     */
    "MetadataSet": Anonymize<I4f1hv034jf1dt>;
    /**
     * Metadata for a referendum has been cleared.
     */
    "MetadataCleared": Anonymize<I4f1hv034jf1dt>;
}>;
export type Iepmkf5d8a0b7i = {
    /**
     * Index of the referendum.
     */
    "index": number;
    /**
     * The account who placed the deposit.
     */
    "who": HexString;
    /**
     * The amount placed by the account.
     */
    "amount": bigint;
};
export type Ifm7fpth9i6ptp = AnonymousEnum<{
    "CallWhitelisted": Anonymize<I1adbcfi5uc62r>;
    "WhitelistedCallRemoved": Anonymize<I1adbcfi5uc62r>;
    "WhitelistedCallDispatched": Anonymize<Icdoijbojtaksl>;
}>;
export type Icdoijbojtaksl = {
    "call_hash": FixedSizeBinary<32>;
    "result": Anonymize<I2kog69vhk3kjk>;
};
export type I2kog69vhk3kjk = ResultPayload<Anonymize<Ia1u1r3n74r13c>, {
    "post_info": Anonymize<Ia1u1r3n74r13c>;
    "error": Anonymize<I68l22felg5oio>;
}>;
export type I5h2o3ndahavg8 = AnonymousEnum<{
    /**
     * A motion (given hash) has been proposed (by given account) with a threshold (given
     * `MemberCount`).
     */
    "Proposed": Anonymize<I7kfspda96roem>;
    /**
     * A motion (given hash) has been voted on by given account, leaving
     * a tally (yes votes and no votes given respectively as `MemberCount`).
     */
    "Voted": Anonymize<I3gfupbmrg231o>;
    /**
     * A motion was approved by the required threshold.
     */
    "Approved": Anonymize<I2ev73t79f46tb>;
    /**
     * A motion was not approved by the required threshold.
     */
    "Disapproved": Anonymize<I2ev73t79f46tb>;
    /**
     * A motion was executed; result will be `Ok` if it returned without error.
     */
    "Executed": Anonymize<Ia08e1l4rehsh9>;
    /**
     * A single member did some action; result will be `Ok` if it returned without error.
     */
    "MemberExecuted": Anonymize<Ia08e1l4rehsh9>;
    /**
     * A proposal was closed because its threshold was reached or after its duration was up.
     */
    "Closed": Anonymize<Iak7fhrgb9jnnq>;
    /**
     * A proposal was killed.
     */
    "Killed": Anonymize<I2ev73t79f46tb>;
    /**
     * Some cost for storing a proposal was burned.
     */
    "ProposalCostBurned": Anonymize<I36i15sa21ipvt>;
    /**
     * Some cost for storing a proposal was released.
     */
    "ProposalCostReleased": Anonymize<I36i15sa21ipvt>;
}>;
export type I7kfspda96roem = {
    "account": HexString;
    "proposal_index": number;
    "proposal_hash": FixedSizeBinary<32>;
    "threshold": number;
};
export type I3gfupbmrg231o = {
    "account": HexString;
    "proposal_hash": FixedSizeBinary<32>;
    "voted": boolean;
    "yes": number;
    "no": number;
};
export type I2ev73t79f46tb = {
    "proposal_hash": FixedSizeBinary<32>;
};
export type Ia08e1l4rehsh9 = {
    "proposal_hash": FixedSizeBinary<32>;
    "result": Anonymize<Id16ku1poe7q51>;
};
export type Iak7fhrgb9jnnq = {
    "proposal_hash": FixedSizeBinary<32>;
    "yes": number;
    "no": number;
};
export type I36i15sa21ipvt = {
    "proposal_hash": FixedSizeBinary<32>;
    "who": HexString;
};
export type Ifu4dro40k0eu1 = AnonymousEnum<{
    /**
     * We have ended a spend period and will now allocate funds.
     */
    "Spending": Anonymize<I8iksqi3eani0a>;
    /**
     * Some funds have been allocated.
     */
    "Awarded": Anonymize<Iktsi3p12r1nf>;
    /**
     * Some of our funds have been burnt.
     */
    "Burnt": Anonymize<I43kq8qudg7pq9>;
    /**
     * Spending has finished; this is the amount that rolls over until next spend.
     */
    "Rollover": Anonymize<I76riseemre533>;
    /**
     * Some funds have been deposited.
     */
    "Deposit": Anonymize<Ie5v6njpckr05b>;
    /**
     * A new spend proposal has been approved.
     */
    "SpendApproved": Anonymize<I56jvc7p0b0306>;
    /**
     * The inactive funds of the pallet have been updated.
     */
    "UpdatedInactive": Anonymize<I4hcillge8de5f>;
    /**
     * A new asset spend proposal has been approved.
     */
    "AssetSpendApproved": Anonymize<I9of9chdpickkl>;
    /**
     * An approved spend was voided.
     */
    "AssetSpendVoided": Anonymize<I666bl2fqjkejo>;
    /**
     * A payment happened.
     */
    "Paid": Anonymize<I666bl2fqjkejo>;
    /**
     * A payment failed and can be retried.
     */
    "PaymentFailed": Anonymize<I666bl2fqjkejo>;
    /**
     * A spend was processed and removed from the storage. It might have been successfully
     * paid or it may have expired.
     */
    "SpendProcessed": Anonymize<I666bl2fqjkejo>;
}>;
export type Iktsi3p12r1nf = {
    "proposal_index": number;
    "award": bigint;
    "account": HexString;
};
export type I56jvc7p0b0306 = {
    "proposal_index": number;
    "amount": bigint;
    "beneficiary": HexString;
};
export type I9of9chdpickkl = {
    "index": number;
    "asset_kind": Anonymize<I8ftdv6d7go8s5>;
    "amount": bigint;
    "beneficiary": HexString;
    "valid_from": number;
    "expire_at": number;
};
export type I8ftdv6d7go8s5 = AnonymousEnum<{
    "Native": undefined;
    "WithId": bigint;
}>;
export type I4k3v1jn280snc = AnonymousEnum<{
    /**
     * The initial payment of InitializationPayment % was paid
     */
    "InitialPaymentMade": Anonymize<Ic2o7gh4sgom1k>;
    /**
     * Someone has proven they made a contribution and associated a native identity with it.
     * Data is the relay account,  native account and the total amount of _rewards_ that will be paid
     */
    "NativeIdentityAssociated": Anonymize<I4moiumda17j4k>;
    /**
     * A contributor has claimed some rewards.
     * Data is the account getting paid and the amount of rewards paid.
     */
    "RewardsPaid": Anonymize<Ic2o7gh4sgom1k>;
    /**
     * A contributor has updated the reward address.
     */
    "RewardAddressUpdated": Anonymize<I5b6sd80djbc64>;
    /**
     * When initializing the reward vec an already initialized account was found
     */
    "InitializedAlreadyInitializedAccount": Anonymize<I20nlejbovhut6>;
    /**
     * When initializing the reward vec an already initialized account was found
     */
    "InitializedAccountWithNotEnoughContribution": Anonymize<I20nlejbovhut6>;
}>;
export type Ic2o7gh4sgom1k = [HexString, bigint];
export type I4moiumda17j4k = [FixedSizeBinary<32>, HexString, bigint];
export type I20nlejbovhut6 = [FixedSizeBinary<32>, Anonymize<I36nb9b8a306lm>, bigint];
export type Idsqc7mhp6nnle = AnonymousEnum<{
    /**
     * An HRMP message was sent to a sibling parachain.
     */
    "XcmpMessageSent": Anonymize<I137t1cld92pod>;
}>;
export type I137t1cld92pod = {
    "message_hash": FixedSizeBinary<32>;
};
export type Ihpdgvt7vs2cb = AnonymousEnum<{
    /**
     * Downward message is invalid XCM.
     * \[ id \]
     */
    "InvalidFormat": FixedSizeBinary<32>;
    /**
     * Downward message is unsupported version of XCM.
     * \[ id \]
     */
    "UnsupportedVersion": FixedSizeBinary<32>;
    /**
     * Downward message executed with the given outcome.
     * \[ id, outcome \]
     */
    "ExecutedDownward": Anonymize<Ibeto40kl3r5j7>;
}>;
export type Ibeto40kl3r5j7 = [FixedSizeBinary<32>, Anonymize<I6uq5gb4s805s7>];
export type Iel5f66clbekc3 = AnonymousEnum<{
    /**
     * Execution of an XCM message was attempted.
     */
    "Attempted": Anonymize<Ia72eet39sf8j9>;
    /**
     * A XCM message was sent.
     */
    "Sent": Anonymize<If8u5kl4h8070m>;
    /**
     * Query response received which does not match a registered query. This may be because a
     * matching query was never registered, it may be because it is a duplicate response, or
     * because the query timed out.
     */
    "UnexpectedResponse": Anonymize<Icl7nl1rfeog3i>;
    /**
     * Query response has been received and is ready for taking with `take_response`. There is
     * no registered notification call.
     */
    "ResponseReady": Anonymize<Iasr6pj6shs0fl>;
    /**
     * Query response has been received and query is removed. The registered notification has
     * been dispatched and executed successfully.
     */
    "Notified": Anonymize<I2uqmls7kcdnii>;
    /**
     * Query response has been received and query is removed. The registered notification
     * could not be dispatched because the dispatch weight is greater than the maximum weight
     * originally budgeted by this runtime for the query result.
     */
    "NotifyOverweight": Anonymize<Idg69klialbkb8>;
    /**
     * Query response has been received and query is removed. There was a general error with
     * dispatching the notification call.
     */
    "NotifyDispatchError": Anonymize<I2uqmls7kcdnii>;
    /**
     * Query response has been received and query is removed. The dispatch was unable to be
     * decoded into a `Call`; this might be due to dispatch function having a signature which
     * is not `(origin, QueryId, Response)`.
     */
    "NotifyDecodeFailed": Anonymize<I2uqmls7kcdnii>;
    /**
     * Expected query response has been received but the origin location of the response does
     * not match that expected. The query remains registered for a later, valid, response to
     * be received and acted upon.
     */
    "InvalidResponder": Anonymize<I7r6b7145022pp>;
    /**
     * Expected query response has been received but the expected origin location placed in
     * storage by this runtime previously cannot be decoded. The query remains registered.
     *
     * This is unexpected (since a location placed in storage in a previously executing
     * runtime should be readable prior to query timeout) and dangerous since the possibly
     * valid response will be dropped. Manual governance intervention is probably going to be
     * needed.
     */
    "InvalidResponderVersion": Anonymize<Icl7nl1rfeog3i>;
    /**
     * Received query response has been read and removed.
     */
    "ResponseTaken": Anonymize<I30pg328m00nr3>;
    /**
     * Some assets have been placed in an asset trap.
     */
    "AssetsTrapped": Anonymize<Icmrn7bogp28cs>;
    /**
     * An XCM version change notification message has been attempted to be sent.
     *
     * The cost of sending it (borne by the chain) is included.
     */
    "VersionChangeNotified": Anonymize<I7m9b5plj4h5ot>;
    /**
     * The supported version of a location has been changed. This might be through an
     * automatic notification or a manual intervention.
     */
    "SupportedVersionChanged": Anonymize<I9kt8c221c83ln>;
    /**
     * A given location which had a version change subscription was dropped owing to an error
     * sending the notification to it.
     */
    "NotifyTargetSendFail": Anonymize<I9onhk772nfs4f>;
    /**
     * A given location which had a version change subscription was dropped owing to an error
     * migrating the location to our new XCM format.
     */
    "NotifyTargetMigrationFail": Anonymize<I3l6bnksrmt56r>;
    /**
     * Expected query response has been received but the expected querier location placed in
     * storage by this runtime previously cannot be decoded. The query remains registered.
     *
     * This is unexpected (since a location placed in storage in a previously executing
     * runtime should be readable prior to query timeout) and dangerous since the possibly
     * valid response will be dropped. Manual governance intervention is probably going to be
     * needed.
     */
    "InvalidQuerierVersion": Anonymize<Icl7nl1rfeog3i>;
    /**
     * Expected query response has been received but the querier location of the response does
     * not match the expected. The query remains registered for a later, valid, response to
     * be received and acted upon.
     */
    "InvalidQuerier": Anonymize<Idh09k0l2pmdcg>;
    /**
     * A remote has requested XCM version change notification from us and we have honored it.
     * A version information message is sent to them and its cost is included.
     */
    "VersionNotifyStarted": Anonymize<I7uoiphbm0tj4r>;
    /**
     * We have requested that a remote chain send us XCM version change notifications.
     */
    "VersionNotifyRequested": Anonymize<I7uoiphbm0tj4r>;
    /**
     * We have requested that a remote chain stops sending us XCM version change
     * notifications.
     */
    "VersionNotifyUnrequested": Anonymize<I7uoiphbm0tj4r>;
    /**
     * Fees were paid from a location for an operation (often for using `SendXcm`).
     */
    "FeesPaid": Anonymize<I512p1n7qt24l8>;
    /**
     * Some assets have been claimed from an asset trap
     */
    "AssetsClaimed": Anonymize<Icmrn7bogp28cs>;
    /**
     * A XCM version migration finished.
     */
    "VersionMigrationFinished": Anonymize<I6s1nbislhk619>;
}>;
export type I64ops44uf7inr = AnonymousEnum<{
    /**
     * Some asset class was created.
     */
    "Created": Anonymize<Idh8b393kqmj7j>;
    /**
     * Some assets were issued.
     */
    "Issued": Anonymize<Ielv09e10u0hs2>;
    /**
     * Some assets were transferred.
     */
    "Transferred": Anonymize<I6g4mum1jlnvc1>;
    /**
     * Some assets were destroyed.
     */
    "Burned": Anonymize<I3fprcgugsmetj>;
    /**
     * The management team changed.
     */
    "TeamChanged": Anonymize<Ic5n87r88749i9>;
    /**
     * The owner changed.
     */
    "OwnerChanged": Anonymize<I56o6rrhe8jc9p>;
    /**
     * Some account `who` was frozen.
     */
    "Frozen": Anonymize<Ifk0u9gb6g0mb2>;
    /**
     * Some account `who` was thawed.
     */
    "Thawed": Anonymize<Ifk0u9gb6g0mb2>;
    /**
     * Some asset `asset_id` was frozen.
     */
    "AssetFrozen": Anonymize<Ib9karr24cpmca>;
    /**
     * Some asset `asset_id` was thawed.
     */
    "AssetThawed": Anonymize<Ib9karr24cpmca>;
    /**
     * Accounts were destroyed for given asset.
     */
    "AccountsDestroyed": Anonymize<Ifstva0urnm27g>;
    /**
     * Approvals were destroyed for given asset.
     */
    "ApprovalsDestroyed": Anonymize<I4lpo3encq7fn8>;
    /**
     * An asset class is in the process of being destroyed.
     */
    "DestructionStarted": Anonymize<Ib9karr24cpmca>;
    /**
     * An asset class was destroyed.
     */
    "Destroyed": Anonymize<Ib9karr24cpmca>;
    /**
     * Some asset class was force-created.
     */
    "ForceCreated": Anonymize<I56o6rrhe8jc9p>;
    /**
     * New metadata has been set for an asset.
     */
    "MetadataSet": Anonymize<Icd1cghie6s8nr>;
    /**
     * Metadata has been cleared for an asset.
     */
    "MetadataCleared": Anonymize<Ib9karr24cpmca>;
    /**
     * (Additional) funds have been approved for transfer to a destination account.
     */
    "ApprovedTransfer": Anonymize<I6h2hvtgcdifdu>;
    /**
     * An approval for account `delegate` was cancelled by `owner`.
     */
    "ApprovalCancelled": Anonymize<I624mqthj1is3k>;
    /**
     * An `amount` was transferred in its entirety from `owner` to `destination` by
     * the approved `delegate`.
     */
    "TransferredApproved": Anonymize<Ibb83anngn8kjs>;
    /**
     * An asset has had its attributes changed by the `Force` origin.
     */
    "AssetStatusChanged": Anonymize<Ib9karr24cpmca>;
    /**
     * The min_balance of an asset has been updated by the asset owner.
     */
    "AssetMinBalanceChanged": Anonymize<Iil3sdsh8fk7l>;
    /**
     * Some account `who` was created with a deposit from `depositor`.
     */
    "Touched": Anonymize<I2i7q7k387rgn8>;
    /**
     * Some account `who` was blocked.
     */
    "Blocked": Anonymize<Ifk0u9gb6g0mb2>;
    /**
     * Some assets were deposited (e.g. for transaction fees).
     */
    "Deposited": Anonymize<Id9dkj6pnhun40>;
    /**
     * Some assets were withdrawn from the account (e.g. for transaction fees).
     */
    "Withdrawn": Anonymize<Id9dkj6pnhun40>;
}>;
export type Idh8b393kqmj7j = {
    "asset_id": bigint;
    "creator": HexString;
    "owner": HexString;
};
export type Ielv09e10u0hs2 = {
    "asset_id": bigint;
    "owner": HexString;
    "amount": bigint;
};
export type I6g4mum1jlnvc1 = {
    "asset_id": bigint;
    "from": HexString;
    "to": HexString;
    "amount": bigint;
};
export type I3fprcgugsmetj = {
    "asset_id": bigint;
    "owner": HexString;
    "balance": bigint;
};
export type Ic5n87r88749i9 = {
    "asset_id": bigint;
    "issuer": HexString;
    "admin": HexString;
    "freezer": HexString;
};
export type I56o6rrhe8jc9p = {
    "asset_id": bigint;
    "owner": HexString;
};
export type Ifk0u9gb6g0mb2 = {
    "asset_id": bigint;
    "who": HexString;
};
export type Ib9karr24cpmca = {
    "asset_id": bigint;
};
export type Ifstva0urnm27g = {
    "asset_id": bigint;
    "accounts_destroyed": number;
    "accounts_remaining": number;
};
export type I4lpo3encq7fn8 = {
    "asset_id": bigint;
    "approvals_destroyed": number;
    "approvals_remaining": number;
};
export type Icd1cghie6s8nr = {
    "asset_id": bigint;
    "name": Binary;
    "symbol": Binary;
    "decimals": number;
    "is_frozen": boolean;
};
export type I6h2hvtgcdifdu = {
    "asset_id": bigint;
    "source": HexString;
    "delegate": HexString;
    "amount": bigint;
};
export type I624mqthj1is3k = {
    "asset_id": bigint;
    "owner": HexString;
    "delegate": HexString;
};
export type Ibb83anngn8kjs = {
    "asset_id": bigint;
    "owner": HexString;
    "delegate": HexString;
    "destination": HexString;
    "amount": bigint;
};
export type Iil3sdsh8fk7l = {
    "asset_id": bigint;
    "new_min_balance": bigint;
};
export type I2i7q7k387rgn8 = {
    "asset_id": bigint;
    "who": HexString;
    "depositor": HexString;
};
export type Id9dkj6pnhun40 = {
    "asset_id": bigint;
    "who": HexString;
    "amount": bigint;
};
export type I2ql1p3qbtsfeo = AnonymousEnum<{
    /**
     * New asset with the asset manager is registered
     */
    "ForeignAssetRegistered": Anonymize<Ifg57078c09fmj>;
    /**
     * Changed the amount of units we are charging per execution second for a given asset
     */
    "UnitsPerSecondChanged": undefined;
    /**
     * Changed the xcm type mapping for a given asset id
     */
    "ForeignAssetXcmLocationChanged": Anonymize<Iemia6jnjjt9pk>;
    /**
     * Removed all information related to an assetId
     */
    "ForeignAssetRemoved": Anonymize<Ibp1rmkdg27gch>;
    /**
     * Supported asset type for fee payment removed
     */
    "SupportedAssetRemoved": Anonymize<Ibb592400fjaeq>;
    /**
     * Removed all information related to an assetId and destroyed asset
     */
    "ForeignAssetDestroyed": Anonymize<Ibp1rmkdg27gch>;
    /**
     * Removed all information related to an assetId and destroyed asset
     */
    "LocalAssetDestroyed": Anonymize<Ib9karr24cpmca>;
}>;
export type Ifg57078c09fmj = {
    "asset_id": bigint;
    "asset": Anonymize<Ics9mfhmor8iso>;
    "metadata": Anonymize<Iecv438ahg26fr>;
};
export type Ics9mfhmor8iso = AnonymousEnum<{
    "Xcm": Anonymize<I4c0s5cioidn76>;
}>;
export type Iecv438ahg26fr = {
    "name": Binary;
    "symbol": Binary;
    "decimals": number;
    "is_frozen": boolean;
};
export type Iemia6jnjjt9pk = {
    "asset_id": bigint;
    "new_asset_type": Anonymize<Ics9mfhmor8iso>;
};
export type Ibp1rmkdg27gch = {
    "asset_id": bigint;
    "asset_type": Anonymize<Ics9mfhmor8iso>;
};
export type Ibb592400fjaeq = {
    "asset_type": Anonymize<Ics9mfhmor8iso>;
};
export type Icnbh4vp7l3kna = AnonymousEnum<{
    /**
     * Transacted the inner call through a derivative account in a destination chain.
     */
    "TransactedDerivative": Anonymize<Id06b279ssr1kc>;
    /**
     * Transacted the call through the sovereign account in a destination chain.
     */
    "TransactedSovereign": Anonymize<Ic0kmabrt5gmed>;
    /**
     * Transacted the call through a signed account in a destination chain.
     */
    "TransactedSigned": Anonymize<I7mnb4b8me3to9>;
    /**
     * Registered a derivative index for an account id.
     */
    "RegisteredDerivative": Anonymize<Igss9t88pmg14>;
    "DeRegisteredDerivative": Anonymize<I666bl2fqjkejo>;
    /**
     * Transact failed
     */
    "TransactFailed": Anonymize<Iflkd2j467575k>;
    /**
     * Changed the transact info of a location
     */
    "TransactInfoChanged": Anonymize<Ie4l506ob97qll>;
    /**
     * Removed the transact info of a location
     */
    "TransactInfoRemoved": Anonymize<I2adkav4nfpltp>;
    /**
     * Set dest fee per second
     */
    "DestFeePerSecondChanged": Anonymize<Ibj2l071rn1t54>;
    /**
     * Remove dest fee per second
     */
    "DestFeePerSecondRemoved": Anonymize<I2adkav4nfpltp>;
    /**
     * HRMP manage action succesfully sent
     */
    "HrmpManagementSent": Anonymize<I84dsnnkjb0aqp>;
}>;
export type Id06b279ssr1kc = {
    "account_id": HexString;
    "dest": Anonymize<If9iqq7i64mur8>;
    "call": Binary;
    "index": number;
};
export type Ic0kmabrt5gmed = {
    "fee_payer"?: Anonymize<I36nb9b8a306lm>;
    "dest": Anonymize<If9iqq7i64mur8>;
    "call": Binary;
};
export type I7mnb4b8me3to9 = {
    "fee_payer": HexString;
    "dest": Anonymize<If9iqq7i64mur8>;
    "call": Binary;
};
export type Igss9t88pmg14 = {
    "account_id": HexString;
    "index": number;
};
export type Ie4l506ob97qll = {
    "location": Anonymize<If9iqq7i64mur8>;
    "remote_info": Anonymize<Icf5eq2v7aoc8g>;
};
export type Icf5eq2v7aoc8g = {
    "transact_extra_weight": Anonymize<I4q39t5hn830vp>;
    "max_weight": Anonymize<I4q39t5hn830vp>;
    "transact_extra_weight_signed"?: Anonymize<Iasb8k6ash5mjn>;
};
export type Ibj2l071rn1t54 = {
    "location": Anonymize<If9iqq7i64mur8>;
    "fee_per_second": bigint;
};
export type I84dsnnkjb0aqp = {
    "action": Anonymize<I5db54nrs89k41>;
};
export type I5db54nrs89k41 = AnonymousEnum<{
    "InitOpen": {
        "para_id": number;
        "proposed_max_capacity": number;
        "proposed_max_message_size": number;
    };
    "Accept": Anonymize<I37r4bdai8o9mp>;
    "Close": Anonymize<I50mrcbubp554e>;
    "Cancel": Anonymize<I96ftepqm4vs7m>;
}>;
export type Id747bemfev6ju = AnonymousEnum<{
    /**
     * Ethereum transaction executed from XCM
     */
    "ExecutedFromXcm": Anonymize<Ielbsgfbhoi5ci>;
}>;
export type Ielbsgfbhoi5ci = {
    "xcm_msg_hash": FixedSizeBinary<32>;
    "eth_tx_hash": FixedSizeBinary<32>;
};
export type I2kosejppk3jon = AnonymousEnum<{
    /**
     * Message discarded due to an error in the `MessageProcessor` (usually a format error).
     */
    "ProcessingFailed": Anonymize<I1rvj4ubaplho0>;
    /**
     * Message is processed.
     */
    "Processed": Anonymize<Ia3uu7lqcc1q1i>;
    /**
     * Message placed in overweight queue.
     */
    "OverweightEnqueued": Anonymize<I7crucfnonitkn>;
    /**
     * This page was reaped.
     */
    "PageReaped": Anonymize<I7tmrp94r9sq4n>;
}>;
export type I1rvj4ubaplho0 = {
    /**
     * The `blake2_256` hash of the message.
     */
    "id": FixedSizeBinary<32>;
    /**
     * The queue of the message.
     */
    "origin": Anonymize<Iejeo53sea6n4q>;
    /**
     * The error that occurred.
     *
     * This error is pretty opaque. More fine-grained errors need to be emitted as events
     * by the `MessageProcessor`.
     */
    "error": Anonymize<I5hhsj7l9obr84>;
};
export type Iejeo53sea6n4q = AnonymousEnum<{
    "Here": undefined;
    "Parent": undefined;
    "Sibling": number;
}>;
export type Ia3uu7lqcc1q1i = {
    /**
     * The `blake2_256` hash of the message.
     */
    "id": FixedSizeBinary<32>;
    /**
     * The queue of the message.
     */
    "origin": Anonymize<Iejeo53sea6n4q>;
    /**
     * How much weight was used to process the message.
     */
    "weight_used": Anonymize<I4q39t5hn830vp>;
    /**
     * Whether the message was processed.
     *
     * Note that this does not mean that the underlying `MessageProcessor` was internally
     * successful. It *solely* means that the MQ pallet will treat this as a success
     * condition and discard the message. Any internal error needs to be emitted as events
     * by the `MessageProcessor`.
     */
    "success": boolean;
};
export type I7crucfnonitkn = {
    /**
     * The `blake2_256` hash of the message.
     */
    "id": FixedSizeBinary<32>;
    /**
     * The queue of the message.
     */
    "origin": Anonymize<Iejeo53sea6n4q>;
    /**
     * The page of the message.
     */
    "page_index": number;
    /**
     * The index of the message within the page.
     */
    "message_index": number;
};
export type I7tmrp94r9sq4n = {
    /**
     * The queue of the page.
     */
    "origin": Anonymize<Iejeo53sea6n4q>;
    /**
     * The index of the page.
     */
    "index": number;
};
export type I6sk30irag0rj6 = AnonymousEnum<{
    /**
     * New asset with the asset manager is registered
     */
    "ForeignAssetCreated": Anonymize<Ia28js1r46j2jd>;
    /**
     * Changed the xcm type mapping for a given asset id
     */
    "ForeignAssetXcmLocationChanged": Anonymize<I2rh7qrq0i4g18>;
    "ForeignAssetFrozen": Anonymize<I8lbbb85osree4>;
    "ForeignAssetUnfrozen": Anonymize<I8lbbb85osree4>;
    /**
     * Tokens have been locked for asset creation
     */
    "TokensLocked": Anonymize<I8sb4e35iir6l5>;
}>;
export type Ia28js1r46j2jd = {
    "contract_address": FixedSizeBinary<20>;
    "asset_id": bigint;
    "xcm_location": Anonymize<If9iqq7i64mur8>;
    "deposit"?: Anonymize<I35p85j063s0il>;
};
export type I2rh7qrq0i4g18 = {
    "asset_id": bigint;
    "previous_xcm_location": Anonymize<If9iqq7i64mur8>;
    "new_xcm_location": Anonymize<If9iqq7i64mur8>;
};
export type I8lbbb85osree4 = {
    "asset_id": bigint;
    "xcm_location": Anonymize<If9iqq7i64mur8>;
};
export type I8sb4e35iir6l5 = [HexString, bigint, Anonymize<I4totqt881mlti>];
export type I4totqt881mlti = FixedSizeArray<4, bigint>;
export type I97lmcp19lo158 = AnonymousEnum<{
    /**
     * New supported asset is registered
     */
    "SupportedAssetAdded": Anonymize<I83vh5qua5oulp>;
    /**
     * Changed the amount of units we are charging per execution second for a given asset
     */
    "SupportedAssetEdited": Anonymize<I83vh5qua5oulp>;
    /**
     * Pause support for a given asset
     */
    "PauseAssetSupport": Anonymize<I2adkav4nfpltp>;
    /**
     * Resume support for a given asset
     */
    "ResumeAssetSupport": Anonymize<I2adkav4nfpltp>;
    /**
     * Supported asset type for fee payment removed
     */
    "SupportedAssetRemoved": Anonymize<I2adkav4nfpltp>;
}>;
export type I83vh5qua5oulp = {
    "location": Anonymize<If9iqq7i64mur8>;
    "relative_price": bigint;
};
export type Iaakhspsugfd34 = AnonymousEnum<{
    /**
     * The XCM incoming execution was Paused
     */
    "EnteredPausedXcmMode": undefined;
    /**
     * The XCM incoming execution returned to normal operation
     */
    "NormalXcmOperationResumed": undefined;
}>;
export type I94co7vj7h6bo = AnonymousEnum<{
    /**
     * A Runtime upgrade started.
     *
     * Its end is indicated by `UpgradeCompleted` or `UpgradeFailed`.
     */
    "UpgradeStarted": Anonymize<If1co0pilmi7oq>;
    /**
     * The current runtime upgrade completed.
     *
     * This implies that all of its migrations completed successfully as well.
     */
    "UpgradeCompleted": undefined;
    /**
     * Runtime upgrade failed.
     *
     * This is very bad and will require governance intervention.
     */
    "UpgradeFailed": undefined;
    /**
     * A migration was skipped since it was already executed in the past.
     */
    "MigrationSkipped": Anonymize<I666bl2fqjkejo>;
    /**
     * A migration progressed.
     */
    "MigrationAdvanced": Anonymize<Iae74gjak1qibn>;
    /**
     * A Migration completed.
     */
    "MigrationCompleted": Anonymize<Iae74gjak1qibn>;
    /**
     * A Migration failed.
     *
     * This implies that the whole upgrade failed and governance intervention is required.
     */
    "MigrationFailed": Anonymize<Iae74gjak1qibn>;
    /**
     * The set of historical migrations has been cleared.
     */
    "HistoricCleared": Anonymize<I3escdojpj0551>;
}>;
export type If1co0pilmi7oq = {
    /**
     * The number of migrations that this upgrade contains.
     *
     * This can be used to design a progress indicator in combination with counting the
     * `MigrationCompleted` and `MigrationSkipped` events.
     */
    "migrations": number;
};
export type Iae74gjak1qibn = {
    /**
     * The index of the migration within the [`Config::Migrations`] list.
     */
    "index": number;
    /**
     * The number of blocks that this migration took so far.
     */
    "took": number;
};
export type I3escdojpj0551 = {
    /**
     * Should be passed to `clear_historic` in a successive call.
     */
    "next_cursor"?: Anonymize<Iabpgqcjikia83>;
};
export type Idb6rt29f52h0r = AnonymousEnum<{
    "RandomnessRequestedBabeEpoch": Anonymize<Iahnhnerp9kl4i>;
    "RandomnessRequestedLocal": Anonymize<Ia0eo5esjam6l0>;
    "RequestFulfilled": Anonymize<I4ov6e94l79mbg>;
    "RequestFeeIncreased": Anonymize<I9ii7g5i3f004f>;
    "RequestExpirationExecuted": Anonymize<I4ov6e94l79mbg>;
}>;
export type Iahnhnerp9kl4i = {
    "id": bigint;
    "refund_address": FixedSizeBinary<20>;
    "contract_address": FixedSizeBinary<20>;
    "fee": bigint;
    "gas_limit": bigint;
    "num_words": number;
    "salt": FixedSizeBinary<32>;
    "earliest_epoch": bigint;
};
export type Ia0eo5esjam6l0 = {
    "id": bigint;
    "refund_address": FixedSizeBinary<20>;
    "contract_address": FixedSizeBinary<20>;
    "fee": bigint;
    "gas_limit": bigint;
    "num_words": number;
    "salt": FixedSizeBinary<32>;
    "earliest_block": number;
};
export type I9ii7g5i3f004f = {
    "id": bigint;
    "new_fee": bigint;
};
export type I9kq3t3h4e6cgp = AnonymousEnum<{
    /**
     * Best finalized chain header has been updated to the header with given number and hash.
     */
    "UpdatedBestFinalizedHeader": Anonymize<Id4cm1n8k2kug1>;
}>;
export type Id4cm1n8k2kug1 = {
    /**
     * Number of the new best finalized header.
     */
    "number": number;
    /**
     * Hash of the new best finalized header.
     */
    "hash": FixedSizeBinary<32>;
    /**
     * The Grandpa info associated to the new best finalized header.
     */
    "grandpa_info": Anonymize<I627irg93qbdgl>;
};
export type I627irg93qbdgl = {
    "finality_proof": Anonymize<I1thtncjg26ghr>;
    "new_verification_context"?: (Anonymize<I74nture9pgqeq>) | undefined;
};
export type I1thtncjg26ghr = {
    "round": bigint;
    "commit": {
        "target_hash": FixedSizeBinary<32>;
        "target_number": number;
        "precommits": Array<{
            "precommit": Anonymize<I8e06chr1md241>;
            "signature": FixedSizeBinary<64>;
            "id": FixedSizeBinary<32>;
        }>;
    };
    "votes_ancestries": Array<Anonymize<Ic952bubvq4k7d>>;
};
export type I74nture9pgqeq = {
    "authorities": Anonymize<I3geksg000c171>;
    "set_id": bigint;
};
export type I4icsif27kbhhg = AnonymousEnum<{
    /**
     * The caller has provided head of parachain that the pallet is not configured to track.
     */
    "UntrackedParachainRejected": Anonymize<I6p1tq74832j8u>;
    /**
     * The caller has declared that he has provided given parachain head, but it is missing
     * from the storage proof.
     */
    "MissingParachainHead": Anonymize<I6p1tq74832j8u>;
    /**
     * The caller has provided parachain head hash that is not matching the hash read from the
     * storage proof.
     */
    "IncorrectParachainHeadHash": Anonymize<Ij76tvu0faddj>;
    /**
     * The caller has provided obsolete parachain head, which is already known to the pallet.
     */
    "RejectedObsoleteParachainHead": Anonymize<I6r44prunlrgaa>;
    /**
     * The caller has provided parachain head that exceeds the maximal configured head size.
     */
    "RejectedLargeParachainHead": Anonymize<I6b8h9eitutv15>;
    /**
     * Parachain head has been updated.
     */
    "UpdatedParachainHead": Anonymize<I6r44prunlrgaa>;
}>;
export type I6p1tq74832j8u = {
    /**
     * Identifier of the parachain that is not tracked by the pallet.
     */
    "parachain": number;
};
export type Ij76tvu0faddj = {
    /**
     * Identifier of the parachain with incorrect head hast.
     */
    "parachain": number;
    /**
     * Specified parachain head hash.
     */
    "parachain_head_hash": FixedSizeBinary<32>;
    /**
     * Actual parachain head hash.
     */
    "actual_parachain_head_hash": FixedSizeBinary<32>;
};
export type I6r44prunlrgaa = {
    /**
     * Identifier of the parachain with obsolete head.
     */
    "parachain": number;
    /**
     * Obsolete parachain head hash.
     */
    "parachain_head_hash": FixedSizeBinary<32>;
};
export type I6b8h9eitutv15 = {
    /**
     * Identifier of the parachain with rejected head.
     */
    "parachain": number;
    /**
     * Parachain head hash.
     */
    "parachain_head_hash": FixedSizeBinary<32>;
    /**
     * Parachain head size.
     */
    "parachain_head_size": number;
};
export type I5fvsm0mnhja4b = AnonymousEnum<{
    /**
     * Message has been accepted and is waiting to be delivered.
     */
    "MessageAccepted": Anonymize<I1udtl7slp3rsi>;
    /**
     * Messages have been received from the bridged chain.
     */
    "MessagesReceived": Anonymize<I2epvs8l1lnps1>;
    /**
     * Messages in the inclusive range have been delivered to the bridged chain.
     */
    "MessagesDelivered": Anonymize<I5q1vbe7r2d82f>;
}>;
export type I1udtl7slp3rsi = {
    /**
     * Lane, which has accepted the message.
     */
    "lane_id": FixedSizeBinary<32>;
    /**
     * Nonce of accepted message.
     */
    "nonce": bigint;
};
export type I2epvs8l1lnps1 = {
    "lane": FixedSizeBinary<32>;
    "receive_results": Array<[bigint, Enum<{
        "Dispatched": {
            "unspent_weight": Anonymize<I4q39t5hn830vp>;
            "dispatch_level_result": Enum<{
                "InvalidPayload": undefined;
                "Dispatched": undefined;
                "NotDispatched": undefined;
            }>;
        };
        "InvalidNonce": undefined;
        "TooManyUnrewardedRelayers": undefined;
        "TooManyUnconfirmedMessages": undefined;
    }>]>;
};
export type I5q1vbe7r2d82f = {
    /**
     * Lane for which the delivery has been confirmed.
     */
    "lane_id": FixedSizeBinary<32>;
    /**
     * Delivered messages.
     */
    "messages": Anonymize<I2trpm8e0601l4>;
};
export type I2trpm8e0601l4 = {
    "begin": bigint;
    "end": bigint;
};
export type Icq1j4dp95np9v = AnonymousEnum<{
    /**
     * The bridge between two locations has been opened.
     */
    "BridgeOpened": Anonymize<I27v0imulq8cgl>;
    /**
     * Bridge is going to be closed, but not yet fully pruned from the runtime storage.
     */
    "ClosingBridge": Anonymize<I73r8bg99ccqq4>;
    /**
     * Bridge has been closed and pruned from the runtime storage. It now may be reopened
     * again by any participant.
     */
    "BridgePruned": Anonymize<Ifeve6k9vrdlrh>;
}>;
export type I27v0imulq8cgl = {
    /**
     * Bridge identifier.
     */
    "bridge_id": FixedSizeBinary<32>;
    /**
     * Amount of deposit held.
     */
    "bridge_deposit": bigint;
    /**
     * Universal location of local bridge endpoint.
     */
    "local_endpoint": XcmV5Junctions;
    /**
     * Universal location of remote bridge endpoint.
     */
    "remote_endpoint": XcmV5Junctions;
    /**
     * Lane identifier.
     */
    "lane_id": FixedSizeBinary<32>;
};
export type I73r8bg99ccqq4 = {
    /**
     * Bridge identifier.
     */
    "bridge_id": FixedSizeBinary<32>;
    /**
     * Lane identifier.
     */
    "lane_id": FixedSizeBinary<32>;
    /**
     * Number of pruned messages during the close call.
     */
    "pruned_messages": bigint;
    /**
     * Number of enqueued messages that need to be pruned in follow up calls.
     */
    "enqueued_messages": bigint;
};
export type Ifeve6k9vrdlrh = {
    /**
     * Bridge identifier.
     */
    "bridge_id": FixedSizeBinary<32>;
    /**
     * Lane identifier.
     */
    "lane_id": FixedSizeBinary<32>;
    /**
     * Amount of deposit released.
     */
    "bridge_deposit": bigint;
    /**
     * Number of pruned messages during the close call.
     */
    "pruned_messages": bigint;
};
export type I1v7jbnil3tjns = Array<{
    "used_bandwidth": Anonymize<Ieafp1gui1o4cl>;
    "para_head_hash"?: Anonymize<I4s6vifaf8k998>;
    "consumed_go_ahead_signal"?: Anonymize<Iav8k1edbj86k7>;
}>;
export type Ieafp1gui1o4cl = {
    "ump_msg_count": number;
    "ump_total_bytes": number;
    "hrmp_outgoing": Array<[number, {
        "msg_count": number;
        "total_bytes": number;
    }]>;
};
export type Iav8k1edbj86k7 = (UpgradeGoAhead) | undefined;
export type I8jgj1nhcr2dg8 = {
    "used_bandwidth": Anonymize<Ieafp1gui1o4cl>;
    "hrmp_watermark"?: Anonymize<I4arjljr6dpflb>;
    "consumed_go_ahead_signal"?: Anonymize<Iav8k1edbj86k7>;
};
export type I4i91h98n3cv1b = {
    "dmq_mqc_head": FixedSizeBinary<32>;
    "relay_dispatch_queue_remaining_capacity": {
        "remaining_count": number;
        "remaining_size": number;
    };
    "ingress_channels": Array<[number, {
        "max_capacity": number;
        "max_total_size": number;
        "max_message_size": number;
        "msg_count": number;
        "total_size": number;
        "mqc_head"?: Anonymize<I4s6vifaf8k998>;
    }]>;
    "egress_channels": Array<[number, {
        "max_capacity": number;
        "max_total_size": number;
        "max_message_size": number;
        "msg_count": number;
        "total_size": number;
        "mqc_head"?: Anonymize<I4s6vifaf8k998>;
    }]>;
};
export type I4iumukclgj8ej = {
    "max_code_size": number;
    "max_head_data_size": number;
    "max_upward_queue_count": number;
    "max_upward_queue_size": number;
    "max_upward_message_size": number;
    "max_upward_message_num_per_candidate": number;
    "hrmp_max_message_num_per_candidate": number;
    "validation_upgrade_cooldown": number;
    "validation_upgrade_delay": number;
    "async_backing_params": Anonymize<Iavuvfkop6318c>;
};
export type I5rp0aladdbrpc = Array<{
    "id": FixedSizeBinary<4>;
    "amount": bigint;
}>;
export type Ie0j5apjs41eea = Array<{
    "id": Enum<{
        "Preimage": PreimagePalletHoldReason;
        "BridgeXcmOverMoonriver": Enum<{
            "BridgeDeposit": undefined;
        }>;
    }>;
    "amount": bigint;
}>;
export type I9bin2jc70qt6q = Array<Anonymize<I3qt1hgg4djhgb>>;
export type I4k7tm7j6vdt7e = {
    "current": number;
    "first": number;
    "length": number;
    "first_slot": bigint;
};
export type I6knmt844a3vbi = {
    "id": HexString;
    "delegations": Anonymize<Icthrrn1e819l6>;
    "total": bigint;
    "less_total": bigint;
    "status": Anonymize<I91jcpjd7q6d1i>;
};
export type Icthrrn1e819l6 = Array<{
    "owner": HexString;
    "amount": bigint;
}>;
export type I91jcpjd7q6d1i = AnonymousEnum<{
    "Active": undefined;
    "Leaving": number;
}>;
export type I45jh0r7cgpsjj = {
    "bond": bigint;
    "delegation_count": number;
    "total_counted": bigint;
    "lowest_top_delegation_amount": bigint;
    "highest_bottom_delegation_amount": bigint;
    "lowest_bottom_delegation_amount": bigint;
    "top_capacity": Enum<{
        "Full": undefined;
        "Empty": undefined;
        "Partial": undefined;
    }>;
    "bottom_capacity": Enum<{
        "Full": undefined;
        "Empty": undefined;
        "Partial": undefined;
    }>;
    "request"?: ({
        "amount": bigint;
        "when_executable": number;
    }) | undefined;
    "status": Enum<{
        "Active": undefined;
        "Idle": undefined;
        "Leaving": number;
    }>;
};
export type I6jltko73jemrp = Array<{
    "delegator": HexString;
    "when_executable": number;
    "action": Anonymize<Ibtq25m1pbdmfs>;
}>;
export type I6jst4duko1p6f = Array<{
    "delegator": HexString;
    "value": number;
}>;
export type I15qcqgmilpii9 = {
    "delegations": Anonymize<Icthrrn1e819l6>;
    "total": bigint;
};
export type I55luuvb7oq2a3 = Array<HexString>;
export type I82d8q70phr5qc = {
    "bond": bigint;
    "delegations": Array<{
        "owner": HexString;
        "amount": bigint;
        "auto_compound": number;
    }>;
    "total": bigint;
};
export type I7kej5hvj859dg = [number, HexString];
export type Iffrjmlp7d020q = {
    "round_issuance": bigint;
    "total_staking_reward": bigint;
    "collator_commission": number;
};
export type I5h9039rqpeali = {
    "expect": Anonymize<I75misot8iv5e8>;
    "annual": Anonymize<Ifcbg4i4r2gomt>;
    "round": Anonymize<Ifcbg4i4r2gomt>;
};
export type I75misot8iv5e8 = {
    "min": bigint;
    "ideal": bigint;
    "max": bigint;
};
export type Ifcbg4i4r2gomt = {
    "min": number;
    "ideal": number;
    "max": number;
};
export type Ic9tuh1kf9enop = {
    "account": HexString;
    "deposit": bigint;
    "keys": FixedSizeBinary<32>;
};
export type Iakad189l4ah9s = {
    "orbiters": Anonymize<I55luuvb7oq2a3>;
    "maybe_current_orbiter"?: ({
        "account_id": HexString;
        "removed": boolean;
    }) | undefined;
    "next_orbiter": number;
};
export type Ifg4nud9sun9ud = [Array<Anonymize<Io22o6h1g8ak4>>, bigint];
export type Io22o6h1g8ak4 = {
    "delegate": HexString;
    "proxy_type": Anonymize<Ifmiop0mj0oacq>;
    "delay": number;
};
export type I1rjlrctbmbkv6 = [Array<{
    "real": HexString;
    "call_hash": FixedSizeBinary<32>;
    "height": number;
}>, bigint];
export type I4ftk0glls7946 = {
    "judgements": Array<[number, IdentityJudgement]>;
    "deposit": bigint;
    "info": Anonymize<I1o57snqt6f4v5>;
};
export type IdentityJudgement = Enum<{
    "Unknown": undefined;
    "FeePaid": bigint;
    "Reasonable": undefined;
    "KnownGood": undefined;
    "OutOfDate": undefined;
    "LowQuality": undefined;
    "Erroneous": undefined;
}>;
export declare const IdentityJudgement: GetEnum<IdentityJudgement>;
export type I1o57snqt6f4v5 = {
    "additional": Array<FixedSizeArray<2, IdentityData>>;
    "display": IdentityData;
    "legal": IdentityData;
    "web": IdentityData;
    "riot": IdentityData;
    "email": IdentityData;
    "pgp_fingerprint"?: Anonymize<If7b8240vgt2q5>;
    "image": IdentityData;
    "twitter": IdentityData;
};
export type IdentityData = Enum<{
    "None": undefined;
    "Raw0": undefined;
    "Raw1": number;
    "Raw2": FixedSizeBinary<2>;
    "Raw3": FixedSizeBinary<3>;
    "Raw4": FixedSizeBinary<4>;
    "Raw5": FixedSizeBinary<5>;
    "Raw6": FixedSizeBinary<6>;
    "Raw7": FixedSizeBinary<7>;
    "Raw8": FixedSizeBinary<8>;
    "Raw9": FixedSizeBinary<9>;
    "Raw10": FixedSizeBinary<10>;
    "Raw11": FixedSizeBinary<11>;
    "Raw12": FixedSizeBinary<12>;
    "Raw13": FixedSizeBinary<13>;
    "Raw14": FixedSizeBinary<14>;
    "Raw15": FixedSizeBinary<15>;
    "Raw16": FixedSizeBinary<16>;
    "Raw17": FixedSizeBinary<17>;
    "Raw18": FixedSizeBinary<18>;
    "Raw19": FixedSizeBinary<19>;
    "Raw20": FixedSizeBinary<20>;
    "Raw21": FixedSizeBinary<21>;
    "Raw22": FixedSizeBinary<22>;
    "Raw23": FixedSizeBinary<23>;
    "Raw24": FixedSizeBinary<24>;
    "Raw25": FixedSizeBinary<25>;
    "Raw26": FixedSizeBinary<26>;
    "Raw27": FixedSizeBinary<27>;
    "Raw28": FixedSizeBinary<28>;
    "Raw29": FixedSizeBinary<29>;
    "Raw30": FixedSizeBinary<30>;
    "Raw31": FixedSizeBinary<31>;
    "Raw32": FixedSizeBinary<32>;
    "BlakeTwo256": FixedSizeBinary<32>;
    "Sha256": FixedSizeBinary<32>;
    "Keccak256": FixedSizeBinary<32>;
    "ShaThree256": FixedSizeBinary<32>;
}>;
export declare const IdentityData: GetEnum<IdentityData>;
export type If7b8240vgt2q5 = (FixedSizeBinary<20>) | undefined;
export type Ic42splpg0rgdk = [HexString, IdentityData];
export type I4v65mt1qihbrb = [bigint, Anonymize<I55luuvb7oq2a3>];
export type Id5475igfi6cio = Array<({
    "account": HexString;
    "fee": bigint;
    "fields": bigint;
}) | undefined>;
export type I2506ik7f9ukdl = {
    "account_id": HexString;
    "allocation": number;
};
export type Idhgvqu0hhernj = {
    "owner": HexString;
    "provider": Anonymize<Idib8jf3ve40bj>;
};
export type Idib8jf3ve40bj = AnonymousEnum<{
    "Allocation": undefined;
    "AuthorityDeposit": bigint;
    "System": undefined;
}>;
export type I7sft4mmcq61ka = [HexString, number, Anonymize<Idib8jf3ve40bj>];
export type I3ks2fimshchoe = {
    "when": Anonymize<Itvprrpb0nm3o>;
    "deposit": bigint;
    "depositor": HexString;
    "approvals": Anonymize<I55luuvb7oq2a3>;
};
export type I1f5dukd42n5v5 = [HexString, FixedSizeBinary<32>];
export type I7jidl7qnnq87c = {
    "size": bigint;
    "hash": FixedSizeBinary<32>;
};
export type I82cps8ng2jtug = [FixedSizeBinary<20>, FixedSizeBinary<32>];
export type Ifitc0q6ckjb3j = [Anonymize<I6fr2mqud652ga>, Anonymize<Ifoernv5r40rfc>, Anonymize<I87cgves5f5lsa>];
export type I6fr2mqud652ga = AnonymousEnum<{
    "Legacy": Anonymize<I22u79j4u5as1p>;
    "EIP2930": {
        "chain_id": bigint;
        "nonce": Anonymize<I4totqt881mlti>;
        "gas_price": Anonymize<I4totqt881mlti>;
        "gas_limit": Anonymize<I4totqt881mlti>;
        "action": Anonymize<I2do93a3gr3ege>;
        "value": Anonymize<I4totqt881mlti>;
        "input": Binary;
        "access_list": Anonymize<Ieap15h2pjii9u>;
        "odd_y_parity": boolean;
        "r": FixedSizeBinary<32>;
        "s": FixedSizeBinary<32>;
    };
    "EIP1559": {
        "chain_id": bigint;
        "nonce": Anonymize<I4totqt881mlti>;
        "max_priority_fee_per_gas": Anonymize<I4totqt881mlti>;
        "max_fee_per_gas": Anonymize<I4totqt881mlti>;
        "gas_limit": Anonymize<I4totqt881mlti>;
        "action": Anonymize<I2do93a3gr3ege>;
        "value": Anonymize<I4totqt881mlti>;
        "input": Binary;
        "access_list": Anonymize<Ieap15h2pjii9u>;
        "odd_y_parity": boolean;
        "r": FixedSizeBinary<32>;
        "s": FixedSizeBinary<32>;
    };
}>;
export type I22u79j4u5as1p = {
    "nonce": Anonymize<I4totqt881mlti>;
    "gas_price": Anonymize<I4totqt881mlti>;
    "gas_limit": Anonymize<I4totqt881mlti>;
    "action": Anonymize<I2do93a3gr3ege>;
    "value": Anonymize<I4totqt881mlti>;
    "input": Binary;
    "signature": {
        "v": bigint;
        "r": FixedSizeBinary<32>;
        "s": FixedSizeBinary<32>;
    };
};
export type I2do93a3gr3ege = AnonymousEnum<{
    "Call": FixedSizeBinary<20>;
    "Create": undefined;
}>;
export type Ieap15h2pjii9u = Array<{
    "address": FixedSizeBinary<20>;
    "storage_keys": Anonymize<Ic5m5lp1oioo8r>;
}>;
export type Ifoernv5r40rfc = {
    "transaction_hash": FixedSizeBinary<32>;
    "transaction_index": number;
    "from": FixedSizeBinary<20>;
    "to"?: Anonymize<If7b8240vgt2q5>;
    "contract_address"?: Anonymize<If7b8240vgt2q5>;
    "logs": Anonymize<Ids7ng2qsv7snu>;
    "logs_bloom": FixedSizeBinary<256>;
};
export type Ids7ng2qsv7snu = Array<Anonymize<I10qb03fpuk6em>>;
export type I87cgves5f5lsa = AnonymousEnum<{
    "Legacy": Anonymize<I16nm875k0bak5>;
    "EIP2930": Anonymize<I16nm875k0bak5>;
    "EIP1559": Anonymize<I16nm875k0bak5>;
}>;
export type I16nm875k0bak5 = {
    "status_code": number;
    "used_gas": Anonymize<I4totqt881mlti>;
    "logs_bloom": FixedSizeBinary<256>;
    "logs": Anonymize<Ids7ng2qsv7snu>;
};
export type Idi27giun0mb9q = {
    "header": Anonymize<I4v962mnhj6j6r>;
    "transactions": Anonymize<I1fl9qh2r1hf29>;
    "ommers": Anonymize<I78ffku0ve5fgm>;
};
export type I4v962mnhj6j6r = {
    "parent_hash": FixedSizeBinary<32>;
    "ommers_hash": FixedSizeBinary<32>;
    "beneficiary": FixedSizeBinary<20>;
    "state_root": FixedSizeBinary<32>;
    "transactions_root": FixedSizeBinary<32>;
    "receipts_root": FixedSizeBinary<32>;
    "logs_bloom": FixedSizeBinary<256>;
    "difficulty": Anonymize<I4totqt881mlti>;
    "number": Anonymize<I4totqt881mlti>;
    "gas_limit": Anonymize<I4totqt881mlti>;
    "gas_used": Anonymize<I4totqt881mlti>;
    "timestamp": bigint;
    "extra_data": Binary;
    "mix_hash": FixedSizeBinary<32>;
    "nonce": FixedSizeBinary<8>;
};
export type I1fl9qh2r1hf29 = Array<Anonymize<I6fr2mqud652ga>>;
export type I78ffku0ve5fgm = Array<Anonymize<I4v962mnhj6j6r>>;
export type Idud3fdh64aqp9 = Array<Anonymize<I87cgves5f5lsa>>;
export type Ie7atdsih6q14b = Array<Anonymize<Ifoernv5r40rfc>>;
export type I2p91o4c53gcqm = Array<({
    "maybe_id"?: Anonymize<I4s6vifaf8k998>;
    "priority": number;
    "call": PreimagesBounded;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "origin": Anonymize<I194p56vr9l05u>;
}) | undefined>;
export type I194p56vr9l05u = AnonymousEnum<{
    "system": Enum<{
        "Root": undefined;
        "Signed": HexString;
        "None": undefined;
    }>;
    "Ethereum": Anonymize<I9hp9au9bfqil7>;
    "Origins": Enum<{
        "WhitelistedCaller": undefined;
        "GeneralAdmin": undefined;
        "ReferendumCanceller": undefined;
        "ReferendumKiller": undefined;
        "FastGeneralAdmin": undefined;
    }>;
    "TreasuryCouncilCollective": Enum<{
        "Members": Anonymize<I9jd27rnpm8ttv>;
        "Member": HexString;
        "_Phantom": undefined;
    }>;
    "OpenTechCommitteeCollective": Enum<{
        "Members": Anonymize<I9jd27rnpm8ttv>;
        "Member": HexString;
        "_Phantom": undefined;
    }>;
    "CumulusXcm": Anonymize<I3in0d0lb61qi8>;
    "PolkadotXcm": Anonymize<Icvilmd7qu30i4>;
    "EthereumXcm": Enum<{
        "XcmEthereumTransaction": FixedSizeBinary<20>;
    }>;
}>;
export type I9hp9au9bfqil7 = AnonymousEnum<{
    "EthereumTransaction": FixedSizeBinary<20>;
}>;
export type I3in0d0lb61qi8 = AnonymousEnum<{
    "Relay": undefined;
    "SiblingParachain": number;
}>;
export type Ib2al60cdrpa3j = AnonymousEnum<{
    "Unrequested": {
        "deposit": Anonymize<Ic2o7gh4sgom1k>;
        "len": number;
    };
    "Requested": {
        "deposit"?: Anonymize<Ibhu2tj2t850jp>;
        "count": number;
        "len"?: Anonymize<I4arjljr6dpflb>;
    };
}>;
export type Ibhu2tj2t850jp = (Anonymize<Ic2o7gh4sgom1k>) | undefined;
export type I1o0pm60kdcf2f = AnonymousEnum<{
    "Unrequested": {
        "ticket": Anonymize<Ic2o7gh4sgom1k>;
        "len": number;
    };
    "Requested": {
        "maybe_ticket"?: Anonymize<Ibhu2tj2t850jp>;
        "count": number;
        "maybe_len"?: Anonymize<I4arjljr6dpflb>;
    };
}>;
export type Iab4eusbjjnf3n = AnonymousEnum<{
    "Casting": Anonymize<If52hjr5c5nrc5>;
    "Delegating": {
        "balance": bigint;
        "target": HexString;
        "conviction": VotingConviction;
        "delegations": Anonymize<I538qha8r4j3ii>;
        "prior": Anonymize<I4ojmnsk1dchql>;
    };
}>;
export type I5isiedqd5giej = [HexString, number];
export type I6f39mehvlsbu3 = AnonymousEnum<{
    "Ongoing": {
        "track": number;
        "origin": Anonymize<I194p56vr9l05u>;
        "proposal": PreimagesBounded;
        "enactment": TraitsScheduleDispatchTime;
        "submitted": number;
        "submission_deposit": Anonymize<Ibnba9cres7tu>;
        "decision_deposit"?: Anonymize<I9hmjujck9mi05>;
        "deciding"?: Anonymize<Ibcbcndfmk0jd9>;
        "tally": Anonymize<Ifsk7cbmtit1jd>;
        "in_queue": boolean;
        "alarm"?: Anonymize<I3aj03qk2o5mdm>;
    };
    "Approved": [number, Anonymize<I9hmjujck9mi05>, Anonymize<I9hmjujck9mi05>];
    "Rejected": [number, Anonymize<I9hmjujck9mi05>, Anonymize<I9hmjujck9mi05>];
    "Cancelled": [number, Anonymize<I9hmjujck9mi05>, Anonymize<I9hmjujck9mi05>];
    "TimedOut": [number, Anonymize<I9hmjujck9mi05>, Anonymize<I9hmjujck9mi05>];
    "Killed": number;
}>;
export type I9hmjujck9mi05 = (Anonymize<Ibnba9cres7tu>) | undefined;
export type Iaqmpqm6nl9dad = AnonymousEnum<{
    "System": Anonymize<Iekve0i6djpd9f>;
    "ParachainSystem": Anonymize<I5kev21p7u6ajb>;
    "Timestamp": Anonymize<I7d75gqfg6jh9c>;
    "RootTesting": Anonymize<I9rkc7eqejp3rj>;
    "Balances": Anonymize<Ifm98jp4vtccsq>;
    "ParachainStaking": Anonymize<Idu6heimvkd805>;
    "AuthorInherent": Anonymize<I1vdp73rdcroud>;
    "AuthorFilter": Anonymize<I2m3qdfrqq2qj>;
    "AuthorMapping": Anonymize<I8vu3qsdem5qr2>;
    "MoonbeamOrbiters": Anonymize<Ibin6kfde1ftud>;
    "Utility": Anonymize<I3a86sj5dfib4d>;
    "Proxy": Anonymize<Ie8d3dcdalu0ip>;
    "MaintenanceMode": Anonymize<Iesemqgoh8ej0v>;
    "Identity": Anonymize<Ibkfv47jfkh415>;
    "Multisig": Anonymize<I6a9d6v2a6qk64>;
    "MoonbeamLazyMigrations": Anonymize<I3u975nn4nff9q>;
    "Parameters": Anonymize<I3i81ot31v7g9a>;
    "EVM": Anonymize<I8s4v176jtv80g>;
    "Ethereum": Anonymize<Icu3fce0sripq4>;
    "Scheduler": Anonymize<I7dp5fb6elh2oq>;
    "Preimage": Anonymize<If81ks88t5mpk5>;
    "ConvictionVoting": Anonymize<I3c37mfnksisj9>;
    "Referenda": Anonymize<Ibt7qhcioqag57>;
    "Whitelist": Anonymize<I80khnjgmmkujf>;
    "TreasuryCouncilCollective": Anonymize<I3ktp4be83lvdm>;
    "OpenTechCommitteeCollective": Anonymize<I3ktp4be83lvdm>;
    "Treasury": Anonymize<Inqrm3l0miuk9>;
    "CrowdloanRewards": Anonymize<I21704cbi8dm12>;
    "PolkadotXcm": Anonymize<I4up31a3q8cjhp>;
    "Assets": Anonymize<I466l683977fg>;
    "AssetManager": Anonymize<I7d8mct7rtjkvk>;
    "XcmTransactor": Anonymize<I9v0cfv3gker3l>;
    "EthereumXcm": Anonymize<I6dhat5sf4f153>;
    "MessageQueue": Anonymize<Ic2uoe7jdksosp>;
    "EvmForeignAssets": Anonymize<I8miimbh35a69d>;
    "XcmWeightTrader": Anonymize<Ieg97aick2i3ho>;
    "EmergencyParaXcm": Anonymize<I64di64n316ddk>;
    "MultiBlockMigrations": Anonymize<I4oqb168b2d4er>;
    "Randomness": Anonymize<I7dmdeiskpd2o4>;
    "BridgeKusamaGrandpa": Anonymize<Iduejesjmcrd2r>;
    "BridgeKusamaParachains": Anonymize<I8627pri32v47a>;
    "BridgeKusamaMessages": Anonymize<Ia0ligqt4gcemj>;
    "BridgeXcmOverMoonriver": Anonymize<If9k2qtlkesr5u>;
}>;
export type I5kev21p7u6ajb = AnonymousEnum<{
    /**
     * Set the current validation data.
     *
     * This should be invoked exactly once per block. It will panic at the finalization
     * phase if the call was not invoked.
     *
     * The dispatch origin for this call must be `Inherent`
     *
     * As a side effect, this function upgrades the current validation function
     * if the appropriate time has come.
     */
    "set_validation_data": Anonymize<I60v7bikk54tpu>;
    "sudo_send_upward_message": Anonymize<Ifpj261e8s63m3>;
}>;
export type I60v7bikk54tpu = {
    "data": {
        "validation_data": Anonymize<Ifn6q3equiq9qi>;
        "relay_chain_state": Anonymize<Itom7fk49o0c9>;
        "downward_messages": Anonymize<I6ljjd4b5fa4ov>;
        "horizontal_messages": Anonymize<I2pf0b05mc7sdr>;
    };
};
export type Ifpj261e8s63m3 = {
    "message": Binary;
};
export type I9rkc7eqejp3rj = AnonymousEnum<{
    /**
     * A dispatch that will fill the block weight up to the given ratio.
     */
    "fill_block": Anonymize<Ienjibnb78vnl0>;
    "trigger_defensive": undefined;
}>;
export type Ienjibnb78vnl0 = {
    "ratio": number;
};
export type Ifm98jp4vtccsq = AnonymousEnum<{
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     */
    "transfer_allow_death": Anonymize<Ibt8o5hb5hjbe0>;
    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     */
    "force_transfer": Anonymize<I6emd42ofsah91>;
    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     */
    "transfer_keep_alive": Anonymize<Ibt8o5hb5hjbe0>;
    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     */
    "transfer_all": Anonymize<I69gs3ob8t125g>;
    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     */
    "force_unreserve": Anonymize<Ibnba9cres7tu>;
    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     */
    "upgrade_accounts": Anonymize<If07oirptjds1e>;
    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     */
    "force_set_balance": Anonymize<I86uimfcgksrk4>;
    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     */
    "force_adjust_total_issuance": Anonymize<I5u8olqbbvfnvf>;
    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     */
    "burn": Anonymize<I5utcetro501ir>;
}>;
export type Ibt8o5hb5hjbe0 = {
    "dest": HexString;
    "value": bigint;
};
export type I6emd42ofsah91 = {
    "source": HexString;
    "dest": HexString;
    "value": bigint;
};
export type I69gs3ob8t125g = {
    "dest": HexString;
    "keep_alive": boolean;
};
export type If07oirptjds1e = {
    "who": Anonymize<I55luuvb7oq2a3>;
};
export type I86uimfcgksrk4 = {
    "who": HexString;
    "new_free": bigint;
};
export type Idu6heimvkd805 = AnonymousEnum<{
    /**
     * Set the expectations for total staked. These expectations determine the issuance for
     * the round according to logic in `fn compute_issuance`
     */
    "set_staking_expectations": Anonymize<I6m4od67mjs4l8>;
    /**
     * Set the annual inflation rate to derive per-round inflation
     */
    "set_inflation": Anonymize<I19e29tp35ff1j>;
    /**
     * Deprecated: please use `set_inflation_distribution_config` instead.
     *
     * Set the account that will hold funds set aside for parachain bond
     */
    "set_parachain_bond_account": Anonymize<I1h1ih5obm3cs>;
    /**
     * Deprecated: please use `set_inflation_distribution_config` instead.
     *
     * Set the percent of inflation set aside for parachain bond
     */
    "set_parachain_bond_reserve_percent": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the total number of collator candidates selected per round
     * - changes are not applied until the start of the next round
     */
    "set_total_selected": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the commission for all collators
     */
    "set_collator_commission": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set blocks per round
     * - if called with `new` less than length of current round, will transition immediately
     * in the next block
     * - also updates per-round inflation config
     */
    "set_blocks_per_round": Anonymize<I3vh014cqgmrfd>;
    /**
     * Join the set of collator candidates
     */
    "join_candidates": Anonymize<I4vasl07tasls>;
    /**
     * Request to leave the set of candidates. If successful, the account is immediately
     * removed from the candidate pool to prevent selection as a collator.
     */
    "schedule_leave_candidates": Anonymize<I98vh5ccjtf1ev>;
    /**
     * Execute leave candidates request
     */
    "execute_leave_candidates": Anonymize<I5ulcu9n58tsgp>;
    /**
     * Cancel open request to leave candidates
     * - only callable by collator account
     * - result upon successful call is the candidate is active in the candidate pool
     */
    "cancel_leave_candidates": Anonymize<I98vh5ccjtf1ev>;
    /**
     * Temporarily leave the set of collator candidates without unbonding
     */
    "go_offline": undefined;
    /**
     * Rejoin the set of collator candidates if previously had called `go_offline`
     */
    "go_online": undefined;
    /**
     * Increase collator candidate self bond by `more`
     */
    "candidate_bond_more": Anonymize<Ievnk06j48hi6e>;
    /**
     * Request by collator candidate to decrease self bond by `less`
     */
    "schedule_candidate_bond_less": Anonymize<Ibrbas2gu3j75d>;
    /**
     * Execute pending request to adjust the collator candidate self bond
     */
    "execute_candidate_bond_less": Anonymize<Ifcg60143soedq>;
    /**
     * Cancel pending request to adjust the collator candidate self bond
     */
    "cancel_candidate_bond_less": undefined;
    /**
     * If caller is not a delegator and not a collator, then join the set of delegators
     * If caller is a delegator, then makes delegation to change their delegation state
     * Sets the auto-compound config for the delegation
     */
    "delegate_with_auto_compound": Anonymize<I1jkfh0p9s7jk5>;
    /**
     * Request to revoke an existing delegation. If successful, the delegation is scheduled
     * to be allowed to be revoked via the `execute_delegation_request` extrinsic.
     * The delegation receives no rewards for the rounds while a revoke is pending.
     * A revoke may not be performed if any other scheduled request is pending.
     */
    "schedule_revoke_delegation": Anonymize<I5ib1pr87frhq4>;
    /**
     * Bond more for delegators wrt a specific collator candidate.
     */
    "delegator_bond_more": Anonymize<I5in2p1j2slcin>;
    /**
     * Request bond less for delegators wrt a specific collator candidate. The delegation's
     * rewards for rounds while the request is pending use the reduced bonded amount.
     * A bond less may not be performed if any other scheduled request is pending.
     */
    "schedule_delegator_bond_less": Anonymize<I80codtbn0f4cb>;
    /**
     * Execute pending request to change an existing delegation
     */
    "execute_delegation_request": Anonymize<Icelrbjjshs48m>;
    /**
     * Cancel request to change an existing delegation.
     */
    "cancel_delegation_request": Anonymize<Ifcg60143soedq>;
    /**
     * Sets the auto-compounding reward percentage for a delegation.
     */
    "set_auto_compound": Anonymize<I8af27or8sm75g>;
    /**
     * Hotfix to remove existing empty entries for candidates that have left.
     */
    "hotfix_remove_delegation_requests_exited_candidates": Anonymize<I6k6pg4oqio6oi>;
    /**
     * Notify a collator is inactive during MaxOfflineRounds
     */
    "notify_inactive_collator": Anonymize<I5ib1pr87frhq4>;
    /**
     * Enable/Disable marking offline feature
     */
    "enable_marking_offline": Anonymize<I9g0k5dg67b5dd>;
    /**
     * Force join the set of collator candidates.
     * It will skip the minimum required bond check.
     */
    "force_join_candidates": Anonymize<Iejqbff9jjd9h3>;
    /**
     * Set the inflation distribution configuration.
     */
    "set_inflation_distribution_config": Anonymize<Id6m22i33hbgnr>;
}>;
export type I6m4od67mjs4l8 = {
    "expectations": Anonymize<I75misot8iv5e8>;
};
export type I19e29tp35ff1j = {
    "schedule": Anonymize<Ifcbg4i4r2gomt>;
};
export type I1h1ih5obm3cs = {
    "new": HexString;
};
export type I4vasl07tasls = {
    "bond": bigint;
    "candidate_count": number;
};
export type I98vh5ccjtf1ev = {
    "candidate_count": number;
};
export type I5ulcu9n58tsgp = {
    "candidate": HexString;
    "candidate_delegation_count": number;
};
export type Ievnk06j48hi6e = {
    "more": bigint;
};
export type Ibrbas2gu3j75d = {
    "less": bigint;
};
export type I1jkfh0p9s7jk5 = {
    "candidate": HexString;
    "amount": bigint;
    "auto_compound": number;
    "candidate_delegation_count": number;
    "candidate_auto_compounding_delegation_count": number;
    "delegation_count": number;
};
export type I5ib1pr87frhq4 = {
    "collator": HexString;
};
export type I5in2p1j2slcin = {
    "candidate": HexString;
    "more": bigint;
};
export type I80codtbn0f4cb = {
    "candidate": HexString;
    "less": bigint;
};
export type Icelrbjjshs48m = {
    "delegator": HexString;
    "candidate": HexString;
};
export type I8af27or8sm75g = {
    "candidate": HexString;
    "value": number;
    "candidate_auto_compounding_delegation_count_hint": number;
    "delegation_count_hint": number;
};
export type I6k6pg4oqio6oi = {
    "candidates": Anonymize<I55luuvb7oq2a3>;
};
export type I9g0k5dg67b5dd = {
    "value": boolean;
};
export type Iejqbff9jjd9h3 = {
    "account": HexString;
    "bond": bigint;
    "candidate_count": number;
};
export type Id6m22i33hbgnr = {
    "new": Anonymize<I35tvldomfrgo6>;
};
export type I1vdp73rdcroud = AnonymousEnum<{
    /**
     * This inherent is a workaround to run code after the "real" inherents have executed,
     * but before transactions are executed.
     */
    "kick_off_authorship_validation": undefined;
}>;
export type I2m3qdfrqq2qj = AnonymousEnum<{
    /**
     * Update the eligible count. Intended to be called by governance.
     */
    "set_eligible": Anonymize<I3vh014cqgmrfd>;
}>;
export type I8vu3qsdem5qr2 = AnonymousEnum<{
    /**
     * Register your NimbusId onchain so blocks you author are associated with your account.
     *
     * Users who have been (or will soon be) elected active collators in staking,
     * should submit this extrinsic to have their blocks accepted and earn rewards.
     */
    "add_association": Anonymize<I6gquroigvp00t>;
    /**
     * Change your Mapping.
     *
     * This is useful for normal key rotation or for when switching from one physical collator
     * machine to another. No new security deposit is required.
     * This sets keys to new_nimbus_id.into() by default.
     */
    "update_association": Anonymize<Iarl2feri6t3b9>;
    /**
     * Clear your Mapping.
     *
     * This is useful when you are no longer an author and would like to re-claim your security
     * deposit.
     */
    "clear_association": Anonymize<I6gquroigvp00t>;
    /**
     * Remove your Mapping.
     *
     * This is useful when you are no longer an author and would like to re-claim your security
     * deposit.
     */
    "remove_keys": undefined;
    /**
     * Set association and session keys at once.
     *
     * This is useful for key rotation to update Nimbus and VRF keys in one call.
     * No new security deposit is required. Will replace `update_association` which is kept
     * now for backwards compatibility reasons.
     */
    "set_keys": Anonymize<I70etqpqbirlcf>;
}>;
export type I6gquroigvp00t = {
    "nimbus_id": FixedSizeBinary<32>;
};
export type Iarl2feri6t3b9 = {
    "old_nimbus_id": FixedSizeBinary<32>;
    "new_nimbus_id": FixedSizeBinary<32>;
};
export type I70etqpqbirlcf = {
    "keys": Binary;
};
export type Ibin6kfde1ftud = AnonymousEnum<{
    /**
     * Add an orbiter in a collator pool
     */
    "collator_add_orbiter": Anonymize<Ic2l2vequpbumk>;
    /**
     * Remove an orbiter from the caller collator pool
     */
    "collator_remove_orbiter": Anonymize<Ic2l2vequpbumk>;
    /**
     * Remove the caller from the specified collator pool
     */
    "orbiter_leave_collator_pool": Anonymize<I5ib1pr87frhq4>;
    /**
     * Registering as an orbiter
     */
    "orbiter_register": undefined;
    /**
     * Deregistering from orbiters
     */
    "orbiter_unregister": Anonymize<If4amksile11f8>;
    /**
     * Add a collator to orbiters program.
     */
    "add_collator": Anonymize<I5ib1pr87frhq4>;
    /**
     * Remove a collator from orbiters program.
     */
    "remove_collator": Anonymize<I5ib1pr87frhq4>;
}>;
export type Ic2l2vequpbumk = {
    "orbiter": HexString;
};
export type If4amksile11f8 = {
    "collators_pool_count": number;
};
export type I3a86sj5dfib4d = AnonymousEnum<{
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    "batch": Anonymize<Ib8en2d082q0uj>;
    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     */
    "as_derivative": Anonymize<I3h01on2mas005>;
    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    "batch_all": Anonymize<Ib8en2d082q0uj>;
    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     */
    "dispatch_as": Anonymize<Ib9331h90g5b7e>;
    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    "force_batch": Anonymize<Ib8en2d082q0uj>;
    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     */
    "with_weight": Anonymize<I70t72khole5qd>;
}>;
export type Ib8en2d082q0uj = {
    "calls": Array<TxCallData>;
};
export type I3h01on2mas005 = {
    "index": number;
    "call": TxCallData;
};
export type Ib9331h90g5b7e = {
    "as_origin": Anonymize<I194p56vr9l05u>;
    "call": TxCallData;
};
export type I70t72khole5qd = {
    "call": TxCallData;
    "weight": Anonymize<I4q39t5hn830vp>;
};
export type Ie8d3dcdalu0ip = AnonymousEnum<{
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    "proxy": Anonymize<Ibup5hc9m4kv4l>;
    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     */
    "add_proxy": Anonymize<Io22o6h1g8ak4>;
    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     */
    "remove_proxy": Anonymize<Io22o6h1g8ak4>;
    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     */
    "remove_proxies": undefined;
    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     */
    "create_pure": Anonymize<Iavauuvpf6t3di>;
    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     */
    "kill_pure": Anonymize<Idffocn2l23ful>;
    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    "announce": Anonymize<I87r60dm6orh5i>;
    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    "remove_announcement": Anonymize<I87r60dm6orh5i>;
    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     */
    "reject_announcement": Anonymize<Iehj01u80rci5u>;
    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    "proxy_announced": Anonymize<I13jnl8irgeqkf>;
}>;
export type Ibup5hc9m4kv4l = {
    "real": HexString;
    "force_proxy_type"?: Anonymize<Idm815cukrjhah>;
    "call": TxCallData;
};
export type Idm815cukrjhah = (Anonymize<Ifmiop0mj0oacq>) | undefined;
export type Iavauuvpf6t3di = {
    "proxy_type": Anonymize<Ifmiop0mj0oacq>;
    "delay": number;
    "index": number;
};
export type Idffocn2l23ful = {
    "spawner": HexString;
    "proxy_type": Anonymize<Ifmiop0mj0oacq>;
    "index": number;
    "height": number;
    "ext_index": number;
};
export type I87r60dm6orh5i = {
    "real": HexString;
    "call_hash": FixedSizeBinary<32>;
};
export type Iehj01u80rci5u = {
    "delegate": HexString;
    "call_hash": FixedSizeBinary<32>;
};
export type I13jnl8irgeqkf = {
    "delegate": HexString;
    "real": HexString;
    "force_proxy_type"?: Anonymize<Idm815cukrjhah>;
    "call": TxCallData;
};
export type Iesemqgoh8ej0v = AnonymousEnum<{
    /**
     * Place the chain in maintenance mode
     *
     * Weight cost is:
     * * One DB read to ensure we're not already in maintenance mode
     * * Three DB writes - 1 for the mode, 1 for suspending xcm execution, 1 for the event
     */
    "enter_maintenance_mode": undefined;
    /**
     * Return the chain to normal operating mode
     *
     * Weight cost is:
     * * One DB read to ensure we're in maintenance mode
     * * Three DB writes - 1 for the mode, 1 for resuming xcm execution, 1 for the event
     */
    "resume_normal_operation": undefined;
}>;
export type Ibkfv47jfkh415 = AnonymousEnum<{
    /**
     * Add a registrar to the system.
     *
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     *
     * - `account`: the account of the registrar.
     *
     * Emits `RegistrarAdded` if successful.
     */
    "add_registrar": Anonymize<I64i34r0tn439a>;
    /**
     * Set an account's identity information and reserve the appropriate deposit.
     *
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `info`: The identity information.
     *
     * Emits `IdentitySet` if successful.
     */
    "set_identity": Anonymize<I2kds5jji7slh8>;
    /**
     * Set the sub-accounts of the sender.
     *
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * - `subs`: The identity's (new) sub-accounts.
     */
    "set_subs": Anonymize<I53ptv16c5mql7>;
    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     *
     * Payment: All reserved balances on the account are returned.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * Emits `IdentityCleared` if successful.
     */
    "clear_identity": undefined;
    /**
     * Request a judgement from a registrar.
     *
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     *
     * ```nocompile
     * Registrars::<T>::get().get(reg_index).unwrap().fee
     * ```
     *
     * Emits `JudgementRequested` if successful.
     */
    "request_judgement": Anonymize<I9l2s4klu0831o>;
    /**
     * Cancel a previous request.
     *
     * Payment: A previously reserved deposit is returned on success.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     *
     * Emits `JudgementUnrequested` if successful.
     */
    "cancel_request": Anonymize<I2ctrt5nqb8o7c>;
    /**
     * Set the fee required for a judgement to be requested from a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     */
    "set_fee": Anonymize<I711qahikocb1c>;
    /**
     * Change the account associated with a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     */
    "set_account_id": Anonymize<If885dhtb970mp>;
    /**
     * Set the field information for a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     */
    "set_fields": Anonymize<Id6gojh30v9ib2>;
    /**
     * Provide a judgement for an account's identity.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     *
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
     * provided.
     *
     * Note: Judgements do not apply to a username.
     *
     * Emits `JudgementGiven` if successful.
     */
    "provide_judgement": Anonymize<Iess0pqcp8gkv8>;
    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     *
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     *
     * Emits `IdentityKilled` if successful.
     */
    "kill_identity": Anonymize<Ibfkgq22t8bv8o>;
    /**
     * Add the given account to the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    "add_sub": Anonymize<I22bk115c518rb>;
    /**
     * Alter the associated name of the given sub-account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    "rename_sub": Anonymize<I22bk115c518rb>;
    /**
     * Remove the given account from the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    "remove_sub": Anonymize<I25koabvo0egr8>;
    /**
     * Remove the sender as a sub-account.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     *
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     */
    "quit_sub": undefined;
    /**
     * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
     *
     * The authority can grant up to `allocation` usernames. To top up the allocation or
     * change the account used to grant usernames, this call can be used with the updated
     * parameters to overwrite the existing configuration.
     */
    "add_username_authority": Anonymize<Icq68a2na3ck8n>;
    /**
     * Remove `authority` from the username authorities.
     */
    "remove_username_authority": Anonymize<I540aqt3mhve7m>;
    /**
     * Set the username for `who`. Must be called by a username authority.
     *
     * If `use_allocation` is set, the authority must have a username allocation available to
     * spend. Otherwise, the authority will need to put up a deposit for registering the
     * username.
     *
     * Users can either pre-sign their usernames or
     * accept them later.
     *
     * Usernames must:
     * - Only contain lowercase ASCII characters or digits.
     * - When combined with the suffix of the issuing authority be _less than_ the
     * `MaxUsernameLength`.
     */
    "set_username_for": Anonymize<I1psn9kso0ag4m>;
    /**
     * Accept a given username that an `authority` granted. The call must include the full
     * username, as in `username.suffix`.
     */
    "accept_username": Anonymize<Ie5l999tf7t2te>;
    /**
     * Remove an expired username approval. The username was approved by an authority but never
     * accepted by the user and must now be beyond its expiration. The call must include the
     * full username, as in `username.suffix`.
     */
    "remove_expired_approval": Anonymize<Ie5l999tf7t2te>;
    /**
     * Set a given username as the primary. The username should include the suffix.
     */
    "set_primary_username": Anonymize<Ie5l999tf7t2te>;
    /**
     * Start the process of removing a username by placing it in the unbinding usernames map.
     * Once the grace period has passed, the username can be deleted by calling
     * [remove_username](crate::Call::remove_username).
     */
    "unbind_username": Anonymize<Ie5l999tf7t2te>;
    /**
     * Permanently delete a username which has been unbinding for longer than the grace period.
     * Caller is refunded the fee if the username expired and the removal was successful.
     */
    "remove_username": Anonymize<Ie5l999tf7t2te>;
    /**
     * Call with [ForceOrigin](crate::Config::ForceOrigin) privileges which deletes a username
     * and slashes any deposit associated with it.
     */
    "kill_username": Anonymize<Ie5l999tf7t2te>;
}>;
export type I2kds5jji7slh8 = {
    "info": Anonymize<I1o57snqt6f4v5>;
};
export type I53ptv16c5mql7 = {
    "subs": Array<Anonymize<Ic42splpg0rgdk>>;
};
export type I9l2s4klu0831o = {
    "reg_index": number;
    "max_fee": bigint;
};
export type I2ctrt5nqb8o7c = {
    "reg_index": number;
};
export type I711qahikocb1c = {
    "index": number;
    "fee": bigint;
};
export type If885dhtb970mp = {
    "index": number;
    "new": HexString;
};
export type Id6gojh30v9ib2 = {
    "index": number;
    "fields": bigint;
};
export type Iess0pqcp8gkv8 = {
    "reg_index": number;
    "target": HexString;
    "judgement": IdentityJudgement;
    "identity": FixedSizeBinary<32>;
};
export type Ibfkgq22t8bv8o = {
    "target": HexString;
};
export type I22bk115c518rb = {
    "sub": HexString;
    "data": IdentityData;
};
export type I25koabvo0egr8 = {
    "sub": HexString;
};
export type Icq68a2na3ck8n = {
    "authority": HexString;
    "suffix": Binary;
    "allocation": number;
};
export type I540aqt3mhve7m = {
    "suffix": Binary;
    "authority": HexString;
};
export type I1psn9kso0ag4m = {
    "who": HexString;
    "username": Binary;
    "signature"?: (FixedSizeBinary<65>) | undefined;
    "use_allocation": boolean;
};
export type I6a9d6v2a6qk64 = AnonymousEnum<{
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    "as_multi_threshold_1": Anonymize<I5i8muthp7fh92>;
    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    "as_multi": Anonymize<Ibdpqtl9rd54ba>;
    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    "approve_as_multi": Anonymize<I7brssfgjtq1ru>;
    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     */
    "cancel_as_multi": Anonymize<Icg7jk7nhmoong>;
}>;
export type I5i8muthp7fh92 = {
    "other_signatories": Anonymize<I55luuvb7oq2a3>;
    "call": TxCallData;
};
export type Ibdpqtl9rd54ba = {
    "threshold": number;
    "other_signatories": Anonymize<I55luuvb7oq2a3>;
    "maybe_timepoint"?: Anonymize<I95jfd8j5cr5eh>;
    "call": TxCallData;
    "max_weight": Anonymize<I4q39t5hn830vp>;
};
export type I7brssfgjtq1ru = {
    "threshold": number;
    "other_signatories": Anonymize<I55luuvb7oq2a3>;
    "maybe_timepoint"?: Anonymize<I95jfd8j5cr5eh>;
    "call_hash": FixedSizeBinary<32>;
    "max_weight": Anonymize<I4q39t5hn830vp>;
};
export type Icg7jk7nhmoong = {
    "threshold": number;
    "other_signatories": Anonymize<I55luuvb7oq2a3>;
    "timepoint": Anonymize<Itvprrpb0nm3o>;
    "call_hash": FixedSizeBinary<32>;
};
export type I3u975nn4nff9q = AnonymousEnum<{
    "create_contract_metadata": Anonymize<Itmchvgqfl28g>;
}>;
export type I3i81ot31v7g9a = AnonymousEnum<{
    /**
     * Set the value of a parameter.
     *
     * The dispatch origin of this call must be `AdminOrigin` for the given `key`. Values be
     * deleted by setting them to `None`.
     */
    "set_parameter": Anonymize<Ic6v0pfadj60db>;
}>;
export type Ic6v0pfadj60db = {
    "key_value": Enum<{
        "RuntimeConfig": Enum<{
            "FeesTreasuryProportion": Anonymize<Idqsmalvqe2q98>;
        }>;
        "PalletRandomness": Enum<{
            "Deposit": Anonymize<Ia023ofm66k1pj>;
        }>;
        "XcmConfig": Enum<{
            "ForeignAssetCreationDeposit": Anonymize<Ia023ofm66k1pj>;
        }>;
    }>;
};
export type Idqsmalvqe2q98 = FixedSizeArray<1, Anonymize<I4arjljr6dpflb>>;
export type Ia023ofm66k1pj = FixedSizeArray<1, Anonymize<I35p85j063s0il>>;
export type I8s4v176jtv80g = AnonymousEnum<{
    /**
     * Withdraw balance from EVM into currency/balances pallet.
     */
    "withdraw": Anonymize<Idcabvplu05lea>;
    /**
     * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
     */
    "call": Anonymize<I2ncccle6pmhd9>;
    /**
     * Issue an EVM create operation. This is similar to a contract creation transaction in
     * Ethereum.
     */
    "create": Anonymize<I92bnd3pe0civj>;
    /**
     * Issue an EVM create2 operation.
     */
    "create2": Anonymize<Ic84i538n8bl8j>;
}>;
export type Idcabvplu05lea = {
    "address": FixedSizeBinary<20>;
    "value": bigint;
};
export type I2ncccle6pmhd9 = {
    "source": FixedSizeBinary<20>;
    "target": FixedSizeBinary<20>;
    "input": Binary;
    "value": Anonymize<I4totqt881mlti>;
    "gas_limit": bigint;
    "max_fee_per_gas": Anonymize<I4totqt881mlti>;
    "max_priority_fee_per_gas"?: Anonymize<Ic4rgfgksgmm3e>;
    "nonce"?: Anonymize<Ic4rgfgksgmm3e>;
    "access_list": Anonymize<I1bsfec060j604>;
};
export type Ic4rgfgksgmm3e = (Anonymize<I4totqt881mlti>) | undefined;
export type I1bsfec060j604 = Array<[FixedSizeBinary<20>, Anonymize<Ic5m5lp1oioo8r>]>;
export type I92bnd3pe0civj = {
    "source": FixedSizeBinary<20>;
    "init": Binary;
    "value": Anonymize<I4totqt881mlti>;
    "gas_limit": bigint;
    "max_fee_per_gas": Anonymize<I4totqt881mlti>;
    "max_priority_fee_per_gas"?: Anonymize<Ic4rgfgksgmm3e>;
    "nonce"?: Anonymize<Ic4rgfgksgmm3e>;
    "access_list": Anonymize<I1bsfec060j604>;
};
export type Ic84i538n8bl8j = {
    "source": FixedSizeBinary<20>;
    "init": Binary;
    "salt": FixedSizeBinary<32>;
    "value": Anonymize<I4totqt881mlti>;
    "gas_limit": bigint;
    "max_fee_per_gas": Anonymize<I4totqt881mlti>;
    "max_priority_fee_per_gas"?: Anonymize<Ic4rgfgksgmm3e>;
    "nonce"?: Anonymize<Ic4rgfgksgmm3e>;
    "access_list": Anonymize<I1bsfec060j604>;
};
export type Icu3fce0sripq4 = AnonymousEnum<{
    /**
     * Transact an Ethereum transaction.
     */
    "transact": Anonymize<Ia8ogbeici6lip>;
}>;
export type Ia8ogbeici6lip = {
    "transaction": Anonymize<I6fr2mqud652ga>;
};
export type I7dp5fb6elh2oq = AnonymousEnum<{
    /**
     * Anonymously schedule a task.
     */
    "schedule": Anonymize<I3rugmro417cu2>;
    /**
     * Cancel an anonymously scheduled task.
     */
    "cancel": Anonymize<I5n4sebgkfr760>;
    /**
     * Schedule a named task.
     */
    "schedule_named": Anonymize<I3uta02p49metg>;
    /**
     * Cancel a named scheduled task.
     */
    "cancel_named": Anonymize<Ifs1i5fk9cqvr6>;
    /**
     * Anonymously schedule a task after a delay.
     */
    "schedule_after": Anonymize<I40fcd8ps9ksvh>;
    /**
     * Schedule a named task after a delay.
     */
    "schedule_named_after": Anonymize<Ie5p66h8puh1a7>;
    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     */
    "set_retry": Anonymize<Ieg3fd8p4pkt10>;
    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     */
    "set_retry_named": Anonymize<I8kg5ll427kfqq>;
    /**
     * Removes the retry configuration of a task.
     */
    "cancel_retry": Anonymize<I467333262q1l9>;
    /**
     * Cancel the retry configuration of a named task.
     */
    "cancel_retry_named": Anonymize<Ifs1i5fk9cqvr6>;
}>;
export type I3rugmro417cu2 = {
    "when": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I3uta02p49metg = {
    "id": FixedSizeBinary<32>;
    "when": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I40fcd8ps9ksvh = {
    "after": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type Ie5p66h8puh1a7 = {
    "id": FixedSizeBinary<32>;
    "after": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I3c37mfnksisj9 = AnonymousEnum<{
    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     *
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     */
    "vote": Anonymize<Idnsr2pndm36h0>;
    /**
     * Delegate the voting power (with some given conviction) of the sending account for a
     * particular class of polls.
     *
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     *
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     * - be delegating already; or
     * - have no voting activity (if there is, then it will need to be removed through
     * `remove_vote`).
     *
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
     * to this function are required.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     * account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     * be more than the account's current balance.
     *
     * Emits `Delegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    "delegate": Anonymize<I355vkhso2qs3n>;
    /**
     * Undelegate the voting power of the sending account for a particular class of polls.
     *
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued has passed.
     *
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     *
     * - `class`: The class of polls to remove the delegation from.
     *
     * Emits `Undelegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    "undelegate": Anonymize<I8steo882k7qns>;
    /**
     * Remove the lock caused by prior voting/delegating which has expired within a particular
     * class.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     *
     * Weight: `O(R)` with R number of vote of target.
     */
    "unlock": Anonymize<I3ncitsp8frod4>;
    /**
     * Remove a vote for a poll.
     *
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     * - the vote of the account was in opposition to the result; or
     * - there was no conviction to the account's vote; or
     * - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     *
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     *
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     *
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     * which have finished or are cancelled, this must be `Some`.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     */
    "remove_vote": Anonymize<I5f178ab6b89t3>;
    /**
     * Remove a vote for a poll.
     *
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     * `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     */
    "remove_other_vote": Anonymize<I7qq8pedqs675e>;
}>;
export type I355vkhso2qs3n = {
    "class": number;
    "to": HexString;
    "conviction": VotingConviction;
    "balance": bigint;
};
export type I3ncitsp8frod4 = {
    "class": number;
    "target": HexString;
};
export type I7qq8pedqs675e = {
    "target": HexString;
    "class": number;
    "index": number;
};
export type Ibt7qhcioqag57 = AnonymousEnum<{
    /**
     * Propose a referendum on a privileged action.
     *
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     * available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     *
     * Emits `Submitted`.
     */
    "submit": Anonymize<I6qgv3p5m0m38b>;
    /**
     * Post the Decision Deposit for a referendum.
     *
     * - `origin`: must be `Signed` and the account must have funds available for the
     * referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     * posted.
     *
     * Emits `DecisionDepositPlaced`.
     */
    "place_decision_deposit": Anonymize<I666bl2fqjkejo>;
    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     * refunded.
     *
     * Emits `DecisionDepositRefunded`.
     */
    "refund_decision_deposit": Anonymize<I666bl2fqjkejo>;
    /**
     * Cancel an ongoing referendum.
     *
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Cancelled`.
     */
    "cancel": Anonymize<I666bl2fqjkejo>;
    /**
     * Cancel an ongoing referendum and slash the deposits.
     *
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Killed` and `DepositSlashed`.
     */
    "kill": Anonymize<I666bl2fqjkejo>;
    /**
     * Advance a referendum onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     */
    "nudge_referendum": Anonymize<I666bl2fqjkejo>;
    /**
     * Advance a track onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     *
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     */
    "one_fewer_deciding": Anonymize<Icbio0e1f0034b>;
    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     * refunded.
     *
     * Emits `SubmissionDepositRefunded`.
     */
    "refund_submission_deposit": Anonymize<I666bl2fqjkejo>;
    /**
     * Set or clear metadata of a referendum.
     *
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     * metadata of a finished referendum.
     * - `index`:  The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     */
    "set_metadata": Anonymize<I8c0vkqjjipnuj>;
}>;
export type I6qgv3p5m0m38b = {
    "proposal_origin": Anonymize<I194p56vr9l05u>;
    "proposal": PreimagesBounded;
    "enactment_moment": TraitsScheduleDispatchTime;
};
export type I80khnjgmmkujf = AnonymousEnum<{
    "whitelist_call": Anonymize<I1adbcfi5uc62r>;
    "remove_whitelisted_call": Anonymize<I1adbcfi5uc62r>;
    "dispatch_whitelisted_call": Anonymize<Ibf6ucefn8fh49>;
    "dispatch_whitelisted_call_with_preimage": Anonymize<I7f7jli6vo6drv>;
}>;
export type I7f7jli6vo6drv = {
    "call": TxCallData;
};
export type I3ktp4be83lvdm = AnonymousEnum<{
    /**
     * Set the collective's membership.
     *
     * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     * - `prime`: The prime member whose vote sets the default.
     * - `old_count`: The upper bound for the previous number of members in storage. Used for
     * weight estimation.
     *
     * The dispatch of this call must be `SetMembersOrigin`.
     *
     * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     * the weight estimations rely on it to estimate dispatchable weight.
     *
     * # WARNING:
     *
     * The `pallet-collective` can also be managed by logic outside of the pallet through the
     * implementation of the trait [`ChangeMembers`].
     * Any call to `set_members` must be careful that the member set doesn't get out of sync
     * with other logic managing the member set.
     *
     * ## Complexity:
     * - `O(MP + N)` where:
     * - `M` old-members-count (code- and governance-bounded)
     * - `N` new-members-count (code- and governance-bounded)
     * - `P` proposals-count (code-bounded)
     */
    "set_members": Anonymize<I76b4rvmflooij>;
    /**
     * Dispatch a proposal from a member using the `Member` origin.
     *
     * Origin must be a member of the collective.
     *
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    "execute": Anonymize<Idjsbeet1fe39m>;
    /**
     * Add a new proposal to either be voted on or executed directly.
     *
     * Requires the sender to be member.
     *
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     *
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - branching is influenced by `threshold` where:
     * - `P1` is proposal execution complexity (`threshold < 2`)
     * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    "propose": Anonymize<Iflbk67akqs4pf>;
    /**
     * Add an aye or nay vote for the sender to the given proposal.
     *
     * Requires the sender to be a member.
     *
     * Transaction fees will be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * ## Complexity
     * - `O(M)` where `M` is members-count (code- and governance-bounded)
     */
    "vote": Anonymize<I2dtrijkm5601t>;
    /**
     * Disapprove a proposal, close, and remove it from the system, regardless of its current
     * state.
     *
     * Must be called by the Root origin.
     *
     * Parameters:
     * * `proposal_hash`: The hash of the proposal that should be disapproved.
     *
     * ## Complexity
     * O(P) where P is the number of max proposals
     */
    "disapprove_proposal": Anonymize<I2ev73t79f46tb>;
    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     *
     * May be called by any signed account in order to finish voting and close the proposal.
     *
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     *
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     *
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     *
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     *
     * ## Complexity
     * - `O(B + M + P1 + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - `P1` is the complexity of `proposal` preimage.
     * - `P2` is proposal-count (code-bounded)
     */
    "close": Anonymize<Ib2obgji960euh>;
    /**
     * Disapprove the proposal and burn the cost held for storing this proposal.
     *
     * Parameters:
     * - `origin`: must be the `KillOrigin`.
     * - `proposal_hash`: The hash of the proposal that should be killed.
     *
     * Emits `Killed` and `ProposalCostBurned` if any cost was held for a given proposal.
     */
    "kill": Anonymize<I2ev73t79f46tb>;
    /**
     * Release the cost held for storing a proposal once the given proposal is completed.
     *
     * If there is no associated cost for the given proposal, this call will have no effect.
     *
     * Parameters:
     * - `origin`: must be `Signed` or `Root`.
     * - `proposal_hash`: The hash of the proposal.
     *
     * Emits `ProposalCostReleased` if any cost held for a given proposal.
     */
    "release_proposal_cost": Anonymize<I2ev73t79f46tb>;
}>;
export type I76b4rvmflooij = {
    "new_members": Anonymize<I55luuvb7oq2a3>;
    "prime"?: Anonymize<I36nb9b8a306lm>;
    "old_count": number;
};
export type Idjsbeet1fe39m = {
    "proposal": TxCallData;
    "length_bound": number;
};
export type Iflbk67akqs4pf = {
    "threshold": number;
    "proposal": TxCallData;
    "length_bound": number;
};
export type I2dtrijkm5601t = {
    "proposal": FixedSizeBinary<32>;
    "index": number;
    "approve": boolean;
};
export type Ib2obgji960euh = {
    "proposal_hash": FixedSizeBinary<32>;
    "index": number;
    "proposal_weight_bound": Anonymize<I4q39t5hn830vp>;
    "length_bound": number;
};
export type Inqrm3l0miuk9 = AnonymousEnum<{
    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
     *
     * ### Details
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     *
     * ### Parameters
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     *
     * ## Events
     *
     * Emits [`Event::SpendApproved`] if successful.
     */
    "spend_local": Anonymize<I6nsmehln1kagc>;
    /**
     * Force a previously approved proposal to be removed from the approval queue.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * The original deposit will no longer be returned.
     *
     * ### Parameters
     * - `proposal_id`: The index of a proposal
     *
     * ### Complexity
     * - O(A) where `A` is the number of approvals
     *
     * ### Errors
     * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
     * approval queue, i.e., the proposal has not been approved. This could also mean the
     * proposal does not exist altogether, thus there is no way it would have been approved
     * in the first place.
     */
    "remove_approval": Anonymize<Icm9m0qeemu66d>;
    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least
     * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
     * for assertion using the [`Config::BalanceConverter`].
     *
     * ## Details
     *
     * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
     * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
     * the [`Config::PayoutPeriod`].
     *
     * ### Parameters
     * - `asset_kind`: An indicator of the specific asset class to be spent.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The beneficiary of the spend.
     * - `valid_from`: The block number from which the spend can be claimed. It can refer to
     * the past if the resulting spend has not yet expired according to the
     * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
     * approval.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendApproved`] if successful.
     */
    "spend": Anonymize<I9tebiigv8mfq3>;
    /**
     * Claim a spend.
     *
     * ## Dispatch Origin
     *
     * Must be signed
     *
     * ## Details
     *
     * Spends must be claimed within some temporal bounds. A spend may be claimed within one
     * [`Config::PayoutPeriod`] from the `valid_from` block.
     * In case of a payout failure, the spend status must be updated with the `check_status`
     * dispatchable before retrying with the current function.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::Paid`] if successful.
     */
    "payout": Anonymize<I666bl2fqjkejo>;
    /**
     * Check the status of the spend and remove it from the storage if processed.
     *
     * ## Dispatch Origin
     *
     * Must be signed.
     *
     * ## Details
     *
     * The status check is a prerequisite for retrying a failed payout.
     * If a spend has either succeeded or expired, it is removed from the storage by this
     * function. In such instances, transaction fees are refunded.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::PaymentFailed`] if the spend payout has failed.
     * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
     */
    "check_status": Anonymize<I666bl2fqjkejo>;
    /**
     * Void previously approved spend.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * A spend void is only possible if the payout has not been attempted yet.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendVoided`] if successful.
     */
    "void_spend": Anonymize<I666bl2fqjkejo>;
}>;
export type I6nsmehln1kagc = {
    "amount": bigint;
    "beneficiary": HexString;
};
export type I9tebiigv8mfq3 = {
    "asset_kind": Anonymize<I8ftdv6d7go8s5>;
    "amount": bigint;
    "beneficiary": HexString;
    "valid_from"?: Anonymize<I4arjljr6dpflb>;
};
export type I21704cbi8dm12 = AnonymousEnum<{
    /**
     * Associate a native rewards_destination identity with a crowdloan contribution.
     *
     * The caller needs to provide the unassociated relay account and a proof to succeed
     * with the association
     * The proof is nothing but a signature over the reward_address using the relay keys
     */
    "associate_native_identity": Anonymize<Idnuqgq0sjkv0o>;
    /**
     * Change reward account by submitting proofs from relay accounts
     *
     * The number of valid proofs needs to be bigger than 'RewardAddressRelayVoteThreshold'
     * The account to be changed needs to be submitted as 'previous_account'
     * Origin must be RewardAddressChangeOrigin
     */
    "change_association_with_relay_keys": Anonymize<I1nl40o8rqtu3p>;
    /**
     * Collect whatever portion of your reward are currently vested.
     */
    "claim": undefined;
    /**
     * Update reward address, proving that the caller owns the current native key
     */
    "update_reward_address": Anonymize<I63sne46ecs10u>;
    /**
     * This extrinsic completes the initialization if some checks are fullfiled. These checks are:
     * -The reward contribution money matches the crowdloan pot
     * -The end vesting block is higher than the init vesting block
     * -The initialization has not complete yet
     */
    "complete_initialization": Anonymize<I90duks9ein583>;
    /**
     * Initialize the reward distribution storage. It shortcuts whenever an error is found
     * This does not enforce any checks other than making sure we dont go over funds
     * complete_initialization should perform any additional
     */
    "initialize_reward_vec": Anonymize<Ifs0pcpedmadns>;
}>;
export type Idnuqgq0sjkv0o = {
    "reward_account": HexString;
    "relay_account": FixedSizeBinary<32>;
    "proof": MultiSignature;
};
export type I1nl40o8rqtu3p = {
    "reward_account": HexString;
    "previous_account": HexString;
    "proofs": Array<[FixedSizeBinary<32>, MultiSignature]>;
};
export type I63sne46ecs10u = {
    "new_reward_account": HexString;
};
export type I90duks9ein583 = {
    "lease_ending_block": number;
};
export type Ifs0pcpedmadns = {
    "rewards": Array<Anonymize<I20nlejbovhut6>>;
};
export type I4up31a3q8cjhp = AnonymousEnum<{
    "send": Anonymize<Ia5cotcvi888ln>;
    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * **This function is deprecated: Use `limited_teleport_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     */
    "teleport_assets": Anonymize<I21jsa919m88fd>;
    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     */
    "reserve_transfer_assets": Anonymize<I21jsa919m88fd>;
    /**
     * Execute an XCM message from a local, signed, origin.
     *
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     *
     * No more than `max_weight` will be used in its attempted execution. If this is less than
     * the maximum amount of weight that the message could take to be executed, then no
     * execution attempt will be made.
     */
    "execute": Anonymize<Iegif7m3upfe1k>;
    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    "force_xcm_version": Anonymize<I9kt8c221c83ln>;
    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     */
    "force_default_xcm_version": Anonymize<Ic76kfh5ebqkpl>;
    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    "force_subscribe_version_notify": Anonymize<Icscpmubum33bq>;
    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we are currently subscribed for XCM version
     * notifications which we no longer desire.
     */
    "force_unsubscribe_version_notify": Anonymize<Icscpmubum33bq>;
    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    "limited_reserve_transfer_assets": Anonymize<I21d2olof7eb60>;
    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    "limited_teleport_assets": Anonymize<I21d2olof7eb60>;
    /**
     * Set or unset the global suspension state of the XCM executor.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     */
    "force_suspension": Anonymize<Ibgm4rnf22lal1>;
    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve, or through teleports.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
     * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
     * operation will fail and the sent assets may be at risk.
     *
     * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
     * to `dest`, no limitations imposed on `fees`.
     * - for local reserve: transfer assets to sovereign account of destination chain and
     * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
     * `beneficiary`.
     * - for destination reserve: burn local assets and forward a notification to `dest` chain
     * to withdraw the reserve assets from this chain's sovereign account and deposit them
     * to `beneficiary`.
     * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
     * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
     * and deposit reserve-based assets to `beneficiary`.
     * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
     * assets and deposit them to `beneficiary`.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
     * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
     * from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    "transfer_assets": Anonymize<I21d2olof7eb60>;
    /**
     * Claims assets trapped on this pallet because of leftover assets during XCM execution.
     *
     * - `origin`: Anyone can call this extrinsic.
     * - `assets`: The exact assets that were trapped. Use the version to specify what version
     * was the latest when they were trapped.
     * - `beneficiary`: The location/account where the claimed assets will be deposited.
     */
    "claim_assets": Anonymize<Ie68np0vpihith>;
    /**
     * Transfer assets from the local chain to the destination chain using explicit transfer
     * types for assets and fees.
     *
     * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
     * provide the `assets_transfer_type` to be used for `assets`:
     * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
     * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
     * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
     * the remote `reserve` is Asset Hub.
     * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
     * mint/teleport assets and deposit them to `beneficiary`.
     *
     * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
     * buy execution using transferred `assets` identified by `remote_fees_id`.
     * Make sure enough of the specified `remote_fees_id` asset is included in the given list
     * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * `remote_fees_id` may use different transfer type than rest of `assets` and can be
     * specified through `fees_transfer_type`.
     *
     * The caller needs to specify what should happen to the transferred assets once they reach
     * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
     * contains the instructions to execute on `dest` as a final step.
     * This is usually as simple as:
     * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
     * but could be something more exotic like sending the `assets` even further.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
     * parachain across a bridge to another ecosystem destination.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
     * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
     * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
     * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
     * transfer, which also determines what happens to the assets on the destination chain.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    "transfer_assets_using_type_and_then": Anonymize<I9bnv6lu0crf1q>;
}>;
export type I466l683977fg = AnonymousEnum<{
    /**
     * Issue a new class of fungible assets from a public origin.
     *
     * This new asset class has no assets initially and its owner is the origin.
     *
     * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
     *
     * Funds of sender are reserved by `AssetDeposit`.
     *
     * Parameters:
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `admin`: The admin of this class of assets. The admin is the initial address of each
     * member of the asset class's admin team.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `Created` event when successful.
     *
     * Weight: `O(1)`
     */
    "create": Anonymize<I6j6svr1mcma8b>;
    /**
     * Issue a new class of fungible assets from a privileged origin.
     *
     * This new asset class has no assets initially.
     *
     * The origin must conform to `ForceOrigin`.
     *
     * Unlike `create`, no funds are reserved.
     *
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `owner`: The owner of this class of assets. The owner has full superuser permissions
     * over this asset, but may later change and configure the permissions using
     * `transfer_ownership` and `set_team`.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `ForceCreated` event when successful.
     *
     * Weight: `O(1)`
     */
    "force_create": Anonymize<I4e3fcbllc550c>;
    /**
     * Start the process of destroying a fungible asset class.
     *
     * `start_destroy` is the first in a series of extrinsics that should be called, to allow
     * destruction of an asset class.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     */
    "start_destroy": Anonymize<I4ov6e94l79mbg>;
    /**
     * Destroy all accounts associated with a given asset.
     *
     * `destroy_accounts` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedAccounts` event.
     */
    "destroy_accounts": Anonymize<I4ov6e94l79mbg>;
    /**
     * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
     *
     * `destroy_approvals` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedApprovals` event.
     */
    "destroy_approvals": Anonymize<I4ov6e94l79mbg>;
    /**
     * Complete destroying asset and unreserve currency.
     *
     * `finish_destroy` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
     * hand.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each successful call emits the `Event::Destroyed` event.
     */
    "finish_destroy": Anonymize<I4ov6e94l79mbg>;
    /**
     * Mint assets of a particular class.
     *
     * The origin must be Signed and the sender must be the Issuer of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount minted.
     * - `beneficiary`: The account to be credited with the minted assets.
     * - `amount`: The amount of the asset to be minted.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
     */
    "mint": Anonymize<I91ebagm7eg2of>;
    /**
     * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
     *
     * Origin must be Signed and the sender should be the Manager of the asset `id`.
     *
     * Bails with `NoAccount` if the `who` is already dead.
     *
     * - `id`: The identifier of the asset to have some amount burned.
     * - `who`: The account to be debited from.
     * - `amount`: The maximum amount by which `who`'s balance should be reduced.
     *
     * Emits `Burned` with the actual amount burned. If this takes the balance to below the
     * minimum for the asset, then the amount burned is increased to take it to zero.
     *
     * Weight: `O(1)`
     * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
     */
    "burn": Anonymize<Idktplkgk9qubb>;
    /**
     * Move some assets from the sender account to another.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     */
    "transfer": Anonymize<I46clc78rtmjag>;
    /**
     * Move some assets from the sender account to another, keeping the sender account alive.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     */
    "transfer_keep_alive": Anonymize<I46clc78rtmjag>;
    /**
     * Move some assets from one account to another.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `source`: The account to be debited.
     * - `dest`: The account to be credited.
     * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
     * `dest`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the `source` balance above zero but
     * below the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
     * `dest`.
     */
    "force_transfer": Anonymize<Ifhl8qqlpgmrgk>;
    /**
     * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
     * must already exist as an entry in `Account`s of the asset. If you want to freeze an
     * account that does not have an entry, use `touch_other` first.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     */
    "freeze": Anonymize<Ie4fskhkb19lqm>;
    /**
     * Allow unprivileged transfers to and from an account again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be unfrozen.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     */
    "thaw": Anonymize<Ie4fskhkb19lqm>;
    /**
     * Disallow further unprivileged transfers for the asset class.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     */
    "freeze_asset": Anonymize<I4ov6e94l79mbg>;
    /**
     * Allow unprivileged transfers for the asset again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be thawed.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     */
    "thaw_asset": Anonymize<I4ov6e94l79mbg>;
    /**
     * Change the Owner of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     */
    "transfer_ownership": Anonymize<Ifv4apklf5icev>;
    /**
     * Change the Issuer, Admin and Freezer of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     *
     * Emits `TeamChanged`.
     *
     * Weight: `O(1)`
     */
    "set_team": Anonymize<I55kkfv5j6l61n>;
    /**
     * Set the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Funds of sender are reserved according to the formula:
     * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
     * account any already reserved funds.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(1)`
     */
    "set_metadata": Anonymize<I87vll2k0a91o2>;
    /**
     * Clear the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Any deposit is freed for the asset owner.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     */
    "clear_metadata": Anonymize<I4ov6e94l79mbg>;
    /**
     * Force the metadata for an asset to some value.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is left alone.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
     */
    "force_set_metadata": Anonymize<Iekaug5vo6n1jh>;
    /**
     * Clear the metadata for an asset.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is returned.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     */
    "force_clear_metadata": Anonymize<I4ov6e94l79mbg>;
    /**
     * Alter the attributes of a given asset.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
     * value to account for the state bloat associated with its balance storage. If set to
     * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
     * an ED in the Balances pallet or whatever else is used to control user-account state
     * growth).
     * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
     * instructions.
     *
     * Emits `AssetStatusChanged` with the identity of the asset.
     *
     * Weight: `O(1)`
     */
    "force_asset_status": Anonymize<I6olidsoliung0>;
    /**
     * Approve an amount of asset for transfer by a delegated third-party account.
     *
     * Origin must be Signed.
     *
     * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
     * for the purpose of holding the approval. If some non-zero amount of assets is already
     * approved from signing account to `delegate`, then it is topped up or unreserved to
     * meet the right value.
     *
     * NOTE: The signing account does not need to own `amount` of assets at the point of
     * making this call.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account to delegate permission to transfer asset.
     * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
     * already an approval in place, then this acts additively.
     *
     * Emits `ApprovedTransfer` on success.
     *
     * Weight: `O(1)`
     */
    "approve_transfer": Anonymize<I32vkhn5265cl8>;
    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be Signed and there must be an approval in place between signer and
     * `delegate`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     */
    "cancel_approval": Anonymize<I13irkvjha30nl>;
    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
     * account of the asset `id`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     */
    "force_cancel_approval": Anonymize<I4dko4hu09aovh>;
    /**
     * Transfer some asset balance from a previously delegated account to some third-party
     * account.
     *
     * Origin must be Signed and there must be an approval in place by the `owner` to the
     * signer.
     *
     * If the entire amount approved for transfer is transferred, then any deposit previously
     * reserved by `approve_transfer` is unreserved.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The account which previously approved for a transfer of at least `amount` and
     * from which the asset balance will be withdrawn.
     * - `destination`: The account to which the asset balance of `amount` will be transferred.
     * - `amount`: The amount of assets to transfer.
     *
     * Emits `TransferredApproved` on success.
     *
     * Weight: `O(1)`
     */
    "transfer_approved": Anonymize<I1he1llr4em5k8>;
    /**
     * Create an asset account for non-provider assets.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
     * to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     *
     * Emits `Touched` event when successful.
     */
    "touch": Anonymize<I4ov6e94l79mbg>;
    /**
     * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
     * account.
     *
     * The origin must be Signed.
     *
     * - `id`: The identifier of the asset for which the caller would like the deposit
     * refunded.
     * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
     *
     * Emits `Refunded` event when successful.
     */
    "refund": Anonymize<Ib98qbv23c0tst>;
    /**
     * Sets the minimum balance of an asset.
     *
     * Only works if there aren't any accounts that are holding the asset or if
     * the new value of `min_balance` is less than the old one.
     *
     * Origin must be Signed and the sender has to be the Owner of the
     * asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `min_balance`: The new value of `min_balance`.
     *
     * Emits `AssetMinBalanceChanged` event when successful.
     */
    "set_min_balance": Anonymize<Iebdnbvufodnev>;
    /**
     * Create an asset account for `who`.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
     * must have sufficient funds for a deposit to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     * - `who`: The account to be created.
     *
     * Emits `Touched` event when successful.
     */
    "touch_other": Anonymize<Ie4fskhkb19lqm>;
    /**
     * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
     *
     * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
     * order to burn a non-zero balance of the asset, the caller must be the account and should
     * use `refund`.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `who`: The account to refund.
     *
     * Emits `Refunded` event when successful.
     */
    "refund_other": Anonymize<Ie4fskhkb19lqm>;
    /**
     * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the account's asset.
     * - `who`: The account to be unblocked.
     *
     * Emits `Blocked`.
     *
     * Weight: `O(1)`
     */
    "block": Anonymize<Ie4fskhkb19lqm>;
    /**
     * Transfer the entire transferable balance from the caller asset account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any held, frozen, or minimum balance (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the asset account has, causing the sender asset account to be killed
     * (false), or transfer everything except at least the minimum balance, which will
     * guarantee to keep the sender asset account alive (true).
     */
    "transfer_all": Anonymize<I9nrp6rbq1k4eb>;
}>;
export type I6j6svr1mcma8b = {
    "id": bigint;
    "admin": HexString;
    "min_balance": bigint;
};
export type I4e3fcbllc550c = {
    "id": bigint;
    "owner": HexString;
    "is_sufficient": boolean;
    "min_balance": bigint;
};
export type I91ebagm7eg2of = {
    "id": bigint;
    "beneficiary": HexString;
    "amount": bigint;
};
export type Idktplkgk9qubb = {
    "id": bigint;
    "who": HexString;
    "amount": bigint;
};
export type I46clc78rtmjag = {
    "id": bigint;
    "target": HexString;
    "amount": bigint;
};
export type Ifhl8qqlpgmrgk = {
    "id": bigint;
    "source": HexString;
    "dest": HexString;
    "amount": bigint;
};
export type Ie4fskhkb19lqm = {
    "id": bigint;
    "who": HexString;
};
export type Ifv4apklf5icev = {
    "id": bigint;
    "owner": HexString;
};
export type I55kkfv5j6l61n = {
    "id": bigint;
    "issuer": HexString;
    "admin": HexString;
    "freezer": HexString;
};
export type I87vll2k0a91o2 = {
    "id": bigint;
    "name": Binary;
    "symbol": Binary;
    "decimals": number;
};
export type Iekaug5vo6n1jh = {
    "id": bigint;
    "name": Binary;
    "symbol": Binary;
    "decimals": number;
    "is_frozen": boolean;
};
export type I6olidsoliung0 = {
    "id": bigint;
    "owner": HexString;
    "issuer": HexString;
    "admin": HexString;
    "freezer": HexString;
    "min_balance": bigint;
    "is_sufficient": boolean;
    "is_frozen": boolean;
};
export type I32vkhn5265cl8 = {
    "id": bigint;
    "delegate": HexString;
    "amount": bigint;
};
export type I13irkvjha30nl = {
    "id": bigint;
    "delegate": HexString;
};
export type I4dko4hu09aovh = {
    "id": bigint;
    "owner": HexString;
    "delegate": HexString;
};
export type I1he1llr4em5k8 = {
    "id": bigint;
    "owner": HexString;
    "destination": HexString;
    "amount": bigint;
};
export type Ib98qbv23c0tst = {
    "id": bigint;
    "allow_burn": boolean;
};
export type Iebdnbvufodnev = {
    "id": bigint;
    "min_balance": bigint;
};
export type I9nrp6rbq1k4eb = {
    "id": bigint;
    "dest": HexString;
    "keep_alive": boolean;
};
export type I7d8mct7rtjkvk = AnonymousEnum<{
    /**
     * Register new asset with the asset manager
     */
    "register_foreign_asset": Anonymize<I6sa7pko9va4d9>;
    /**
     * Change the xcm type mapping for a given assetId
     * We also change this if the previous units per second where pointing at the old
     * assetType
     */
    "change_existing_asset_type": Anonymize<Ifsq5hnrgk1fhu>;
    /**
     * Remove a given assetId -> assetType association
     */
    "remove_existing_asset_type": Anonymize<I53muj3qku75an>;
    /**
     * Destroy a given foreign assetId
     * The weight in this case is the one returned by the trait
     * plus the db writes and reads from removing all the associated
     * data
     */
    "destroy_foreign_asset": Anonymize<I53muj3qku75an>;
}>;
export type I6sa7pko9va4d9 = {
    "asset": Anonymize<Ics9mfhmor8iso>;
    "metadata": Anonymize<Iecv438ahg26fr>;
    "min_amount": bigint;
    "is_sufficient": boolean;
};
export type Ifsq5hnrgk1fhu = {
    "asset_id": bigint;
    "new_asset_type": Anonymize<Ics9mfhmor8iso>;
    "num_assets_weight_hint": number;
};
export type I53muj3qku75an = {
    "asset_id": bigint;
    "num_assets_weight_hint": number;
};
export type I9v0cfv3gker3l = AnonymousEnum<{
    /**
     * Register a derivative index for an account id. Dispatchable by
     * DerivativeAddressRegistrationOrigin
     *
     * We do not store the derivative address, but only the index. We do not need to store
     * the derivative address to issue calls, only the index is enough
     *
     * For now an index is registered for all possible destinations and not per-destination.
     * We can change this in the future although it would just make things more complicated
     */
    "register": Anonymize<I7ftla9uldpsck>;
    /**
     * De-Register a derivative index. This prevents an account to use a derivative address
     * (represented by an index) from our of our sovereign accounts anymore
     */
    "deregister": Anonymize<I666bl2fqjkejo>;
    /**
     * Transact the inner call through a derivative account in a destination chain,
     * using 'fee_location' to pay for the fees. This fee_location is given as a multilocation
     *
     * The caller needs to have the index registered in this pallet. The fee multiasset needs
     * to be a reserve asset for the destination transactor::multilocation.
     */
    "transact_through_derivative": Anonymize<I6hso490tnm9h4>;
    /**
     * Transact the call through the sovereign account in a destination chain,
     * 'fee_payer' pays for the fee
     *
     * SovereignAccountDispatcherOrigin callable only
     */
    "transact_through_sovereign": Anonymize<I4d8r6ni3smvbq>;
    /**
     * Change the transact info of a location
     */
    "set_transact_info": Anonymize<I5jipnfinnrumu>;
    /**
     * Remove the transact info of a location
     */
    "remove_transact_info": Anonymize<Icscpmubum33bq>;
    /**
     * Transact the call through the a signed origin in this chain
     * that should be converted to a transaction dispatch account in the destination chain
     * by any method implemented in the destination chains runtime
     *
     * This time we are giving the currency as a currencyId instead of multilocation
     */
    "transact_through_signed": Anonymize<Iehad3aaamosq5>;
    /**
     * Set the fee per second of an asset on its reserve chain
     */
    "set_fee_per_second": Anonymize<If6qluggsjqn24>;
    /**
     * Remove the fee per second of an asset on its reserve chain
     */
    "remove_fee_per_second": Anonymize<Ibmjtl75ptu606>;
    /**
     * Manage HRMP operations
     */
    "hrmp_manage": Anonymize<I7rec93lud546q>;
}>;
export type I7ftla9uldpsck = {
    "who": HexString;
    "index": number;
};
export type I6hso490tnm9h4 = {
    "dest": Enum<{
        "Relay": undefined;
    }>;
    "index": number;
    "fee": Anonymize<Iastnco49ndprk>;
    "inner_call": Binary;
    "weight_info": Anonymize<Idqc0k36dfbejd>;
    "refund": boolean;
};
export type Iastnco49ndprk = {
    "currency": Enum<{
        "AsCurrencyId": Enum<{
            "SelfReserve": undefined;
            "ForeignAsset": bigint;
            "Erc20": {
                "contract_address": FixedSizeBinary<20>;
            };
        }>;
        "AsMultiLocation": XcmVersionedLocation;
    }>;
    "fee_amount"?: Anonymize<I35p85j063s0il>;
};
export type Idqc0k36dfbejd = {
    "transact_required_weight_at_most": Anonymize<I4q39t5hn830vp>;
    "overall_weight"?: (XcmV3WeightLimit) | undefined;
};
export type I4d8r6ni3smvbq = {
    "dest": XcmVersionedLocation;
    "fee_payer"?: Anonymize<I36nb9b8a306lm>;
    "fee": Anonymize<Iastnco49ndprk>;
    "call": Binary;
    "origin_kind": XcmV2OriginKind;
    "weight_info": Anonymize<Idqc0k36dfbejd>;
    "refund": boolean;
};
export type I5jipnfinnrumu = {
    "location": XcmVersionedLocation;
    "transact_extra_weight": Anonymize<I4q39t5hn830vp>;
    "max_weight": Anonymize<I4q39t5hn830vp>;
    "transact_extra_weight_signed"?: Anonymize<Iasb8k6ash5mjn>;
};
export type Iehad3aaamosq5 = {
    "dest": XcmVersionedLocation;
    "fee": Anonymize<Iastnco49ndprk>;
    "call": Binary;
    "weight_info": Anonymize<Idqc0k36dfbejd>;
    "refund": boolean;
};
export type If6qluggsjqn24 = {
    "asset_location": XcmVersionedLocation;
    "fee_per_second": bigint;
};
export type Ibmjtl75ptu606 = {
    "asset_location": XcmVersionedLocation;
};
export type I7rec93lud546q = {
    "action": Anonymize<I5db54nrs89k41>;
    "fee": Anonymize<Iastnco49ndprk>;
    "weight_info": Anonymize<Idqc0k36dfbejd>;
};
export type I6dhat5sf4f153 = AnonymousEnum<{
    /**
     * Xcm Transact an Ethereum transaction.
     * Weight: Gas limit plus the db read involving the suspension check
     */
    "transact": Anonymize<I5d5ame4o328hi>;
    /**
     * Xcm Transact an Ethereum transaction through proxy.
     * Weight: Gas limit plus the db reads involving the suspension and proxy checks
     */
    "transact_through_proxy": Anonymize<I6pm4ngit6p3fq>;
    /**
     * Suspends all Ethereum executions from XCM.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     */
    "suspend_ethereum_xcm_execution": undefined;
    /**
     * Resumes all Ethereum executions from XCM.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     */
    "resume_ethereum_xcm_execution": undefined;
    /**
     * Xcm Transact an Ethereum transaction, but allow to force the caller and create address.
     * This call should be restricted (callable only by the runtime or governance).
     * Weight: Gas limit plus the db reads involving the suspension and proxy checks
     */
    "force_transact_as": Anonymize<I4g6atvguddvkt>;
}>;
export type I5d5ame4o328hi = {
    "xcm_transaction": Anonymize<I10iaskecbelbq>;
};
export type I10iaskecbelbq = AnonymousEnum<{
    "V1": {
        "gas_limit": Anonymize<I4totqt881mlti>;
        "fee_payment": Enum<{
            "Manual": {
                "gas_price"?: Anonymize<Ic4rgfgksgmm3e>;
                "max_fee_per_gas"?: Anonymize<Ic4rgfgksgmm3e>;
            };
            "Auto": undefined;
        }>;
        "action": Anonymize<I2do93a3gr3ege>;
        "value": Anonymize<I4totqt881mlti>;
        "input": Binary;
        "access_list"?: Anonymize<I3dj14b7k3rkm5>;
    };
    "V2": {
        "gas_limit": Anonymize<I4totqt881mlti>;
        "action": Anonymize<I2do93a3gr3ege>;
        "value": Anonymize<I4totqt881mlti>;
        "input": Binary;
        "access_list"?: Anonymize<I3dj14b7k3rkm5>;
    };
}>;
export type I3dj14b7k3rkm5 = (Anonymize<I1bsfec060j604>) | undefined;
export type I6pm4ngit6p3fq = {
    "transact_as": FixedSizeBinary<20>;
    "xcm_transaction": Anonymize<I10iaskecbelbq>;
};
export type I4g6atvguddvkt = {
    "transact_as": FixedSizeBinary<20>;
    "xcm_transaction": Anonymize<I10iaskecbelbq>;
    "force_create_address"?: Anonymize<If7b8240vgt2q5>;
};
export type Ic2uoe7jdksosp = AnonymousEnum<{
    /**
     * Remove a page which has no more messages remaining to be processed or is stale.
     */
    "reap_page": Anonymize<I40pqum1mu8qg3>;
    /**
     * Execute an overweight message.
     *
     * Temporary processing errors will be propagated whereas permanent errors are treated
     * as success condition.
     *
     * - `origin`: Must be `Signed`.
     * - `message_origin`: The origin from which the message to be executed arrived.
     * - `page`: The page in the queue in which the message to be executed is sitting.
     * - `index`: The index into the queue of the message to be executed.
     * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
     * of the message.
     *
     * Benchmark complexity considerations: O(index + weight_limit).
     */
    "execute_overweight": Anonymize<I1r4c2ghbtvjuc>;
}>;
export type I40pqum1mu8qg3 = {
    "message_origin": Anonymize<Iejeo53sea6n4q>;
    "page_index": number;
};
export type I1r4c2ghbtvjuc = {
    "message_origin": Anonymize<Iejeo53sea6n4q>;
    "page": number;
    "index": number;
    "weight_limit": Anonymize<I4q39t5hn830vp>;
};
export type I8miimbh35a69d = AnonymousEnum<{
    /**
     * Create new asset with the ForeignAssetCreator
     */
    "create_foreign_asset": Anonymize<I379npf8sk9t8>;
    /**
     * Change the xcm type mapping for a given assetId
     * We also change this if the previous units per second where pointing at the old
     * assetType
     */
    "change_xcm_location": Anonymize<Ic0s0pur65t3iu>;
    /**
     * Freeze a given foreign assetId
     */
    "freeze_foreign_asset": Anonymize<Iatf3353k2f8t7>;
    /**
     * Unfreeze a given foreign assetId
     */
    "unfreeze_foreign_asset": Anonymize<Ib9karr24cpmca>;
}>;
export type I379npf8sk9t8 = {
    "asset_id": bigint;
    "asset_xcm_location": Anonymize<If9iqq7i64mur8>;
    "decimals": number;
    "symbol": Binary;
    "name": Binary;
};
export type Ic0s0pur65t3iu = {
    "asset_id": bigint;
    "new_xcm_location": Anonymize<If9iqq7i64mur8>;
};
export type Iatf3353k2f8t7 = {
    "asset_id": bigint;
    "allow_xcm_deposit": boolean;
};
export type Ieg97aick2i3ho = AnonymousEnum<{
    "add_asset": Anonymize<I83vh5qua5oulp>;
    "edit_asset": Anonymize<I83vh5qua5oulp>;
    "pause_asset_support": Anonymize<I2adkav4nfpltp>;
    "resume_asset_support": Anonymize<I2adkav4nfpltp>;
    "remove_asset": Anonymize<I2adkav4nfpltp>;
}>;
export type I64di64n316ddk = AnonymousEnum<{
    /**
     * Resume `Normal` mode
     */
    "paused_to_normal": undefined;
    /**
     * Authorize a runtime upgrade. Only callable in `Paused` mode
     */
    "fast_authorize_upgrade": Anonymize<Ib51vk42m1po4n>;
}>;
export type I4oqb168b2d4er = AnonymousEnum<{
    /**
     * Allows root to set a cursor to forcefully start, stop or forward the migration process.
     *
     * Should normally not be needed and is only in place as emergency measure. Note that
     * restarting the migration process in this manner will not call the
     * [`MigrationStatusHandler::started`] hook or emit an `UpgradeStarted` event.
     */
    "force_set_cursor": Anonymize<Ibou4u1engb441>;
    /**
     * Allows root to set an active cursor to forcefully start/forward the migration process.
     *
     * This is an edge-case version of [`Self::force_set_cursor`] that allows to set the
     * `started_at` value to the next block number. Otherwise this would not be possible, since
     * `force_set_cursor` takes an absolute block number. Setting `started_at` to `None`
     * indicates that the current block number plus one should be used.
     */
    "force_set_active_cursor": Anonymize<Id6nbvqoqdj4o2>;
    /**
     * Forces the onboarding of the migrations.
     *
     * This process happens automatically on a runtime upgrade. It is in place as an emergency
     * measurement. The cursor needs to be `None` for this to succeed.
     */
    "force_onboard_mbms": undefined;
    /**
     * Clears the `Historic` set.
     *
     * `map_cursor` must be set to the last value that was returned by the
     * `HistoricCleared` event. The first time `None` can be used. `limit` must be chosen in a
     * way that will result in a sensible weight.
     */
    "clear_historic": Anonymize<I95iqep3b8snn9>;
}>;
export type Ibou4u1engb441 = {
    "cursor"?: (Anonymize<Iepbsvlk3qceij>) | undefined;
};
export type Iepbsvlk3qceij = AnonymousEnum<{
    "Active": {
        "index": number;
        "inner_cursor"?: Anonymize<Iabpgqcjikia83>;
        "started_at": number;
    };
    "Stuck": undefined;
}>;
export type Id6nbvqoqdj4o2 = {
    "index": number;
    "inner_cursor"?: Anonymize<Iabpgqcjikia83>;
    "started_at"?: Anonymize<I4arjljr6dpflb>;
};
export type I95iqep3b8snn9 = {
    "selector": Enum<{
        "Specific": Anonymize<Itom7fk49o0c9>;
        "Wildcard": {
            "limit"?: Anonymize<I4arjljr6dpflb>;
            "previous_cursor"?: Anonymize<Iabpgqcjikia83>;
        };
    }>;
};
export type I7dmdeiskpd2o4 = AnonymousEnum<{
    /**
     * Populates `RandomnessResults` due this epoch with BABE epoch randomness
     */
    "set_babe_randomness_results": undefined;
}>;
export type Iduejesjmcrd2r = AnonymousEnum<{
    /**
     * This call is deprecated and will be removed around May 2024. Use the
     * `submit_finality_proof_ex` instead. Semantically, this call is an equivalent of the
     * `submit_finality_proof_ex` call without current authority set id check.
     */
    "submit_finality_proof": Anonymize<I29mlfpi57nes9>;
    /**
     * Bootstrap the bridge pallet with an initial header and authority set from which to sync.
     *
     * The initial configuration provided does not need to be the genesis header of the bridged
     * chain, it can be any arbitrary header. You can also provide the next scheduled set
     * change if it is already know.
     *
     * This function is only allowed to be called from a trusted origin and writes to storage
     * with practically no checks in terms of the validity of the data. It is important that
     * you ensure that valid data is being passed in.
     */
    "initialize": Anonymize<I9n8t62ile2km9>;
    /**
     * Change `PalletOwner`.
     *
     * May only be called either by root, or by `PalletOwner`.
     */
    "set_owner": Anonymize<Iv53je8etqh25>;
    /**
     * Halt or resume all pallet operations.
     *
     * May only be called either by root, or by `PalletOwner`.
     */
    "set_operating_mode": Anonymize<Id3fgg5dtq3ja9>;
    /**
     * Verify a target header is finalized according to the given finality proof. The proof
     * is assumed to be signed by GRANDPA authorities set with `current_set_id` id.
     *
     * It will use the underlying storage pallet to fetch information about the current
     * authorities and best finalized header in order to verify that the header is finalized.
     *
     * If successful in verification, it will write the target header to the underlying storage
     * pallet.
     *
     * The call fails if:
     *
     * - the pallet is halted;
     *
     * - the pallet knows better header than the `finality_target`;
     *
     * - the id of best GRANDPA authority set, known to the pallet is not equal to the
     * `current_set_id`;
     *
     * - verification is not optimized or invalid;
     *
     * - header contains forced authorities set change or change with non-zero delay.
     *
     * The `is_free_execution_expected` parameter is not really used inside the call. It is
     * used by the transaction extension, which should be registered at the runtime level. If
     * this parameter is `true`, the transaction will be treated as invalid, if the call won't
     * be executed for free. If transaction extension is not used by the runtime, this
     * parameter is not used at all.
     */
    "submit_finality_proof_ex": Anonymize<I7hl2ljcti73p2>;
    /**
     * Set current authorities set and best finalized bridged header to given values
     * (almost) without any checks. This call can fail only if:
     *
     * - the call origin is not a root or a pallet owner;
     *
     * - there are too many authorities in the new set.
     *
     * No other checks are made. Previously imported headers stay in the storage and
     * are still accessible after the call.
     */
    "force_set_pallet_state": Anonymize<I19i0akqkvu7h8>;
}>;
export type I29mlfpi57nes9 = {
    "finality_target": Anonymize<Ic952bubvq4k7d>;
    "justification": Anonymize<I1thtncjg26ghr>;
};
export type I9n8t62ile2km9 = {
    "init_data": {
        "header": Anonymize<Ic952bubvq4k7d>;
        "authority_list": Anonymize<I3geksg000c171>;
        "set_id": bigint;
        "operating_mode": Anonymize<Ibqjcgmcid3dll>;
    };
};
export type Ibqjcgmcid3dll = AnonymousEnum<{
    "Normal": undefined;
    "Halted": undefined;
}>;
export type Iv53je8etqh25 = {
    "new_owner"?: Anonymize<I36nb9b8a306lm>;
};
export type Id3fgg5dtq3ja9 = {
    "operating_mode": Anonymize<Ibqjcgmcid3dll>;
};
export type I7hl2ljcti73p2 = {
    "finality_target": Anonymize<Ic952bubvq4k7d>;
    "justification": Anonymize<I1thtncjg26ghr>;
    "current_set_id": bigint;
    "is_free_execution_expected": boolean;
};
export type I19i0akqkvu7h8 = {
    "new_current_set_id": bigint;
    "new_authorities": Anonymize<I3geksg000c171>;
    "new_best_header": Anonymize<Ic952bubvq4k7d>;
};
export type I8627pri32v47a = AnonymousEnum<{
    /**
     * Submit proof of one or several parachain heads.
     *
     * The proof is supposed to be proof of some `Heads` entries from the
     * `polkadot-runtime-parachains::paras` pallet instance, deployed at the bridged chain.
     * The proof is supposed to be crafted at the `relay_header_hash` that must already be
     * imported by corresponding GRANDPA pallet at this chain.
     *
     * The call fails if:
     *
     * - the pallet is halted;
     *
     * - the relay chain block `at_relay_block` is not imported by the associated bridge
     * GRANDPA pallet.
     *
     * The call may succeed, but some heads may not be updated e.g. because pallet knows
     * better head or it isn't tracked by the pallet.
     */
    "submit_parachain_heads": Anonymize<I4pbpsirgl3tci>;
    /**
     * Change `PalletOwner`.
     *
     * May only be called either by root, or by `PalletOwner`.
     */
    "set_owner": Anonymize<Iv53je8etqh25>;
    /**
     * Halt or resume all pallet operations.
     *
     * May only be called either by root, or by `PalletOwner`.
     */
    "set_operating_mode": Anonymize<Id3fgg5dtq3ja9>;
    /**
     * Submit proof of one or several parachain heads.
     *
     * The proof is supposed to be proof of some `Heads` entries from the
     * `polkadot-runtime-parachains::paras` pallet instance, deployed at the bridged chain.
     * The proof is supposed to be crafted at the `relay_header_hash` that must already be
     * imported by corresponding GRANDPA pallet at this chain.
     *
     * The call fails if:
     *
     * - the pallet is halted;
     *
     * - the relay chain block `at_relay_block` is not imported by the associated bridge
     * GRANDPA pallet.
     *
     * The call may succeed, but some heads may not be updated e.g. because pallet knows
     * better head or it isn't tracked by the pallet.
     *
     * The `is_free_execution_expected` parameter is not really used inside the call. It is
     * used by the transaction extension, which should be registered at the runtime level. If
     * this parameter is `true`, the transaction will be treated as invalid, if the call won't
     * be executed for free. If transaction extension is not used by the runtime, this
     * parameter is not used at all.
     */
    "submit_parachain_heads_ex": Anonymize<I1be5fgduvh91i>;
}>;
export type I4pbpsirgl3tci = {
    "at_relay_block": Anonymize<I4p5t2krb1gmvp>;
    "parachains": Anonymize<Iqnbvitf7a7l3>;
    "parachain_heads_proof": Anonymize<Itom7fk49o0c9>;
};
export type I1be5fgduvh91i = {
    "at_relay_block": Anonymize<I4p5t2krb1gmvp>;
    "parachains": Anonymize<Iqnbvitf7a7l3>;
    "parachain_heads_proof": Anonymize<Itom7fk49o0c9>;
    "is_free_execution_expected": boolean;
};
export type Ia0ligqt4gcemj = AnonymousEnum<{
    /**
     * Change `PalletOwner`.
     *
     * May only be called either by root, or by `PalletOwner`.
     */
    "set_owner": Anonymize<Iv53je8etqh25>;
    /**
     * Halt or resume all/some pallet operations.
     *
     * May only be called either by root, or by `PalletOwner`.
     */
    "set_operating_mode": Anonymize<If7h5asiehgc1m>;
    /**
     * Receive messages proof from bridged chain.
     *
     * The weight of the call assumes that the transaction always brings outbound lane
     * state update. Because of that, the submitter (relayer) has no benefit of not including
     * this data in the transaction, so reward confirmations lags should be minimal.
     *
     * The call fails if:
     *
     * - the pallet is halted;
     *
     * - the call origin is not `Signed(_)`;
     *
     * - there are too many messages in the proof;
     *
     * - the proof verification procedure returns an error - e.g. because header used to craft
     * proof is not imported by the associated finality pallet;
     *
     * - the `dispatch_weight` argument is not sufficient to dispatch all bundled messages.
     *
     * The call may succeed, but some messages may not be delivered e.g. if they are not fit
     * into the unrewarded relayers vector.
     */
    "receive_messages_proof": Anonymize<Ib2r5rmd2kb5rr>;
    /**
     * Receive messages delivery proof from bridged chain.
     */
    "receive_messages_delivery_proof": Anonymize<I8enps0nf0j3o4>;
}>;
export type If7h5asiehgc1m = {
    "operating_mode": Anonymize<Icdpdqb1rbmstf>;
};
export type Icdpdqb1rbmstf = AnonymousEnum<{
    "Basic": Anonymize<Ibqjcgmcid3dll>;
    "RejectingOutboundMessages": undefined;
}>;
export type Ib2r5rmd2kb5rr = {
    "relayer_id_at_bridged_chain": HexString;
    "proof": {
        "bridged_header_hash": FixedSizeBinary<32>;
        "storage_proof": Anonymize<Itom7fk49o0c9>;
        "lane": FixedSizeBinary<32>;
        "nonces_start": bigint;
        "nonces_end": bigint;
    };
    "messages_count": number;
    "dispatch_weight": Anonymize<I4q39t5hn830vp>;
};
export type I8enps0nf0j3o4 = {
    "proof": {
        "bridged_header_hash": FixedSizeBinary<32>;
        "storage_proof": Anonymize<Itom7fk49o0c9>;
        "lane": FixedSizeBinary<32>;
    };
    "relayers_state": {
        "unrewarded_relayer_entries": bigint;
        "messages_in_oldest_entry": bigint;
        "total_messages": bigint;
        "last_delivered_nonce": bigint;
    };
};
export type If9k2qtlkesr5u = AnonymousEnum<{
    /**
     * Open a bridge between two locations.
     *
     * The caller must be within the `T::OpenBridgeOrigin` filter (presumably: a sibling
     * parachain or a parent relay chain). The `bridge_destination_universal_location` must be
     * a destination within the consensus of the `T::BridgedNetwork` network.
     *
     * The `BridgeDeposit` amount is reserved on the caller account. This deposit
     * is unreserved after bridge is closed.
     *
     * The states after this call: bridge is `Opened`, outbound lane is `Opened`, inbound lane
     * is `Opened`.
     */
    "open_bridge": Anonymize<I6c1udb33nvkg9>;
    /**
     * Try to close the bridge.
     *
     * Can only be called by the "owner" of this side of the bridge, meaning that the
     * inbound XCM channel with the local origin chain is working.
     *
     * Closed bridge is a bridge without any traces in the runtime storage. So this method
     * first tries to prune all queued messages at the outbound lane. When there are no
     * outbound messages left, outbound and inbound lanes are purged. After that, funds
     * are returned back to the owner of this side of the bridge.
     *
     * The number of messages that we may prune in a single call is limited by the
     * `may_prune_messages` argument. If there are more messages in the queue, the method
     * prunes exactly `may_prune_messages` and exits early. The caller may call it again
     * until outbound queue is depleted and get his funds back.
     *
     * The states after this call: everything is either `Closed`, or purged from the
     * runtime storage.
     */
    "close_bridge": Anonymize<Ifha513j297q5e>;
}>;
export type I6c1udb33nvkg9 = {
    "bridge_destination_universal_location": Anonymize<Ibldt7l7uie0q>;
};
export type Ibldt7l7uie0q = AnonymousEnum<{
    "V3": XcmV3Junctions;
    "V4": XcmV3Junctions;
    "V5": XcmV5Junctions;
}>;
export type Ifha513j297q5e = {
    "bridge_destination_universal_location": Anonymize<Ibldt7l7uie0q>;
    "may_prune_messages": bigint;
};
export type Ifd4n2fqmntemu = [HexString, undefined];
export type I7pc2or9t0j7rj = {
    "index": number;
    "threshold": number;
    "ayes": Anonymize<I55luuvb7oq2a3>;
    "nays": Anonymize<I55luuvb7oq2a3>;
    "end": number;
};
export type I1fhhvus3f3pq9 = {
    "proposer": HexString;
    "value": bigint;
    "beneficiary": HexString;
    "bond": bigint;
};
export type I9e1k9mfd924m0 = {
    "asset_kind": Anonymize<I8ftdv6d7go8s5>;
    "amount": bigint;
    "beneficiary": HexString;
    "valid_from": number;
    "expire_at": number;
    "status": Anonymize<Ier5jvvb5iqu1g>;
};
export type Ier5jvvb5iqu1g = AnonymousEnum<{
    "Pending": undefined;
    "Attempted": Anonymize<I3m5sq54sjdlso>;
    "Failed": undefined;
}>;
export type I3m5sq54sjdlso = {};
export type Ibrauvtsisstbp = {
    "total_reward": bigint;
    "claimed_reward": bigint;
    "contributed_relay_addresses": Anonymize<Ic5m5lp1oioo8r>;
};
export type Ib77b0fp1a6mjr = Array<{
    "recipient": number;
    "state": Enum<{
        "Ok": undefined;
        "Suspended": undefined;
    }>;
    "signals_exist": boolean;
    "first_index": number;
    "last_index": number;
}>;
export type Ifup3lg9ro8a0f = {
    "suspend_threshold": number;
    "drop_threshold": number;
    "resume_threshold": number;
};
export type I8e1rrqvum82k2 = [number, HexString, XcmVersionedAssetId];
export type Icksgi86tt9bmn = {
    "owner": HexString;
    "issuer": HexString;
    "admin": HexString;
    "freezer": HexString;
    "supply": bigint;
    "deposit": bigint;
    "min_balance": bigint;
    "is_sufficient": boolean;
    "accounts": number;
    "sufficients": number;
    "approvals": number;
    "status": Anonymize<I3sd59779ndgs3>;
};
export type I3sd59779ndgs3 = AnonymousEnum<{
    "Live": undefined;
    "Frozen": undefined;
    "Destroying": undefined;
}>;
export type I7pi9qrc9a6rbn = {
    "balance": bigint;
    "status": Anonymize<Icvjt1ogfma62c>;
    "reason": Enum<{
        "Consumer": undefined;
        "Sufficient": undefined;
        "DepositHeld": bigint;
        "DepositRefunded": undefined;
        "DepositFrom": Anonymize<Ic2o7gh4sgom1k>;
    }>;
};
export type Icvjt1ogfma62c = AnonymousEnum<{
    "Liquid": undefined;
    "Frozen": undefined;
    "Blocked": undefined;
}>;
export type Ie7gvtu33pdnbd = [bigint, HexString];
export type I4s6jkha20aoh0 = {
    "amount": bigint;
    "deposit": bigint;
};
export type Ifjamgt3ponn9a = [bigint, HexString, HexString];
export type I78s05f59eoi8b = {
    "deposit": bigint;
    "name": Binary;
    "symbol": Binary;
    "decimals": number;
    "is_frozen": boolean;
};
export type I121rub4n25k05 = {
    "staking": number;
    "utility": number;
    "hrmp": number;
    "bond": number;
    "bond_extra": number;
    "unbond": number;
    "withdraw_unbonded": number;
    "validate": number;
    "nominate": number;
    "chill": number;
    "set_payee": number;
    "set_controller": number;
    "rebond": number;
    "as_derivative": number;
    "init_open_channel": number;
    "accept_open_channel": number;
    "close_channel": number;
    "cancel_open_request": number;
};
export type Idh2ug6ou4a8og = {
    "begin": number;
    "end": number;
    "count": number;
    "ready_neighbours"?: ({
        "prev": Anonymize<Iejeo53sea6n4q>;
        "next": Anonymize<Iejeo53sea6n4q>;
    }) | undefined;
    "message_count": bigint;
    "size": bigint;
};
export type Ib4jhb8tt3uung = [Anonymize<Iejeo53sea6n4q>, number];
export type I3nt43q1felhpo = [bigint, Enum<{
    "Active": undefined;
    "FrozenXcmDepositAllowed": undefined;
    "FrozenXcmDepositForbidden": undefined;
}>];
export type I8k4t3g0d1is9p = {
    "deposit_account": HexString;
    "deposit": bigint;
};
export type I7m9dkorbfsjro = [boolean, bigint];
export type I24au772a01k9n = AnonymousEnum<{
    "Normal": undefined;
    "Paused": undefined;
}>;
export type Iapo0cnvtli5i0 = {
    "request": {
        "refund_address": FixedSizeBinary<20>;
        "contract_address": FixedSizeBinary<20>;
        "fee": bigint;
        "gas_limit": bigint;
        "num_words": number;
        "salt": FixedSizeBinary<32>;
        "info": Enum<{
            "BabeEpoch": Anonymize<I200n1ov5tbcvr>;
            "Local": Anonymize<I9jd27rnpm8ttv>;
        }>;
    };
    "deposit": bigint;
};
export type Iu5urbma3d3as = {
    "randomness"?: Anonymize<I4s6vifaf8k998>;
    "request_count": bigint;
};
export type I316f7rqm1ifg1 = AnonymousEnum<{
    "BabeEpoch": bigint;
    "Local": number;
}>;
export type I67smi4kj2jg4u = {
    "number": number;
    "state_root": FixedSizeBinary<32>;
};
export type Id15d558jgoqcl = {
    "best_head_hash": {
        "at_relay_block_number": number;
        "head_hash": FixedSizeBinary<32>;
    };
    "next_imported_hash_position": number;
};
export type Idb24blqv4khu3 = {
    "relayers": Array<{
        "relayer": HexString;
        "messages": Anonymize<I2trpm8e0601l4>;
    }>;
    "last_confirmed_nonce": bigint;
    "state": Anonymize<Ibguedor6to6h9>;
};
export type Ibguedor6to6h9 = AnonymousEnum<{
    "Opened": undefined;
    "Closed": undefined;
}>;
export type I84l6vdi7riqfe = {
    "oldest_unpruned_nonce": bigint;
    "latest_received_nonce": bigint;
    "latest_generated_nonce": bigint;
    "state": Anonymize<Ibguedor6to6h9>;
};
export type I3bv0ejtjh5f9r = {
    "bridge_origin_relative_location": XcmVersionedLocation;
    "bridge_origin_universal_location": Anonymize<Ibldt7l7uie0q>;
    "bridge_destination_universal_location": Anonymize<Ibldt7l7uie0q>;
    "state": Enum<{
        "Opened": undefined;
        "Suspended": undefined;
        "Closed": undefined;
    }>;
    "bridge_owner_account": HexString;
    "deposit": bigint;
    "lane_id": FixedSizeBinary<32>;
};
export type Ievrs91su783vi = Array<Anonymize<I627irg93qbdgl>>;
export type I7uf2ofmdnm812 = Array<Anonymize<I6rijf6a9nh113>>;
export type I6rijf6a9nh113 = {
    "nonce": bigint;
    "dispatch_weight": Anonymize<I4q39t5hn830vp>;
    "size": number;
};
export type I3r3poh6h8vl7n = Array<[Binary, Anonymize<I6rijf6a9nh113>]>;
export type I74b5o27m5tpv = Array<Anonymize<I4q39t5hn830vp>>;
export type Io4aq6tvaqcc7 = ResultPayload<Anonymize<Id16ku1poe7q51>, Anonymize<I5nrjkj9qumobs>>;
export type I2q8ltoai1r4og = {
    "ready": Anonymize<I1fl9qh2r1hf29>;
    "future": Anonymize<I1fl9qh2r1hf29>;
};
export type If08sfhqn8ujfr = {
    "balance": Anonymize<I4totqt881mlti>;
    "nonce": Anonymize<I4totqt881mlti>;
};
export type I61suq2euu87ho = ResultPayload<Anonymize<I7ag5k7bmmgq3j>, Anonymize<I68l22felg5oio>>;
export type I7ag5k7bmmgq3j = {
    "exit_reason": Anonymize<Iag9iovb9j5ijo>;
    "value": Binary;
    "used_gas": Anonymize<I8mgv59to1hjie>;
    "weight_info"?: Anonymize<Ib72ii9bshc8f5>;
    "logs": Anonymize<Ids7ng2qsv7snu>;
};
export type I8mgv59to1hjie = {
    "standard": Anonymize<I4totqt881mlti>;
    "effective": Anonymize<I4totqt881mlti>;
};
export type Ib72ii9bshc8f5 = ({
    "ref_time_limit"?: Anonymize<I35p85j063s0il>;
    "proof_size_limit"?: Anonymize<I35p85j063s0il>;
    "ref_time_usage"?: Anonymize<I35p85j063s0il>;
    "proof_size_usage"?: Anonymize<I35p85j063s0il>;
}) | undefined;
export type I7n8kbohflaod = ResultPayload<Anonymize<Ie3rl25flint9v>, Anonymize<I68l22felg5oio>>;
export type Ie3rl25flint9v = {
    "exit_reason": Anonymize<Iag9iovb9j5ijo>;
    "value": FixedSizeBinary<20>;
    "used_gas": Anonymize<I8mgv59to1hjie>;
    "weight_info"?: Anonymize<Ib72ii9bshc8f5>;
    "logs": Anonymize<Ids7ng2qsv7snu>;
};
export type Ifogockjiq4b3 = (Anonymize<Idi27giun0mb9q>) | undefined;
export type I2r0n4gcrs974b = (Anonymize<Idud3fdh64aqp9>) | undefined;
export type Ie6kgk6f04rsvk = (Anonymize<Ie7atdsih6q14b>) | undefined;
export type Ibkook56hopvp8 = [Anonymize<Ifogockjiq4b3>, Anonymize<I2r0n4gcrs974b>, Anonymize<Ie6kgk6f04rsvk>];
export type I45rl58hfs7m0h = [Anonymize<Ifogockjiq4b3>, Anonymize<Ie6kgk6f04rsvk>];
export type I5bgbhp433c8bl = ResultPayload<{
    "execution_result": Anonymize<I2kog69vhk3kjk>;
    "emitted_events": Anonymize<I2kdf9fhgg5p6t>;
    "local_xcm"?: Anonymize<Ieqgqma27vbupd>;
    "forwarded_xcms": Anonymize<Ialhmrpub9sefe>;
}, Anonymize<I55ku9c5gk50hb>>;
export type I2kdf9fhgg5p6t = Array<Anonymize<I6lsdonc548n1k>>;
export type Ifb4t7j7sn57m4 = ResultPayload<{
    "execution_result": Anonymize<I6uq5gb4s805s7>;
    "emitted_events": Anonymize<I2kdf9fhgg5p6t>;
    "forwarded_xcms": Anonymize<Ialhmrpub9sefe>;
}, Anonymize<I55ku9c5gk50hb>>;
export type I81ojrtgkds5sl = ResultPayload<HexString, Anonymize<Ibaohq34aedndv>>;
export type Ifv1hra9a1ej1o = Array<{
    "phase": Phase;
    "event": Anonymize<I2dkkh5p968qs3>;
    "topics": Anonymize<Ic5m5lp1oioo8r>;
}>;
export type I2dkkh5p968qs3 = AnonymousEnum<{
    "System": Anonymize<Iaktb5bos95hrs>;
    "Indices": Anonymize<I2pejk6do5vg4t>;
    "ParachainSystem": Anonymize<Icbsekf57miplo>;
    "TxPause": Anonymize<I9ulgod11dfvq5>;
    "MultiBlockMigrations": Anonymize<I94co7vj7h6bo>;
    "Balances": Anonymize<Iao8h4hv7atnq3>;
    "TransactionPayment": TransactionPaymentEvent;
    "Session": Anonymize<I4co4bgsti676q>;
    "ParachainStaking": Anonymize<I836ha9codfrm6>;
    "ConvictionVoting": Anonymize<I7tvgbf73o5td4>;
    "Referenda": Anonymize<Idfraa3b4eu018>;
    "Whitelist": Anonymize<I4llkm1lp1bigd>;
    "XcmpQueue": Anonymize<Idsqc7mhp6nnle>;
    "PolkadotXcm": Anonymize<Id2l439q7pe8kr>;
    "CumulusXcm": Anonymize<Ihpdgvt7vs2cb>;
    "MessageQueue": Anonymize<I2kosejppk3jon>;
    "Utility": Anonymize<I2h4rf2ad4tlre>;
    "Scheduler": Anonymize<Ic4skm7au89frs>;
    "Proxy": Anonymize<I7j4vibq8brbq0>;
    "Multisig": Anonymize<I9dua8dbe792fr>;
    "Identity": Anonymize<I2au2or9cskfoi>;
    "Vesting": VestingEvent;
    "Treasury": Anonymize<I3kfo09eqm1214>;
    "Preimage": PreimageEvent;
    "Ethereum": Anonymize<I510u4q1qqh897>;
    "EVM": Anonymize<I9k071kk4cn1u8>;
    "EVMAccounts": Anonymize<I71u7do1ao6vjp>;
    "XTokens": Anonymize<I1kj6lnq7rdnrl>;
    "Tokens": Anonymize<I4oigsiqtj1dkn>;
    "UnknownTokens": Anonymize<Iacevcg18ig1av>;
    "OrmlXcm": Anonymize<Iclksjsco5l5ll>;
    "ZenlinkProtocol": Anonymize<I148v60cekcg36>;
    "Ismp": Anonymize<Icmkq9kpsciiub>;
    "IsmpParachain": Anonymize<Ie6qh3o3afje2f>;
    "Hyperbridge": Anonymize<I98tlgsrsat2ne>;
    "TokenGateway": Anonymize<I4e096t1b1rrk7>;
    "FlexibleFee": Anonymize<I951u7mq7pq6i7>;
    "Salp": Anonymize<I87g1igl7tl927>;
    "AssetRegistry": Anonymize<Idk7vijisib25n>;
    "VtokenMinting": Anonymize<Ibe1mbk3j43vrp>;
    "Slp": Anonymize<I5jumpe7oiv3dr>;
    "XcmInterface": Anonymize<Iu4qso82fll8>;
    "TokenConversion": Anonymize<I6rndlmfeiieis>;
    "Farming": Anonymize<I3rtmkbgfdecd4>;
    "SystemStaking": Anonymize<I3oonoiudj95ud>;
    "FeeShare": Anonymize<Ickekbsj4u887j>;
    "CrossInOut": Anonymize<I1siqn564k36so>;
    "BbBNC": Anonymize<I3lfnu67umnl7t>;
    "Slpx": Anonymize<I4ursntiif5vp5>;
    "FellowshipCollective": Anonymize<Ifuucdgpuglunu>;
    "FellowshipReferenda": Anonymize<I28aoa43r171jt>;
    "StableAsset": Anonymize<I9449gf1cit5>;
    "VtokenVoting": Anonymize<I7s7ajrmv13hni>;
    "LendMarket": Anonymize<Iff94km1u4n3pd>;
    "Prices": Anonymize<Iaja1q8oji7pdd>;
    "Oracle": Anonymize<Iepf7s9r1cn7ph>;
    "OracleMembership": Anonymize<Ibraem55mlft17>;
    "LeverageStaking": Anonymize<I7t9fm1af55at9>;
    "ChannelCommission": Anonymize<Idnhi30b9nageu>;
    "CloudsConvert": Anonymize<I3tig0oab4mvlr>;
    "BuyBack": Anonymize<I2kcq0r7qlj1i7>;
    "SlpV2": Anonymize<I4uk3228gmrfd9>;
}>;
export type Iaktb5bos95hrs = AnonymousEnum<{
    /**
     * An extrinsic completed successfully.
     */
    "ExtrinsicSuccess": Anonymize<Ia82mnkmeo2rhc>;
    /**
     * An extrinsic failed.
     */
    "ExtrinsicFailed": Anonymize<I7pbnbt70rdp6m>;
    /**
     * `:code` was updated.
     */
    "CodeUpdated": undefined;
    /**
     * A new account was created.
     */
    "NewAccount": Anonymize<Icbccs0ug47ilf>;
    /**
     * An account was reaped.
     */
    "KilledAccount": Anonymize<Icbccs0ug47ilf>;
    /**
     * On on-chain remark happened.
     */
    "Remarked": Anonymize<I855j4i3kr8ko1>;
    /**
     * An upgrade was authorized.
     */
    "UpgradeAuthorized": Anonymize<Ibgl04rn6nbfm6>;
    /**
     * An invalid authorized upgrade was rejected while trying to apply it.
     */
    "RejectedInvalidAuthorizedUpgrade": Anonymize<I92lvnr2lhfkjg>;
}>;
export type I7pbnbt70rdp6m = {
    "dispatch_error": Anonymize<I46mg5gru1rk0a>;
    "dispatch_info": Anonymize<Ic9s8f85vjtncc>;
};
export type I46mg5gru1rk0a = AnonymousEnum<{
    "Other": undefined;
    "CannotLookup": undefined;
    "BadOrigin": undefined;
    "Module": Enum<{
        "System": Anonymize<I5o0s7c8q1cc9b>;
        "Timestamp": undefined;
        "Indices": Anonymize<Icq1825fru3di2>;
        "ParachainSystem": Anonymize<Icjkr35j4tmg7k>;
        "ParachainInfo": undefined;
        "TxPause": Anonymize<Ifku1elmu8hk3i>;
        "MultiBlockMigrations": Anonymize<Iaaqq5jevtahm8>;
        "Balances": Anonymize<Idj13i7adlomht>;
        "TransactionPayment": undefined;
        "Authorship": undefined;
        "Session": Anonymize<I1e07dgbaqd1sq>;
        "Aura": undefined;
        "AuraExt": undefined;
        "ParachainStaking": Anonymize<Iat6dg9851r60t>;
        "ConvictionVoting": Anonymize<Idfa8k8ikssbsf>;
        "Referenda": Anonymize<I84u4ul208g742>;
        "Origins": undefined;
        "Whitelist": Anonymize<I15nctscutpbeh>;
        "XcmpQueue": Anonymize<Idnnbndsjjeqqs>;
        "PolkadotXcm": Anonymize<I6dl09bpoqheqk>;
        "CumulusXcm": undefined;
        "MessageQueue": Anonymize<I5iupade5ag2dp>;
        "Utility": Anonymize<I8dt2g2hcrgh36>;
        "Scheduler": Anonymize<If7oa8fprnilo5>;
        "Proxy": Anonymize<Iuvt54ei4cehc>;
        "Multisig": Anonymize<Ia76qmhhg4jvb9>;
        "Identity": Anonymize<Ib8gja1crqq8kd>;
        "Vesting": Anonymize<I5vocqfqrr94pk>;
        "Treasury": Anonymize<I36uss0m9fpcsf>;
        "Preimage": Anonymize<I4cfhml1prt4lu>;
        "Ethereum": Anonymize<I1mp6vnoh32l4q>;
        "EVM": Anonymize<I2e8svucak6is3>;
        "EVMChainId": undefined;
        "DynamicFee": undefined;
        "EVMAccounts": Anonymize<Ie65vecqacffpm>;
        "XTokens": Anonymize<I8g8tbk0anjali>;
        "Tokens": Anonymize<Icc7o7ep6n36h2>;
        "Currencies": Anonymize<Icgcafv5q5cios>;
        "UnknownTokens": Anonymize<I5llpdov40t5vu>;
        "OrmlXcm": Anonymize<Ifv4efjta13rhe>;
        "ZenlinkProtocol": Anonymize<I8dt4sn2f9onud>;
        "Ismp": Anonymize<Iu66k013uv34p>;
        "IsmpParachain": undefined;
        "Hyperbridge": undefined;
        "TokenGateway": Anonymize<Ic0f75bbp58vde>;
        "FlexibleFee": Anonymize<I4bah32pt0fjeb>;
        "Salp": Anonymize<Ikmpj1qpmlgg2>;
        "AssetRegistry": Anonymize<Ifdrdolunm5asr>;
        "VtokenMinting": Anonymize<I4sgpk7gabn1jg>;
        "Slp": Anonymize<I7d2j6upi68gp8>;
        "XcmInterface": Anonymize<Ienvs8qkad8lnj>;
        "TokenConversion": Anonymize<Iahrplfbd63p1f>;
        "Farming": Anonymize<Idvt9vhbsepe42>;
        "SystemStaking": Anonymize<Ie8fttjg299r2c>;
        "FeeShare": Anonymize<Ierlpnhjmvhm3t>;
        "CrossInOut": Anonymize<I7g8kiobl17ku6>;
        "BbBNC": Anonymize<I1pcsi4mugfb5o>;
        "Slpx": Anonymize<I75at17i6fmjmo>;
        "FellowshipCollective": Anonymize<Ib69hbq04ogo7t>;
        "FellowshipReferenda": Anonymize<I84u4ul208g742>;
        "StableAsset": Anonymize<Idhsrli8e2qcvl>;
        "StablePool": Anonymize<I37baq92usopm0>;
        "VtokenVoting": Anonymize<If5eaevvg0u6lv>;
        "LendMarket": Anonymize<If47j4ahcl5iuf>;
        "Prices": undefined;
        "Oracle": Anonymize<Ibbhs1otrrm5i1>;
        "OracleMembership": Anonymize<Ie3flrv31mi7gh>;
        "LeverageStaking": Anonymize<I5hife89is4rs2>;
        "ChannelCommission": Anonymize<Idoo1gokjlqeae>;
        "CloudsConvert": Anonymize<If5rlmcl3m09tr>;
        "BuyBack": Anonymize<Iqrtuhjkceatk>;
        "SlpV2": Anonymize<I2e3a0uivkcoam>;
    }>;
    "ConsumerRemaining": undefined;
    "NoProviders": undefined;
    "TooManyConsumers": undefined;
    "Token": TokenError;
    "Arithmetic": ArithmeticError;
    "Transactional": TransactionalError;
    "Exhausted": undefined;
    "Corruption": undefined;
    "Unavailable": undefined;
    "RootNotAllowed": undefined;
    "Trie": Anonymize<Idh4cj79bvroj8>;
}>;
export type Icjkr35j4tmg7k = AnonymousEnum<{
    /**
     * Attempt to upgrade validation function while existing upgrade pending.
     */
    "OverlappingUpgrades": undefined;
    /**
     * Polkadot currently prohibits this parachain from upgrading its validation function.
     */
    "ProhibitedByPolkadot": undefined;
    /**
     * The supplied validation function has compiled into a blob larger than Polkadot is
     * willing to run.
     */
    "TooBig": undefined;
    /**
     * The inherent which supplies the validation data did not run this block.
     */
    "ValidationDataNotAvailable": undefined;
    /**
     * The inherent which supplies the host configuration did not run this block.
     */
    "HostConfigurationNotAvailable": undefined;
    /**
     * No validation function upgrade is currently scheduled.
     */
    "NotScheduled": undefined;
}>;
export type Ifku1elmu8hk3i = AnonymousEnum<{
    /**
     * The call is paused.
     */
    "IsPaused": undefined;
    /**
     * The call is unpaused.
     */
    "IsUnpaused": undefined;
    /**
     * The call is whitelisted and cannot be paused.
     */
    "Unpausable": undefined;
    "NotFound": undefined;
}>;
export type Iat6dg9851r60t = AnonymousEnum<{
    "DelegatorDNE": undefined;
    "DelegatorDNEinTopNorBottom": undefined;
    "DelegatorDNEInDelegatorSet": undefined;
    "CandidateDNE": undefined;
    "DelegationDNE": undefined;
    "DelegatorExists": undefined;
    "CandidateExists": undefined;
    "CandidateBondBelowMin": undefined;
    "InsufficientBalance": undefined;
    "DelegatorBondBelowMin": undefined;
    "DelegationBelowMin": undefined;
    "AlreadyOffline": undefined;
    "AlreadyActive": undefined;
    "DelegatorAlreadyLeaving": undefined;
    "DelegatorNotLeaving": undefined;
    "DelegatorCannotLeaveYet": undefined;
    "CannotDelegateIfLeaving": undefined;
    "CandidateAlreadyLeaving": undefined;
    "CandidateNotLeaving": undefined;
    "CandidateCannotLeaveYet": undefined;
    "CannotGoOnlineIfLeaving": undefined;
    "ExceedMaxDelegationsPerDelegator": undefined;
    "AlreadyDelegatedCandidate": undefined;
    "InvalidSchedule": undefined;
    "CannotSetBelowMin": undefined;
    "RoundLengthMustBeGreaterThanTotalSelectedCollators": undefined;
    "NoWritingSameValue": undefined;
    "TooLowCandidateCountWeightHintJoinCandidates": undefined;
    "TooLowCandidateCountWeightHintCancelLeaveCandidates": undefined;
    "TooLowCandidateCountToLeaveCandidates": undefined;
    "TooLowDelegationCountToDelegate": undefined;
    "TooLowCandidateDelegationCountToDelegate": undefined;
    "TooLowCandidateDelegationCountToLeaveCandidates": undefined;
    "TooLowDelegationCountToLeaveDelegators": undefined;
    "PendingCandidateRequestsDNE": undefined;
    "PendingCandidateRequestAlreadyExists": undefined;
    "PendingCandidateRequestNotDueYet": undefined;
    "PendingDelegationRequestDNE": undefined;
    "PendingDelegationRequestAlreadyExists": undefined;
    "PendingDelegationRequestNotDueYet": undefined;
    "CannotDelegateLessThanOrEqualToLowestBottomWhenFull": undefined;
    "PendingDelegationRevoke": undefined;
}>;
export type I5vocqfqrr94pk = AnonymousEnum<{
    /**
     * The account given is not vesting.
     */
    "NotVesting": undefined;
    /**
     * The account already has `MaxVestingSchedules` count of schedules and thus
     * cannot add another one. Consider merging existing schedules in order to add another.
     */
    "AtMaxVestingSchedules": undefined;
    /**
     * Amount being transferred is too low to create a vesting schedule.
     */
    "AmountLow": undefined;
    /**
     * An index was out of bounds of the vesting schedules.
     */
    "ScheduleIndexOutOfBounds": undefined;
    /**
     * Failed to create a new schedule because some parameter was invalid.
     */
    "InvalidScheduleParams": undefined;
    /**
     * change to the same per_block param
     */
    "SamePerBlock": undefined;
    /**
     * VestingStartAt storage is not set
     */
    "VestingStartAtNotSet": undefined;
    /**
     * Wrong amount
     */
    "WrongLockedAmount": undefined;
    /**
     * Wrong vesting during cliff period
     */
    "WrongCliffVesting": undefined;
}>;
export type I2e8svucak6is3 = AnonymousEnum<{
    /**
     * Not enough balance to perform action
     */
    "BalanceLow": undefined;
    /**
     * Calculating total fee overflowed
     */
    "FeeOverflow": undefined;
    /**
     * Calculating total payment overflowed
     */
    "PaymentOverflow": undefined;
    /**
     * Withdraw fee failed
     */
    "WithdrawFailed": undefined;
    /**
     * Gas price is too low.
     */
    "GasPriceTooLow": undefined;
    /**
     * Nonce is invalid
     */
    "InvalidNonce": undefined;
    /**
     * Gas limit is too low.
     */
    "GasLimitTooLow": undefined;
    /**
     * Gas limit is too high.
     */
    "GasLimitTooHigh": undefined;
    /**
     * The chain id is invalid.
     */
    "InvalidChainId": undefined;
    /**
     * the signature is invalid.
     */
    "InvalidSignature": undefined;
    /**
     * EVM reentrancy
     */
    "Reentrancy": undefined;
    /**
     * EIP-3607,
     */
    "TransactionMustComeFromEOA": undefined;
    /**
     * Undefined error.
     */
    "Undefined": undefined;
    /**
     * Address not allowed to deploy contracts either via CREATE or CALL(CREATE).
     */
    "CreateOriginNotAllowed": undefined;
}>;
export type Ie65vecqacffpm = AnonymousEnum<{
    /**
     * EVM Account's nonce is not zero
     */
    "TruncatedAccountAlreadyUsed": undefined;
    /**
     * Address is already bound
     */
    "AddressAlreadyBound": undefined;
    /**
     * Bound address cannot be used
     */
    "BoundAddressCannotBeUsed": undefined;
    /**
     * Address not whitelisted
     */
    "AddressNotWhitelisted": undefined;
}>;
export type I8g8tbk0anjali = AnonymousEnum<{
    /**
     * Asset has no reserve location.
     */
    "AssetHasNoReserve": undefined;
    /**
     * Not cross-chain transfer.
     */
    "NotCrossChainTransfer": undefined;
    /**
     * Invalid transfer destination.
     */
    "InvalidDest": undefined;
    /**
     * Currency is not cross-chain transferable.
     */
    "NotCrossChainTransferableCurrency": undefined;
    /**
     * The message's weight could not be determined.
     */
    "UnweighableMessage": undefined;
    /**
     * XCM execution failed.
     */
    "XcmExecutionFailed": undefined;
    /**
     * Could not re-anchor the assets to declare the fees for the
     * destination chain.
     */
    "CannotReanchor": undefined;
    /**
     * Could not get ancestry of asset reserve location.
     */
    "InvalidAncestry": undefined;
    /**
     * The Asset is invalid.
     */
    "InvalidAsset": undefined;
    /**
     * The destination `Location` provided cannot be inverted.
     */
    "DestinationNotInvertible": undefined;
    /**
     * The version of the `Versioned` value used is not able to be
     * interpreted.
     */
    "BadVersion": undefined;
    /**
     * We tried sending distinct asset and fee but they have different
     * reserve chains.
     */
    "DistinctReserveForAssetAndFee": undefined;
    /**
     * The fee is zero.
     */
    "ZeroFee": undefined;
    /**
     * The transferring asset amount is zero.
     */
    "ZeroAmount": undefined;
    /**
     * The number of assets to be sent is over the maximum.
     */
    "TooManyAssetsBeingSent": undefined;
    /**
     * The specified index does not exist in a Assets struct.
     */
    "AssetIndexNonExistent": undefined;
    /**
     * Fee is not enough.
     */
    "FeeNotEnough": undefined;
    /**
     * Not supported Location
     */
    "NotSupportedLocation": undefined;
    /**
     * MinXcmFee not registered for certain reserve location
     */
    "MinXcmFeeNotDefined": undefined;
    /**
     * Asset transfer is limited by RateLimiter.
     */
    "RateLimited": undefined;
}>;
export type Icc7o7ep6n36h2 = AnonymousEnum<{
    /**
     * The balance is too low
     */
    "BalanceTooLow": undefined;
    /**
     * Cannot convert Amount into Balance type
     */
    "AmountIntoBalanceFailed": undefined;
    /**
     * Failed because liquidity restrictions due to locking
     */
    "LiquidityRestrictions": undefined;
    /**
     * Failed because the maximum locks was exceeded
     */
    "MaxLocksExceeded": undefined;
    /**
     * Transfer/payment would kill account
     */
    "KeepAlive": undefined;
    /**
     * Value too low to create account due to existential deposit
     */
    "ExistentialDeposit": undefined;
    /**
     * Beneficiary account must pre-exist
     */
    "DeadAccount": undefined;
    "TooManyReserves": undefined;
}>;
export type Icgcafv5q5cios = AnonymousEnum<{
    /**
     * Unable to convert the Amount type into Balance.
     */
    "AmountIntoBalanceFailed": undefined;
    /**
     * Balance is too low.
     */
    "BalanceTooLow": undefined;
    /**
     * Deposit result is not expected
     */
    "DepositFailed": undefined;
}>;
export type I5llpdov40t5vu = AnonymousEnum<{
    /**
     * The balance is too low.
     */
    "BalanceTooLow": undefined;
    /**
     * The operation will cause balance to overflow.
     */
    "BalanceOverflow": undefined;
    /**
     * Unhandled asset.
     */
    "UnhandledAsset": undefined;
}>;
export type Ifv4efjta13rhe = AnonymousEnum<{
    /**
     * The message and destination combination was not recognized as being
     * reachable.
     */
    "Unreachable": undefined;
    /**
     * The message and destination was recognized as being reachable but
     * the operation could not be completed.
     */
    "SendFailure": undefined;
    /**
     * The version of the `Versioned` value used is not able to be
     * interpreted.
     */
    "BadVersion": undefined;
}>;
export type I8dt4sn2f9onud = AnonymousEnum<{
    /**
     * Require the admin who can reset the admin and receiver of the protocol fee.
     */
    "RequireProtocolAdmin": undefined;
    /**
     * Require the admin candidate who can become new admin after confirm.
     */
    "RequireProtocolAdminCandidate": undefined;
    /**
     * Invalid fee_point
     */
    "InvalidFeePoint": undefined;
    /**
     * Unsupported AssetId by this ZenlinkProtocol Version.
     */
    "UnsupportedAssetType": undefined;
    /**
     * Account balance must be greater than or equal to the transfer amount.
     */
    "InsufficientAssetBalance": undefined;
    /**
     * Account native currency balance must be greater than ExistentialDeposit.
     */
    "NativeBalanceTooLow": undefined;
    /**
     * Trading pair can't be created.
     */
    "DeniedCreatePair": undefined;
    /**
     * Trading pair already exists.
     */
    "PairAlreadyExists": undefined;
    /**
     * Trading pair does not exist.
     */
    "PairNotExists": undefined;
    /**
     * Asset does not exist.
     */
    "AssetNotExists": undefined;
    /**
     * Liquidity is not enough.
     */
    "InsufficientLiquidity": undefined;
    /**
     * Trading pair does have enough foreign.
     */
    "InsufficientPairReserve": undefined;
    /**
     * Get target amount is less than exception.
     */
    "InsufficientTargetAmount": undefined;
    /**
     * Sold amount is more than exception.
     */
    "ExcessiveSoldAmount": undefined;
    /**
     * Can't find pair though trading path.
     */
    "InvalidPath": undefined;
    /**
     * Incorrect foreign amount range.
     */
    "IncorrectAssetAmountRange": undefined;
    /**
     * Overflow.
     */
    "Overflow": undefined;
    /**
     * Transaction block number is larger than the end block number.
     */
    "Deadline": undefined;
    /**
     * Location given was invalid or unsupported.
     */
    "AccountIdBadLocation": undefined;
    /**
     * XCM execution failed.
     */
    "ExecutionFailed": undefined;
    /**
     * Transfer to self by XCM message.
     */
    "DeniedTransferToSelf": undefined;
    /**
     * Not in ZenlinkRegistedParaChains.
     */
    "TargetChainNotRegistered": undefined;
    /**
     * Can't pass the K value check
     */
    "InvariantCheckFailed": undefined;
    /**
     * Created pair can't create now
     */
    "PairCreateForbidden": undefined;
    /**
     * Pair is not in bootstrap
     */
    "NotInBootstrap": undefined;
    /**
     * Amount of contribution is invalid.
     */
    "InvalidContributionAmount": undefined;
    /**
     * Amount of contribution is invalid.
     */
    "UnqualifiedBootstrap": undefined;
    /**
     * Zero contribute in bootstrap
     */
    "ZeroContribute": undefined;
    /**
     * Bootstrap deny refund
     */
    "DenyRefund": undefined;
    /**
     * Bootstrap is disable
     */
    "DisableBootstrap": undefined;
    /**
     * Not eligible to contribute
     */
    "NotQualifiedAccount": undefined;
    /**
     * Reward of bootstrap is not set.
     */
    "NoRewardTokens": undefined;
    /**
     * Charge bootstrap extrinsic args has error,
     */
    "ChargeRewardParamsError": undefined;
    /**
     * Exist some reward in bootstrap,
     */
    "ExistRewardsInBootstrap": undefined;
}>;
export type Iu66k013uv34p = AnonymousEnum<{
    /**
     * Invalid ISMP message
     */
    "InvalidMessage": undefined;
    /**
     * Requested message was not found
     */
    "MessageNotFound": undefined;
    /**
     * Encountered an error while creating the consensus client.
     */
    "ConsensusClientCreationFailed": undefined;
    /**
     * Couldn't update unbonding period
     */
    "UnbondingPeriodUpdateFailed": undefined;
    /**
     * Couldn't update challenge period
     */
    "ChallengePeriodUpdateFailed": undefined;
}>;
export type Ic0f75bbp58vde = AnonymousEnum<{
    /**
     * A asset that has not been registered
     */
    "UnregisteredAsset": undefined;
    /**
     * Error while teleporting asset
     */
    "AssetTeleportError": undefined;
    /**
     * Coprocessor was not configured in the runtime
     */
    "CoprocessorNotConfigured": undefined;
    /**
     * Asset or update Dispatch Error
     */
    "DispatchError": undefined;
    /**
     * Asset Id creation failed
     */
    "AssetCreationError": undefined;
    /**
     * Asset decimals not found
     */
    "AssetDecimalsNotFound": undefined;
    /**
     * Protocol Params have not been initialized
     */
    "NotInitialized": undefined;
    /**
     * Unknown Asset
     */
    "UnknownAsset": undefined;
    /**
     * BoundedVec conversion failed
     */
    "FailToConvert": undefined;
}>;
export type I4bah32pt0fjeb = AnonymousEnum<{
    /**
     * The account does not have enough balance to perform the operation.
     */
    "NotEnoughBalance": undefined;
    /**
     * An error occurred during currency conversion.
     */
    "ConversionError": undefined;
    /**
     * No weight or fee information is available for the requested operation.
     */
    "WeightAndFeeNotExist": undefined;
    /**
     * The message cannot be weighed, possibly due to insufficient information.
     */
    "UnweighableMessage": undefined;
    /**
     * The XCM execution has failed.
     */
    "XcmExecutionFailed": undefined;
    /**
     * The specified currency is not supported by the system.
     */
    "CurrencyNotSupport": undefined;
    /**
     * The maximum number of currencies that can be handled has been reached.
     */
    "MaxCurrenciesReached": undefined;
    /**
     * EVM permit expired.
     */
    "EvmPermitExpired": undefined;
    /**
     * EVM permit is invalid.
     */
    "EvmPermitInvalid": undefined;
    /**
     * EVM permit call failed.
     */
    "EvmPermitCallExecutionError": undefined;
    /**
     * EVM permit call failed.
     */
    "EvmPermitRunnerError": undefined;
    /**
     * Percentage calculation failed due to overflow.
     */
    "PercentageCalculationFailed": undefined;
}>;
export type Ikmpj1qpmlgg2 = AnonymousEnum<{
    /**
     * The first slot needs to at least be less than 3 `max_value`.
     */
    "FirstSlotTooFarInFuture": undefined;
    /**
     * Last slot must be greater than first slot.
     */
    "LastSlotBeforeFirstSlot": undefined;
    /**
     * The last slot cannot be more then 3 slots after the first slot.
     */
    "LastSlotTooFarInFuture": undefined;
    /**
     * There was an overflow.
     */
    "Overflow": undefined;
    /**
     * The contribution was below the minimum, `MinContribution`.
     */
    "ContributionTooSmall": undefined;
    /**
     * The account doesn't have any contribution to the fund.
     */
    "ZeroContribution": undefined;
    /**
     * Invalid fund index.
     */
    "InvalidParaId": undefined;
    /**
     * Invalid fund status.
     */
    "InvalidFundStatus": undefined;
    /**
     * Invalid contribution status.
     */
    "InvalidContributionStatus": undefined;
    /**
     * Contributions exceed maximum amount.
     */
    "CapExceeded": undefined;
    /**
     * The fund has been registered.
     */
    "FundAlreadyCreated": undefined;
    /**
     * Crosschain xcm failed
     */
    "XcmFailed": undefined;
    /**
     * Don't have enough vsToken/vsBond to refund
     */
    "NotEnoughReservedAssetsToRefund": undefined;
    /**
     * Don't have enough token to refund by users
     */
    "NotEnoughBalanceInRefundPool": undefined;
    /**
     * Don't have enough vsToken/vsBond to unlock
     */
    "NotEnoughBalanceToUnlock": undefined;
    /**
     * The vsBond is expired now
     */
    "VSBondExpired": undefined;
    /**
     * The vsBond cannot be redeemed by now
     */
    "UnRedeemableNow": undefined;
    /**
     * Dont have enough vsToken/vsBond to redeem
     */
    "NotEnoughFreeAssetsToRedeem": undefined;
    /**
     * Don't have enough token to redeem by users
     */
    "NotEnoughBalanceInRedeemPool": undefined;
    "NotEnoughBalanceInFund": undefined;
    "InvalidFundSameSlot": undefined;
    "InvalidFundNotExist": undefined;
    "InvalidRefund": undefined;
    "NotEnoughBalanceToContribute": undefined;
    "NotSupportTokenType": undefined;
    /**
     * Responder is not a relay chain
     */
    "ResponderNotRelayChain": undefined;
    /**
     * No contribution record found
     */
    "NotFindContributionValue": undefined;
    "ArgumentsError": undefined;
}>;
export type Ifdrdolunm5asr = AnonymousEnum<{
    /**
     * The given location could not be used (e.g. because it cannot be expressed in the
     * desired version of XCM).
     */
    "BadLocation": undefined;
    /**
     * Location existed
     */
    "LocationExisted": undefined;
    /**
     * AssetId not exists
     */
    "AssetIdNotExists": undefined;
    /**
     * AssetId exists
     */
    "AssetIdExisted": undefined;
    /**
     * CurrencyId not exists
     */
    "CurrencyIdNotExists": undefined;
    /**
     * CurrencyId exists
     */
    "CurrencyIdExisted": undefined;
}>;
export type I4sgpk7gabn1jg = AnonymousEnum<{
    /**
     * Below minimum mint amount.
     */
    "BelowMinimumMint": undefined;
    /**
     * Below minimum redeem amount.
     */
    "BelowMinimumRedeem": undefined;
    /**
     * Invalid token to rebond.
     */
    "InvalidRebondToken": undefined;
    /**
     * Token type not support.
     */
    "NotSupportTokenType": undefined;
    /**
     * Not enough balance to unlock.
     */
    "NotEnoughBalanceToUnlock": undefined;
    /**
     * Token unlock ledger not found.
     */
    "TokenToRebondNotZero": undefined;
    /**
     * Ongoing time unit not set.
     */
    "OngoingTimeUnitNotSet": undefined;
    /**
     * Token unlock ledger not found.
     */
    "TokenUnlockLedgerNotFound": undefined;
    /**
     * User unlock ledger not found.
     */
    "UserUnlockLedgerNotFound": undefined;
    /**
     * Time unit unlock ledger not found.
     */
    "TimeUnitUnlockLedgerNotFound": undefined;
    /**
     * Unlock duration not found.
     */
    "UnlockDurationNotFound": undefined;
    /**
     * Unexpected error.
     */
    "Unexpected": undefined;
    /**
     * Calculation overflow.
     */
    "CalculationOverflow": undefined;
    /**
     * Exceed maximum unlock id.
     */
    "ExceedMaximumUnlockId": undefined;
    /**
     * Too many redeems.
     */
    "TooManyRedeems": undefined;
    /**
     * Can not rebond.
     */
    "CanNotRebond": undefined;
    /**
     * Not enough balance.
     */
    "NotEnoughBalance": undefined;
    /**
     * veBNC checking error.
     */
    "VeBNCCheckingError": undefined;
    /**
     * IncentiveCoef not found.
     */
    "IncentiveCoefNotFound": undefined;
    /**
     * Too many locks.
     */
    "TooManyLocks": undefined;
    /**
     * No unlock record.
     */
    "NoUnlockRecord": undefined;
    /**
     * Fail to remove lock.
     */
    "FailToRemoveLock": undefined;
    /**
     * Balance not zero.
     */
    "BalanceZero": undefined;
    /**
     * IncentiveLockBlocksNotSet
     */
    "IncentiveLockBlocksNotSet": undefined;
    /**
     * VtokenIssuanceNotSet
     */
    "VtokenIssuanceNotSet": undefined;
}>;
export type I7d2j6upi68gp8 = AnonymousEnum<{
    "OperateOriginNotSet": undefined;
    "NotAuthorized": undefined;
    "NotSupportedCurrencyId": undefined;
    "FailToAddDelegator": undefined;
    "OverFlow": undefined;
    "UnderFlow": undefined;
    "NotExist": undefined;
    "LowerThanMinimum": undefined;
    "GreaterThanMaximum": undefined;
    "AlreadyBonded": undefined;
    "AccountNotExist": undefined;
    "DelegatorNotExist": undefined;
    "XcmFailure": undefined;
    "DelegatorNotBonded": undefined;
    "ExceedActiveMaximum": undefined;
    "ProblematicLedger": undefined;
    "NotEnoughToUnbond": undefined;
    "ExceedUnlockingRecords": undefined;
    "RebondExceedUnlockingAmount": undefined;
    "DecodingError": undefined;
    "EncodingError": undefined;
    "VectorEmpty": undefined;
    "ValidatorSetNotExist": undefined;
    "ValidatorNotExist": undefined;
    "InvalidTimeUnit": undefined;
    "AmountZero": undefined;
    "AmountNotZero": undefined;
    "AlreadyExist": undefined;
    "ValidatorStillInUse": undefined;
    "TimeUnitNotExist": undefined;
    "FeeSourceNotExist": undefined;
    "WeightAndFeeNotExists": undefined;
    "MinimumsAndMaximumsNotExist": undefined;
    "QueryNotExist": undefined;
    "DelaysNotExist": undefined;
    "Unexpected": undefined;
    "QueryResponseRemoveError": undefined;
    "InvalidHostingFee": undefined;
    "InvalidAccount": undefined;
    "IncreaseTokenPoolError": undefined;
    "TuneExchangeRateLimitNotSet": undefined;
    "CurrencyLatestTuneRecordNotExist": undefined;
    "InvalidTransferSource": undefined;
    "ValidatorNotProvided": undefined;
    "Unsupported": undefined;
    "ValidatorNotBonded": undefined;
    "AlreadyRequested": undefined;
    "RequestNotExist": undefined;
    "AlreadyLeaving": undefined;
    "DelegatorNotLeaving": undefined;
    "RequestNotDue": undefined;
    "LeavingNotDue": undefined;
    "DelegatorSetNotExist": undefined;
    "DelegatorLeaving": undefined;
    "DelegatorAlreadyLeaving": undefined;
    "ValidatorError": undefined;
    "AmountNone": undefined;
    "InvalidDelays": undefined;
    "OngoingTimeUnitUpdateIntervalNotExist": undefined;
    "LastTimeUpdatedOngoingTimeUnitNotExist": undefined;
    "TooFrequent": undefined;
    "DestAccountNotValid": undefined;
    "WhiteListNotExist": undefined;
    "DelegatorAlreadyTuned": undefined;
    "FeeTooHigh": undefined;
    "NotEnoughBalance": undefined;
    "VectorTooLong": undefined;
    "MultiCurrencyError": undefined;
    "NotDelegateValidator": undefined;
    "DividedByZero": undefined;
    "SharePriceNotValid": undefined;
    "InvalidAmount": undefined;
    "ValidatorMultilocationNotvalid": undefined;
    "AmountNotProvided": undefined;
    "FailToConvert": undefined;
    "ExceedMaxLengthLimit": undefined;
    /**
     * Transfer to failed
     */
    "TransferToError": undefined;
    "StablePoolNotFound": undefined;
    "StablePoolTokenIndexNotFound": undefined;
    "ExceedLimit": undefined;
    "InvalidPageNumber": undefined;
    "NoMoreValidatorBoostListForCurrency": undefined;
    /**
     * Hyperbridge price feed failed.
     */
    "HandleHyperbridgeOracleError": undefined;
}>;
export type Ienvs8qkad8lnj = AnonymousEnum<{
    /**
     * Failed to send XCM message.
     */
    "XcmSendFailed": undefined;
    /**
     * The weight and fee for the operation does not exist.
     */
    "OperationWeightAndFeeNotExist": undefined;
    /**
     * Failed to convert currency id.
     */
    "FailToConvert": undefined;
    /**
     * The message is unweighable.
     */
    "UnweighableMessage": undefined;
}>;
export type Iahrplfbd63p1f = AnonymousEnum<{
    "NotEnoughBalance": undefined;
    "NotSupportTokenType": undefined;
    "CalculationOverflow": undefined;
}>;
export type Idvt9vhbsepe42 = AnonymousEnum<{
    /**
     * The field tokens_proportion cannot be empty.
     */
    "NotNullable": undefined;
    /**
     * The pool does not exist.
     */
    "PoolDoesNotExist": undefined;
    /**
     * The gauge pool does not exist.
     */
    "GaugePoolNotExist": undefined;
    /**
     * The gauge info does not exist.
     */
    "GaugeInfoNotExist": undefined;
    /**
     * The pool is not in the correct state.
     */
    "InvalidPoolState": undefined;
    /**
     * claim_limit_time exceeded
     */
    "CanNotClaim": undefined;
    /**
     * gauge pool max_block exceeded
     */
    "GaugeMaxBlockOverflow": undefined;
    /**
     * withdraw_limit_time exceeded
     */
    "WithdrawLimitCountExceeded": undefined;
    /**
     * User's personal share info does not exist
     */
    "ShareInfoNotExists": undefined;
    /**
     * The current block height needs to be greater than the field after_block_to_start in
     * order to execute deposit.
     */
    "CanNotDeposit": undefined;
    /**
     * Whitelist cannot be empty
     */
    "WhitelistEmpty": undefined;
    /**
     * When starting a round, the field end_round needs to be 0 to indicate that the previous
     * round has ended.
     */
    "RoundNotOver": undefined;
    /**
     * The round length needs to be set when starting a round
     */
    "RoundLengthNotSet": undefined;
    /**
     * Whitelist maximum limit exceeded
     */
    "WhitelistLimitExceeded": undefined;
    /**
     * No one voted for this pool.
     */
    "NobodyVoting": undefined;
    /**
     * The pool is not in the whitelist
     */
    "NotInWhitelist": undefined;
    /**
     * The total voting percentage of users cannot exceed 100%.
     */
    "PercentOverflow": undefined;
    /**
     * The pool cannot be cleaned completely
     */
    "PoolNotCleared": undefined;
    /**
     * Invalid remove amount
     */
    "InvalidRemoveAmount": undefined;
    /**
     * User farming pool overflow
     */
    "UserFarmingPoolOverflow": undefined;
}>;
export type Ie8fttjg299r2c = AnonymousEnum<{
    /**
     * Invalid token config params
     */
    "InvalidTokenConfig": undefined;
    /**
     * exceed max token len
     */
    "ExceedMaxTokenLen": undefined;
    /**
     * exceed max poolid len
     */
    "ExceedMaxFarmingPoolidLen": undefined;
    /**
     * Token info not found
     */
    "TokenInfoNotFound": undefined;
    /**
     * payout error
     */
    "PayoutFailed": undefined;
    /**
     * Error converting Vec to BoundedVec.
     */
    "ConversionError": undefined;
}>;
export type Ierlpnhjmvhm3t = AnonymousEnum<{
    /**
     * Not support proportion
     */
    "NotSupportProportion": undefined;
    /**
     * Existential deposit
     */
    "ExistentialDeposit": undefined;
    /**
     * Distribution not exist
     */
    "DistributionNotExist": undefined;
    /**
     * Price oracle not ready
     */
    "PriceOracleNotReady": undefined;
    /**
     * Price is zero
     */
    "PriceIsZero": undefined;
    /**
     * Interval is zero
     */
    "IntervalIsZero": undefined;
    /**
     * Value is zero
     */
    "ValueIsZero": undefined;
    /**
     * Tokens proportions not cleared
     */
    "TokensProportionsNotCleared": undefined;
}>;
export type I7g8kiobl17ku6 = AnonymousEnum<{
    /**
     * Indicates that the balance is not sufficient for the requested operation.
     */
    "NotEnoughBalance": undefined;
    /**
     * Indicates that the specified item does not exist.
     */
    "NotExist": undefined;
    /**
     * Indicates that the operation is not allowed for the current context.
     */
    "NotAllowed": undefined;
    /**
     * Indicates that the currency does not support crossing in and out.
     */
    "CurrencyNotSupportCrossInAndOut": undefined;
    /**
     * Indicates that there is no mapping for the specified multilocation.
     */
    "NoMultilocationMapping": undefined;
    /**
     * Indicates that the item already exists.
     */
    "AlreadyExist": undefined;
    /**
     * Indicates that there is no minimum crossing amount set for the operation.
     */
    "NoCrossingMinimumSet": undefined;
    /**
     * Indicates that the specified amount is lower than the required minimum.
     */
    "AmountLowerThanMinimum": undefined;
    /**
     * Indicates that the list has reached its maximum capacity.
     */
    "ListOverflow": undefined;
}>;
export type I1pcsi4mugfb5o = AnonymousEnum<{
    /**
     * Not enough balance
     */
    "NotEnoughBalance": undefined;
    /**
     * Block number is expired
     */
    "Expired": undefined;
    /**
     * Below minimum mint
     */
    "BelowMinimumMint": undefined;
    /**
     * Lock does not exist
     */
    "LockNotExist": undefined;
    /**
     * Lock already exists
     */
    "LockExist": undefined;
    /**
     * Arguments error
     */
    "ArgumentsError": undefined;
    /**
     * Exceeds max positions
     */
    "ExceedsMaxPositions": undefined;
    /**
     * No controller
     */
    "NoController": undefined;
}>;
export type I75at17i6fmjmo = AnonymousEnum<{
    /**
     * Contract Account already exists in the whitelist
     */
    "AccountAlreadyExists": undefined;
    /**
     * Currency already exists in the whitelist
     */
    "CurrencyAlreadyExists": undefined;
    /**
     * Contract Account is not in the whitelist
     */
    "AccountNotFound": undefined;
    /**
     * Currency is not in the whitelist
     */
    "CurrencyNotFound": undefined;
    /**
     * The maximum number of whitelist addresses is 10
     */
    "WhitelistOverflow": undefined;
    /**
     * Execution fee not set
     */
    "NotSetExecutionFee": undefined;
    /**
     * Insufficient balance to execute the fee
     */
    "FreeBalanceTooLow": undefined;
    /**
     * The maximum number of order is 500
     */
    "OrderQueueOverflow": undefined;
    /**
     * The maximum number of currency id is 10
     */
    "CurrencyListOverflow": undefined;
    /**
     * Convert vtoken error
     */
    "ErrorConvertVtoken": undefined;
    /**
     * Error encode
     */
    "ErrorEncode": undefined;
    "ErrorValidating": undefined;
    "ErrorDelivering": undefined;
    "ErrorVtokenMiting": undefined;
    "ErrorTransferTo": undefined;
    "ErrorChargeFee": undefined;
    "ErrorArguments": undefined;
    "Unsupported": undefined;
    /**
     * Async Mint execution too frequent
     */
    "AsyncMintTooFrequent": undefined;
    /**
     * Async Mint issuance ratio too high
     */
    "AsyncMintIssuanceRatioTooHigh": undefined;
    /**
     * Async Mint configuration not set
     */
    "AsyncMintConfigNotSet": undefined;
    /**
     * Duplicate accounts in the exempt list
     */
    "DuplicateAccount": undefined;
}>;
export type Ib69hbq04ogo7t = AnonymousEnum<{
    /**
     * Account is already a member.
     */
    "AlreadyMember": undefined;
    /**
     * Account is not a member.
     */
    "NotMember": undefined;
    /**
     * The given poll index is unknown or has closed.
     */
    "NotPolling": undefined;
    /**
     * The given poll is still ongoing.
     */
    "Ongoing": undefined;
    /**
     * There are no further records to be removed.
     */
    "NoneRemaining": undefined;
    /**
     * Unexpected error in state.
     */
    "Corruption": undefined;
    /**
     * The member's rank is too low to vote.
     */
    "RankTooLow": undefined;
    /**
     * The information provided is incorrect.
     */
    "InvalidWitness": undefined;
    /**
     * The origin is not sufficiently privileged to do the operation.
     */
    "NoPermission": undefined;
    /**
     * The new member to exchange is the same as the old member
     */
    "SameMember": undefined;
    /**
     * The max member count for the rank has been reached.
     */
    "TooManyMembers": undefined;
}>;
export type Idhsrli8e2qcvl = AnonymousEnum<{
    /**
     * The pool is existed, cannot create again.
     */
    "InconsistentStorage": undefined;
    /**
     * The pool asset is invalid.
     */
    "InvalidPoolAsset": undefined;
    /**
     * The arguments are mismatch, not match the expected length.
     */
    "ArgumentsMismatch": undefined;
    /**
     * The arguments are error.
     */
    "ArgumentsError": undefined;
    /**
     * The pool is not found, cannot modify.
     */
    "PoolNotFound": undefined;
    /**
     * make mistakes in calculation.
     */
    "Math": undefined;
    /**
     * The new invariant of the pool is invalid.
     */
    "InvalidPoolValue": undefined;
    /**
     * The actual output amount is less than the expected minimum output amount when add
     * liquidity.
     */
    "MintUnderMin": undefined;
    /**
     * The actual output amount is less than the expected minimum output amount when swap.
     */
    "SwapUnderMin": undefined;
    /**
     * The actual output amount is less than the expected minimum output amount when redeem.
     */
    "RedeemUnderMin": undefined;
    /**
     * The actual input amount is more than the expected maximum input amount when redeem
     * multi.
     */
    "RedeemOverMax": undefined;
    /**
     * The old token rate is not cleared.
     */
    "TokenRateNotCleared": undefined;
}>;
export type I37baq92usopm0 = AnonymousEnum<{
    /**
     * A swap occurred, but the result is below the minimum swap amount.
     */
    "SwapUnderMin": undefined;
    /**
     * A minting operation occurred, but the minted amount is below the minimum mint amount.
     */
    "MintUnderMin": undefined;
    /**
     * Cannot mint tokens, possibly due to invalid parameters or illegal state.
     */
    "CantMint": undefined;
    /**
     * The redeemed amount exceeds the allowed maximum.
     */
    "RedeemOverMax": undefined;
    /**
     * The token rate is not set, preventing related operations.
     */
    "TokenRateNotSet": undefined;
}>;
export type If5eaevvg0u6lv = AnonymousEnum<{
    /**
     * XCM execution Failure
     */
    "XcmFailure": undefined;
    /**
     * The given currency is not supported.
     */
    "VTokenNotSupport": undefined;
    /**
     * Derivative index occupied.
     */
    "DerivativeIndexOccupied": undefined;
    /**
     * Another vote is pending.
     */
    "PendingVote": undefined;
    /**
     * Another update referendum status is pending.
     */
    "PendingUpdateReferendumStatus": undefined;
    /**
     * No data available in storage.
     */
    "NoData": undefined;
    /**
     * Poll is not ongoing.
     */
    "NotOngoing": undefined;
    /**
     * Poll is not completed.
     */
    "NotCompleted": undefined;
    /**
     * Poll is not killed.
     */
    "NotKilled": undefined;
    /**
     * Poll is not expired.
     */
    "NotExpired": undefined;
    /**
     * The given account did not vote on the poll.
     */
    "NotVoter": undefined;
    /**
     * The actor has no permission to conduct the action.
     */
    "NoPermission": undefined;
    /**
     * The actor has no permission to conduct the action right now but will do in the future.
     */
    "NoPermissionYet": undefined;
    /**
     * The account is already delegating.
     */
    "AlreadyDelegating": undefined;
    /**
     * Too high a balance was provided that the account cannot afford.
     */
    "InsufficientFunds": undefined;
    /**
     * Maximum number of votes reached.
     */
    "MaxVotesReached": undefined;
    /**
     * Maximum number of items reached.
     */
    "TooMany": undefined;
    /**
     * The given vote is not Standard vote.
     */
    "NotStandardVote": undefined;
    /**
     * The given conviction is not valid.
     */
    "InvalidConviction": undefined;
    /**
     * The given value is out of range.
     */
    "OutOfRange": undefined;
    "InvalidCallDispatch": undefined;
    "CallDecodeFailed": undefined;
    /**
     * Delegation to oneself makes no sense.
     */
    "Nonsense": undefined;
    /**
     * The account currently has votes attached to it and the operation cannot succeed until
     * these are removed through `remove_vote`.
     */
    "AlreadyVoting": undefined;
    /**
     * The account is not currently delegating.
     */
    "NotDelegating": undefined;
    /**
     * Try access poll Failure
     */
    "AccessPollFailure": undefined;
    /**
     * Too many votes for a delegate.
     */
    "TooManyVotes": undefined;
    /**
     * The parameter needs to pass in pollIndex.
     */
    "NeedPollIndex": undefined;
}>;
export type If47j4ahcl5iuf = AnonymousEnum<{
    /**
     * Insufficient liquidity to borrow more or disable collateral
     */
    "InsufficientLiquidity": undefined;
    /**
     * Insufficient deposit to redeem
     */
    "InsufficientDeposit": undefined;
    /**
     * Repay amount greater than allowed
     */
    "TooMuchRepay": undefined;
    /**
     * Asset already enabled/disabled collateral
     */
    "DuplicateOperation": undefined;
    /**
     * No deposit asset
     */
    "NoDeposit": undefined;
    /**
     * Repay amount more than collateral amount
     */
    "InsufficientCollateral": undefined;
    /**
     * Liquidator is same as borrower
     */
    "LiquidatorIsBorrower": undefined;
    /**
     * Deposits are not used as a collateral
     */
    "DepositsAreNotCollateral": undefined;
    /**
     * Insufficient shortfall to repay
     */
    "InsufficientShortfall": undefined;
    /**
     * Insufficient reserves
     */
    "InsufficientReserves": undefined;
    /**
     * Invalid rate model params
     */
    "InvalidRateModelParam": undefined;
    /**
     * Market not activated
     */
    "MarketNotActivated": undefined;
    /**
     * Oracle price not ready
     */
    "PriceOracleNotReady": undefined;
    /**
     * Oracle price is zero
     */
    "PriceIsZero": undefined;
    /**
     * Invalid asset id
     */
    "InvalidCurrencyId": undefined;
    /**
     * Invalid lend token id
     */
    "InvalidLendTokenId": undefined;
    /**
     * Market does not exist
     */
    "MarketDoesNotExist": undefined;
    /**
     * Market already exists
     */
    "MarketAlreadyExists": undefined;
    /**
     * New markets must have a pending state
     */
    "NewMarketMustHavePendingState": undefined;
    /**
     * Upper bound of supplying is exceeded
     */
    "SupplyCapacityExceeded": undefined;
    /**
     * Upper bound of borrowing is exceeded
     */
    "BorrowCapacityExceeded": undefined;
    /**
     * Insufficient cash in the pool
     */
    "InsufficientCash": undefined;
    /**
     * The factor should be greater than 0% and less than 100%
     */
    "InvalidFactor": undefined;
    /**
     * The supply cap cannot be zero
     */
    "InvalidSupplyCap": undefined;
    /**
     * The exchange rate should be greater than 0.02 and less than 1
     */
    "InvalidExchangeRate": undefined;
    /**
     * Amount cannot be zero
     */
    "InvalidAmount": undefined;
    /**
     * Payer cannot be signer
     */
    "PayerIsSigner": undefined;
    /**
     * Codec error
     */
    "CodecError": undefined;
    /**
     * Collateral is reserved and cannot be liquidated
     */
    "CollateralReserved": undefined;
    /**
     * Market bond does not exist
     */
    "MarketBondDoesNotExist": undefined;
    /**
     * Error converting Vec to BoundedVec.
     */
    "ConversionError": undefined;
}>;
export type Ibbhs1otrrm5i1 = AnonymousEnum<{
    /**
     * Sender does not have permission
     */
    "NoPermission": undefined;
    /**
     * Feeder has already fed at this block
     */
    "AlreadyFeeded": undefined;
}>;
export type Ie3flrv31mi7gh = AnonymousEnum<{
    /**
     * Already a member.
     */
    "AlreadyMember": undefined;
    /**
     * Not a member.
     */
    "NotMember": undefined;
    /**
     * Too many members.
     */
    "TooManyMembers": undefined;
}>;
export type I5hife89is4rs2 = AnonymousEnum<{
    /**
     * Arguments error, old rate is equal to new rate
     */
    "ArgumentsError": undefined;
    /**
     * Not support token type
     */
    "NotSupportTokenType": undefined;
}>;
export type Idoo1gokjlqeae = AnonymousEnum<{
    /**
     * Overflow error, indicating that a mathematical operation exceeded the allowed numeric range.
     */
    "Overflow": undefined;
    /**
     * Error indicating that the provided channel name exceeds the maximum allowed length.
     */
    "ChannelNameTooLong": undefined;
    /**
     * Conversion error, indicating a failure during a type conversion operation.
     */
    "ConversionError": undefined;
    /**
     * Error indicating that the specified channel does not exist in storage.
     */
    "ChannelNotExist": undefined;
    /**
     * Transfer error, indicating that a fund transfer operation has failed.
     */
    "TransferError": undefined;
    /**
     * Error indicating that the vToken is not configured for commission calculations.
     */
    "VtokenNotConfiguredForCommission": undefined;
    /**
     * Invalid commission rate, indicating that the provided commission rate is out of range or malformed.
     */
    "InvalidCommissionRate": undefined;
    /**
     * Error indicating that the commission token has already been set and cannot be reconfigured.
     */
    "CommissionTokenAlreadySet": undefined;
    /**
     * Invalid vToken, indicating that the provided vToken is invalid or unrecognized.
     */
    "InvalidVtoken": undefined;
    /**
     * Error indicating that no changes were made during a modification operation.
     * This means that a modification request was issued but did not result in any actual changes.
     */
    "NoChangesMade": undefined;
    /**
     * Error indicating a division operation encountered a divisor of zero.
     * This is a critical error, as division by zero is undefined and cannot be performed.
     */
    "DivisionByZero": undefined;
    /**
     * Error indicating that the removal operation was not successfully completed.
     * This means an attempt to remove a resource or record did not succeed.
     */
    "RemovalNotComplete": undefined;
    /**
     * Error indicating a failure during token-to-vToken conversion via exchange rate calculation.
     * This can occur when the conversion formula encounters an unexpected condition or invalid input.
     */
    "TokenToVtokenConversionFailed": undefined;
}>;
export type If5rlmcl3m09tr = AnonymousEnum<{
    "NotEnoughBalance": undefined;
    "CalculationOverflow": undefined;
    "LessThanExpected": undefined;
    "LessThanExistentialDeposit": undefined;
}>;
export type Iqrtuhjkceatk = AnonymousEnum<{
    /**
     * Insufficient balance.
     */
    "NotEnoughBalance": undefined;
    /**
     * Currency does not exist.
     */
    "CurrencyIdNotExists": undefined;
    /**
     * Currency is not supported.
     */
    "CurrencyIdError": undefined;
    /**
     * Duration can't be zero.
     */
    "ZeroDuration": undefined;
    /**
     * Field min_swap_value can't be zero.
     */
    "ZeroMinSwapValue": undefined;
}>;
export type I2e3a0uivkcoam = AnonymousEnum<{
    /**
     * Delegator index has exceeded the maximum allowed value of 65535.
     */
    "DelegatorIndexOverflow": undefined;
    /**
     * The maximum number of validators has been reached.
     */
    "ValidatorsOverflow": undefined;
    /**
     * UnlockRecordOverflow
     */
    "UnlockRecordOverflow": undefined;
    /**
     * The staking protocol is not supported.
     */
    "UnsupportedStakingProtocol": undefined;
    /**
     * The delegator index was not found.
     */
    "DelegatorIndexNotFound": undefined;
    /**
     * The Configuration was not found.
     */
    "ConfigurationNotFound": undefined;
    /**
     * The delegator was not found.
     */
    "DelegatorNotFound": undefined;
    /**
     * The ledger was not found.
     */
    "LedgerNotFound": undefined;
    /**
     * The validator was not found.
     */
    "ValidatorNotFound": undefined;
    /**
     * Missing XCM fee value.
     */
    "XcmFeeNotFound": undefined;
    /**
     * Missing pending status.
     */
    "PendingStatusNotFound": undefined;
    /**
     * The specified time unit does not exist.
     */
    "TimeUnitNotFound": undefined;
    /**
     * The delegator already exists.
     */
    "DelegatorAlreadyExists": undefined;
    /**
     * The delegator index already exists.
     */
    "DelegatorIndexAlreadyExists": undefined;
    /**
     * The validator already exists.
     */
    "ValidatorAlreadyExists": undefined;
    /**
     * Failed to derive the derivative account ID.
     */
    "DerivativeAccountIdFailed": undefined;
    /**
     * Error during validation.
     */
    "ValidatingFailed": undefined;
    /**
     * Error during delivery.
     */
    "DeliveringFailed": undefined;
    /**
     * calculate protocol fee failed.
     */
    "CalculateProtocolFeeFailed": undefined;
    /**
     * IncreaseTokenPoolFailed
     */
    "IncreaseTokenPoolFailed": undefined;
    /**
     * The update interval is too short.
     */
    "UpdateIntervalTooShort": undefined;
    /**
     * The specified token exchange rate amount is too large.
     */
    "UpdateTokenExchangeRateAmountTooLarge": undefined;
    /**
     * Invalid parameter.
     */
    "InvalidParameter": undefined;
    /**
     * Not authorized.
     */
    "NotAuthorized": undefined;
}>;
export type I92lvnr2lhfkjg = {
    "code_hash": FixedSizeBinary<32>;
    "error": Anonymize<I46mg5gru1rk0a>;
};
export type I9ulgod11dfvq5 = AnonymousEnum<{
    /**
     * This pallet, or a specific call is now paused.
     */
    "CallPaused": Anonymize<Iba7pefg0d11kh>;
    /**
     * This pallet, or a specific call is now unpaused.
     */
    "CallUnpaused": Anonymize<Iba7pefg0d11kh>;
}>;
export type Iba7pefg0d11kh = {
    "full_name": Anonymize<Idkbvh6dahk1v7>;
};
export type I836ha9codfrm6 = AnonymousEnum<{
    /**
     * Started new round.
     */
    "NewRound": Anonymize<I68vefv6bi40pm>;
    /**
     * Account joined the set of collator candidates.
     */
    "JoinedCollatorCandidates": Anonymize<I2tar7hv83bhs9>;
    /**
     * Candidate selected for collators. Total Exposed Amount includes all delegations.
     */
    "CollatorChosen": Anonymize<I7m6jdbthkclds>;
    /**
     * Candidate requested to decrease a self bond.
     */
    "CandidateBondLessRequested": Anonymize<Idcbd1egqu902f>;
    /**
     * Candidate has increased a self bond.
     */
    "CandidateBondedMore": Anonymize<I4b9s9ufqtqpag>;
    /**
     * Candidate has decreased a self bond.
     */
    "CandidateBondedLess": Anonymize<I2prd76if4ekis>;
    /**
     * Candidate temporarily leave the set of collator candidates without unbonding.
     */
    "CandidateWentOffline": Anonymize<I4b66js88p45m8>;
    /**
     * Candidate rejoins the set of collator candidates.
     */
    "CandidateBackOnline": Anonymize<I4b66js88p45m8>;
    /**
     * Candidate has requested to leave the set of candidates.
     */
    "CandidateScheduledExit": Anonymize<I8uo8rqvrpdign>;
    /**
     * Cancelled request to leave the set of candidates.
     */
    "CancelledCandidateExit": Anonymize<I4b66js88p45m8>;
    /**
     * Cancelled request to decrease candidate's bond.
     */
    "CancelledCandidateBondLess": Anonymize<Idn49754fsdtru>;
    /**
     * Candidate has left the set of candidates.
     */
    "CandidateLeft": Anonymize<I680fmn7ufn665>;
    /**
     * Delegator requested to decrease a bond for the collator candidate.
     */
    "DelegationDecreaseScheduled": Anonymize<I369fnsmd2kjhd>;
    "DelegationIncreased": Anonymize<I2a4el6f8bntsn>;
    "DelegationDecreased": Anonymize<I2a4el6f8bntsn>;
    /**
     * Delegator requested to leave the set of delegators.
     */
    "DelegatorExitScheduled": Anonymize<Igut3khe172gn>;
    /**
     * Delegator requested to revoke delegation.
     */
    "DelegationRevocationScheduled": Anonymize<I7oac900a2ho0o>;
    /**
     * Delegator has left the set of delegators.
     */
    "DelegatorLeft": Anonymize<I7bui4st6iq68m>;
    /**
     * Delegation revoked.
     */
    "DelegationRevoked": Anonymize<I27psftcg9098g>;
    /**
     * Delegation kicked.
     */
    "DelegationKicked": Anonymize<I27psftcg9098g>;
    /**
     * Cancelled a pending request to exit the set of delegators.
     */
    "DelegatorExitCancelled": Anonymize<Icuam3sm8vhog2>;
    /**
     * Cancelled request to change an existing delegation.
     */
    "CancelledDelegationRequest": Anonymize<Ifjv4i6s7q1stt>;
    /**
     * New delegation (increase of the existing one).
     */
    "Delegation": Anonymize<Id1re1vndv0kab>;
    /**
     * Delegation from candidate state has been remove.
     */
    "DelegatorLeftCandidate": Anonymize<Ie3dfke5vrt21s>;
    /**
     * Paid the account (delegator or collator) the balance as liquid rewards.
     */
    "Rewarded": Anonymize<Ibl3t1j4prdqji>;
    /**
     * Transferred to account which holds funds reserved for parachain bond.
     */
    "ReservedForParachainBond": Anonymize<I7j4m7a3pkvsf4>;
    /**
     * Account (re)set for parachain bond treasury.
     */
    "ParachainBondAccountSet": Anonymize<Id9sjif2ghpo08>;
    /**
     * Percent of inflation reserved for parachain bond (re)set.
     */
    "ParachainBondReservePercentSet": Anonymize<I6fomjr8ghrs40>;
    /**
     * Annual inflation input (first 3) was used to derive new per-round inflation (last 3)
     */
    "InflationSet": Anonymize<I8jjc8aeseo568>;
    /**
     * Staking expectations set.
     */
    "StakeExpectationsSet": Anonymize<Ia48s8or178ack>;
    /**
     * Set total selected candidates to this value.
     */
    "TotalSelectedSet": Anonymize<I6fomjr8ghrs40>;
    /**
     * Set collator commission to this value.
     */
    "CollatorCommissionSet": Anonymize<I6fomjr8ghrs40>;
    /**
     * Set blocks per round
     */
    "BlocksPerRoundSet": Anonymize<I25jemnddpsl99>;
}>;
export type I2tar7hv83bhs9 = {
    "account": SS58String;
    "amount_locked": bigint;
    "new_total_amt_locked": bigint;
};
export type I7m6jdbthkclds = {
    "round": number;
    "collator_account": SS58String;
    "total_exposed_amount": bigint;
};
export type Idcbd1egqu902f = {
    "candidate": SS58String;
    "amount_to_decrease": bigint;
    "execute_round": number;
};
export type I4b9s9ufqtqpag = {
    "candidate": SS58String;
    "amount": bigint;
    "new_total_bond": bigint;
};
export type I2prd76if4ekis = {
    "candidate": SS58String;
    "amount": bigint;
    "new_bond": bigint;
};
export type I4b66js88p45m8 = {
    "candidate": SS58String;
};
export type I8uo8rqvrpdign = {
    "exit_allowed_round": number;
    "candidate": SS58String;
    "scheduled_exit": number;
};
export type Idn49754fsdtru = {
    "candidate": SS58String;
    "amount": bigint;
    "execute_round": number;
};
export type I680fmn7ufn665 = {
    "ex_candidate": SS58String;
    "unlocked_amount": bigint;
    "new_total_amt_locked": bigint;
};
export type I369fnsmd2kjhd = {
    "delegator": SS58String;
    "candidate": SS58String;
    "amount_to_decrease": bigint;
    "execute_round": number;
};
export type I2a4el6f8bntsn = {
    "delegator": SS58String;
    "candidate": SS58String;
    "amount": bigint;
    "in_top": boolean;
};
export type Igut3khe172gn = {
    "round": number;
    "delegator": SS58String;
    "scheduled_exit": number;
};
export type I7oac900a2ho0o = {
    "round": number;
    "delegator": SS58String;
    "candidate": SS58String;
    "scheduled_exit": number;
};
export type I7bui4st6iq68m = {
    "delegator": SS58String;
    "unstaked_amount": bigint;
};
export type I27psftcg9098g = {
    "delegator": SS58String;
    "candidate": SS58String;
    "unstaked_amount": bigint;
};
export type Icuam3sm8vhog2 = {
    "delegator": SS58String;
};
export type Ifjv4i6s7q1stt = {
    "delegator": SS58String;
    "cancelled_request": Anonymize<I99jrare3vnf02>;
    "collator": SS58String;
};
export type Id1re1vndv0kab = {
    "delegator": SS58String;
    "locked_amount": bigint;
    "candidate": SS58String;
    "delegator_position": Anonymize<Ibml0ipjqum8cv>;
};
export type Ie3dfke5vrt21s = {
    "delegator": SS58String;
    "candidate": SS58String;
    "unstaked_amount": bigint;
    "total_candidate_staked": bigint;
};
export type Ibl3t1j4prdqji = {
    "account": SS58String;
    "rewards": bigint;
};
export type Id9sjif2ghpo08 = {
    "old": SS58String;
    "new": SS58String;
};
export type I4llkm1lp1bigd = AnonymousEnum<{
    "CallWhitelisted": Anonymize<I1adbcfi5uc62r>;
    "WhitelistedCallRemoved": Anonymize<I1adbcfi5uc62r>;
    "WhitelistedCallDispatched": Anonymize<Iao0880t6bdk6t>;
}>;
export type Iao0880t6bdk6t = {
    "call_hash": FixedSizeBinary<32>;
    "result": Anonymize<Idk1gjo1nphf83>;
};
export type Idk1gjo1nphf83 = ResultPayload<Anonymize<Ia1u1r3n74r13c>, {
    "post_info": Anonymize<Ia1u1r3n74r13c>;
    "error": Anonymize<I46mg5gru1rk0a>;
}>;
export type I2h4rf2ad4tlre = AnonymousEnum<{
    /**
     * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
     * well as the error.
     */
    "BatchInterrupted": Anonymize<I559a3l6k1tuhi>;
    /**
     * Batch of dispatches completed fully with no error.
     */
    "BatchCompleted": undefined;
    /**
     * Batch of dispatches completed but has errors.
     */
    "BatchCompletedWithErrors": undefined;
    /**
     * A single item within a Batch of dispatches has completed with no error.
     */
    "ItemCompleted": undefined;
    /**
     * A single item within a Batch of dispatches has completed with error.
     */
    "ItemFailed": Anonymize<Ia74hfkpnt69k4>;
    /**
     * A call was dispatched.
     */
    "DispatchedAs": Anonymize<Icdh3rm93onuu7>;
    /**
     * Main call was dispatched.
     */
    "IfElseMainSuccess": undefined;
    /**
     * The fallback call was dispatched.
     */
    "IfElseFallbackCalled": Anonymize<Ic8o3lkomig9pc>;
}>;
export type I559a3l6k1tuhi = {
    "index": number;
    "error": Anonymize<I46mg5gru1rk0a>;
};
export type Ia74hfkpnt69k4 = {
    "error": Anonymize<I46mg5gru1rk0a>;
};
export type Icdh3rm93onuu7 = {
    "result": Anonymize<I5sjue8i9nndg4>;
};
export type I5sjue8i9nndg4 = ResultPayload<undefined, Anonymize<I46mg5gru1rk0a>>;
export type Ic8o3lkomig9pc = {
    "main_error": Anonymize<I46mg5gru1rk0a>;
};
export type Ic4skm7au89frs = AnonymousEnum<{
    /**
     * Scheduled some task.
     */
    "Scheduled": Anonymize<I5n4sebgkfr760>;
    /**
     * Canceled some task.
     */
    "Canceled": Anonymize<I5n4sebgkfr760>;
    /**
     * Dispatched some task.
     */
    "Dispatched": Anonymize<I5fbs546684p2n>;
    /**
     * Set a retry configuration for some task.
     */
    "RetrySet": Anonymize<Ia3c82eadg79bj>;
    /**
     * Cancel a retry configuration for some task.
     */
    "RetryCancelled": Anonymize<Ienusoeb625ftq>;
    /**
     * The call for the provided hash was not found so the task has been aborted.
     */
    "CallUnavailable": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task was unable to be renewed since the agenda is full at that block.
     */
    "PeriodicFailed": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task was unable to be retried since the agenda is full at that block or there
     * was not enough weight to reschedule it.
     */
    "RetryFailed": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task can never be executed since it is overweight.
     */
    "PermanentlyOverweight": Anonymize<Ienusoeb625ftq>;
    /**
     * Agenda is incomplete from `when`.
     */
    "AgendaIncomplete": Anonymize<Ibtsa3docbr9el>;
}>;
export type I5fbs546684p2n = {
    "task": Anonymize<I9jd27rnpm8ttv>;
    "id"?: Anonymize<I4s6vifaf8k998>;
    "result": Anonymize<I5sjue8i9nndg4>;
};
export type I7j4vibq8brbq0 = AnonymousEnum<{
    /**
     * A proxy was executed correctly, with the given.
     */
    "ProxyExecuted": Anonymize<Icdh3rm93onuu7>;
    /**
     * A pure account has been created by new proxy with given
     * disambiguation index and proxy type.
     */
    "PureCreated": Anonymize<I7svoh0vdq580e>;
    /**
     * An announcement was placed to make a call in the future.
     */
    "Announced": Anonymize<I2ur0oeqg495j8>;
    /**
     * A proxy was added.
     */
    "ProxyAdded": Anonymize<I8isvjsseb7fjo>;
    /**
     * A proxy was removed.
     */
    "ProxyRemoved": Anonymize<I8isvjsseb7fjo>;
    /**
     * A deposit stored for proxies or announcements was poked / updated.
     */
    "DepositPoked": Anonymize<I1bhd210c3phjj>;
}>;
export type I7svoh0vdq580e = {
    "pure": SS58String;
    "who": SS58String;
    "proxy_type": Anonymize<Iebopc45bqaiad>;
    "disambiguation_index": number;
};
export type Iebopc45bqaiad = AnonymousEnum<{
    "Any": undefined;
    "NonTransfer": undefined;
    "Governance": undefined;
    "CancelProxy": undefined;
    "IdentityJudgement": undefined;
    "Staking": undefined;
}>;
export type I8isvjsseb7fjo = {
    "delegator": SS58String;
    "delegatee": SS58String;
    "proxy_type": Anonymize<Iebopc45bqaiad>;
    "delay": number;
};
export type I9dua8dbe792fr = AnonymousEnum<{
    /**
     * A new multisig operation has begun.
     */
    "NewMultisig": Anonymize<Iep27ialq4a7o7>;
    /**
     * A multisig operation has been approved by someone.
     */
    "MultisigApproval": Anonymize<Iasu5jvoqr43mv>;
    /**
     * A multisig operation has been executed.
     */
    "MultisigExecuted": Anonymize<I2e077c652dip6>;
    /**
     * A multisig operation has been cancelled.
     */
    "MultisigCancelled": Anonymize<I5qolde99acmd1>;
    /**
     * The deposit for a multisig operation has been updated/poked.
     */
    "DepositPoked": Anonymize<I8gtde5abn1g9a>;
}>;
export type I2e077c652dip6 = {
    "approving": SS58String;
    "timepoint": Anonymize<Itvprrpb0nm3o>;
    "multisig": SS58String;
    "call_hash": FixedSizeBinary<32>;
    "result": Anonymize<I5sjue8i9nndg4>;
};
export type I2au2or9cskfoi = AnonymousEnum<{
    /**
     * A name was set or reset (which will remove all judgements).
     */
    "IdentitySet": Anonymize<I4cbvqmqadhrea>;
    /**
     * A name was cleared, and the given balance returned.
     */
    "IdentityCleared": Anonymize<Iep1lmt6q3s6r3>;
    /**
     * A name was removed and the given balance slashed.
     */
    "IdentityKilled": Anonymize<Iep1lmt6q3s6r3>;
    /**
     * A judgement was asked from a registrar.
     */
    "JudgementRequested": Anonymize<I1fac16213rie2>;
    /**
     * A judgement request was retracted.
     */
    "JudgementUnrequested": Anonymize<I1fac16213rie2>;
    /**
     * A judgement was given by a registrar.
     */
    "JudgementGiven": Anonymize<Ifjt77oc391o43>;
    /**
     * A registrar was added.
     */
    "RegistrarAdded": Anonymize<Itvt1jsipv0lc>;
    /**
     * A sub-identity was added to an identity and the deposit paid.
     */
    "SubIdentityAdded": Anonymize<Ick3mveut33f44>;
    /**
     * An account's sub-identities were set (in bulk).
     */
    "SubIdentitiesSet": Anonymize<I719lqkkbtikbl>;
    /**
     * A given sub-account's associated name was changed by its super-identity.
     */
    "SubIdentityRenamed": Anonymize<Ie4intrc3n8jfu>;
    /**
     * A sub-identity was removed from an identity and the deposit freed.
     */
    "SubIdentityRemoved": Anonymize<Ick3mveut33f44>;
    /**
     * A sub-identity was cleared, and the given deposit repatriated from the
     * main identity account to the sub-identity account.
     */
    "SubIdentityRevoked": Anonymize<Ick3mveut33f44>;
    /**
     * A username authority was added.
     */
    "AuthorityAdded": Anonymize<I2rg5btjrsqec0>;
    /**
     * A username authority was removed.
     */
    "AuthorityRemoved": Anonymize<I2rg5btjrsqec0>;
    /**
     * A username was set for `who`.
     */
    "UsernameSet": Anonymize<Ibdqerrooruuq9>;
    /**
     * A username was queued, but `who` must accept it prior to `expiration`.
     */
    "UsernameQueued": Anonymize<I8u2ba9jeiu6q0>;
    /**
     * A queued username passed its expiration without being claimed and was removed.
     */
    "PreapprovalExpired": Anonymize<I7ieadb293k6b4>;
    /**
     * A username was set as a primary and can be looked up from `who`.
     */
    "PrimaryUsernameSet": Anonymize<Ibdqerrooruuq9>;
    /**
     * A dangling username (as in, a username corresponding to an account that has removed its
     * identity) has been removed.
     */
    "DanglingUsernameRemoved": Anonymize<Ibdqerrooruuq9>;
    /**
     * A username has been unbound.
     */
    "UsernameUnbound": Anonymize<Ie5l999tf7t2te>;
    /**
     * A username has been removed.
     */
    "UsernameRemoved": Anonymize<Ie5l999tf7t2te>;
    /**
     * A username has been killed.
     */
    "UsernameKilled": Anonymize<Ie5l999tf7t2te>;
}>;
export type Iep1lmt6q3s6r3 = {
    "who": SS58String;
    "deposit": bigint;
};
export type I1fac16213rie2 = {
    "who": SS58String;
    "registrar_index": number;
};
export type Ifjt77oc391o43 = {
    "target": SS58String;
    "registrar_index": number;
};
export type Ick3mveut33f44 = {
    "sub": SS58String;
    "main": SS58String;
    "deposit": bigint;
};
export type I719lqkkbtikbl = {
    "main": SS58String;
    "number_of_subs": number;
    "new_deposit": bigint;
};
export type Ie4intrc3n8jfu = {
    "sub": SS58String;
    "main": SS58String;
};
export type I2rg5btjrsqec0 = {
    "authority": SS58String;
};
export type Ibdqerrooruuq9 = {
    "who": SS58String;
    "username": Binary;
};
export type I8u2ba9jeiu6q0 = {
    "who": SS58String;
    "username": Binary;
    "expiration": number;
};
export type I7ieadb293k6b4 = {
    "whose": SS58String;
};
export type I3kfo09eqm1214 = AnonymousEnum<{
    /**
     * We have ended a spend period and will now allocate funds.
     */
    "Spending": Anonymize<I8iksqi3eani0a>;
    /**
     * Some funds have been allocated.
     */
    "Awarded": Anonymize<I16enopmju1p0q>;
    /**
     * Some of our funds have been burnt.
     */
    "Burnt": Anonymize<I43kq8qudg7pq9>;
    /**
     * Spending has finished; this is the amount that rolls over until next spend.
     */
    "Rollover": Anonymize<I76riseemre533>;
    /**
     * Some funds have been deposited.
     */
    "Deposit": Anonymize<Ie5v6njpckr05b>;
    /**
     * A new spend proposal has been approved.
     */
    "SpendApproved": Anonymize<I38bmcrmh852rk>;
    /**
     * The inactive funds of the pallet have been updated.
     */
    "UpdatedInactive": Anonymize<I4hcillge8de5f>;
    /**
     * A new asset spend proposal has been approved.
     */
    "AssetSpendApproved": Anonymize<I8usdc6tg7829p>;
    /**
     * An approved spend was voided.
     */
    "AssetSpendVoided": Anonymize<I666bl2fqjkejo>;
    /**
     * A payment happened.
     */
    "Paid": Anonymize<I666bl2fqjkejo>;
    /**
     * A payment failed and can be retried.
     */
    "PaymentFailed": Anonymize<I666bl2fqjkejo>;
    /**
     * A spend was processed and removed from the storage. It might have been successfully
     * paid or it may have expired.
     */
    "SpendProcessed": Anonymize<I666bl2fqjkejo>;
}>;
export type I8usdc6tg7829p = {
    "index": number;
    "amount": bigint;
    "beneficiary": SS58String;
    "valid_from": number;
    "expire_at": number;
};
export type I71u7do1ao6vjp = AnonymousEnum<{
    /**
     * Binding was created.
     */
    "Bound": Anonymize<I8363i1h1dgh0n>;
    /**
     * Deployer was added.
     */
    "DeployerAdded": Anonymize<Ibqjgs3foip9fb>;
    /**
     * Deployer was removed.
     */
    "DeployerRemoved": Anonymize<Ibqjgs3foip9fb>;
}>;
export type I8363i1h1dgh0n = {
    "account": SS58String;
    "address": FixedSizeBinary<20>;
};
export type Ibqjgs3foip9fb = {
    "who": FixedSizeBinary<20>;
};
export type I1kj6lnq7rdnrl = AnonymousEnum<{
    /**
     * Transferred `Asset` with fee.
     */
    "TransferredAssets": Anonymize<I1hgaklii9a5gl>;
}>;
export type I1hgaklii9a5gl = {
    "sender": SS58String;
    "assets": Anonymize<I4npjalvhmfuj>;
    "fee": Anonymize<Iffh1nc5e1mod6>;
    "dest": Anonymize<If9iqq7i64mur8>;
};
export type I4oigsiqtj1dkn = AnonymousEnum<{
    /**
     * An account was created with some free balance.
     */
    "Endowed": Anonymize<I3d8ss06imalrs>;
    /**
     * An account was removed whose balance was non-zero but below
     * ExistentialDeposit, resulting in an outright loss.
     */
    "DustLost": Anonymize<I3d8ss06imalrs>;
    /**
     * Transfer succeeded.
     */
    "Transfer": Anonymize<I1452l7htqmdul>;
    /**
     * Some balance was reserved (moved from free to reserved).
     */
    "Reserved": Anonymize<I3d8ss06imalrs>;
    /**
     * Some balance was unreserved (moved from reserved to free).
     */
    "Unreserved": Anonymize<I3d8ss06imalrs>;
    /**
     * Some reserved balance was repatriated (moved from reserved to
     * another account).
     */
    "ReserveRepatriated": Anonymize<I5k7trgmhddpc9>;
    /**
     * A balance was set by root.
     */
    "BalanceSet": Anonymize<Ifg1v23kle5pvs>;
    /**
     * The total issuance of an currency has been set
     */
    "TotalIssuanceSet": Anonymize<Ic7aob2k1l1jfu>;
    /**
     * Some balances were withdrawn (e.g. pay for transaction fee)
     */
    "Withdrawn": Anonymize<I3d8ss06imalrs>;
    /**
     * Some balances were slashed (e.g. due to mis-behavior)
     */
    "Slashed": Anonymize<Idog3297nuhubu>;
    /**
     * Deposited some balance into an account
     */
    "Deposited": Anonymize<I3d8ss06imalrs>;
    /**
     * Some funds are locked
     */
    "LockSet": Anonymize<I7aphsup25pr8u>;
    /**
     * Some locked funds were unlocked
     */
    "LockRemoved": Anonymize<Id9ivc2gke7kda>;
    /**
     * Some free balance was locked.
     */
    "Locked": Anonymize<I3d8ss06imalrs>;
    /**
     * Some locked balance was freed.
     */
    "Unlocked": Anonymize<I3d8ss06imalrs>;
    "Issued": Anonymize<Ic7aob2k1l1jfu>;
    "Rescinded": Anonymize<Ic7aob2k1l1jfu>;
}>;
export type I3d8ss06imalrs = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": SS58String;
    "amount": bigint;
};
export type Iebirugq1dbhv6 = AnonymousEnum<{
    "Native": Anonymize<I3tfkbkbc856i7>;
    "VToken": Anonymize<I3tfkbkbc856i7>;
    "Token": Anonymize<I3tfkbkbc856i7>;
    "Stable": Anonymize<I3tfkbkbc856i7>;
    "VSToken": Anonymize<I3tfkbkbc856i7>;
    "VSBond": [Anonymize<I3tfkbkbc856i7>, number, number, number];
    "LPToken": [Anonymize<I3tfkbkbc856i7>, number, Anonymize<I3tfkbkbc856i7>, number];
    "ForeignAsset": number;
    "Token2": number;
    "VToken2": number;
    "VSToken2": number;
    "VSBond2": [number, number, number, number];
    "StableLpToken": number;
    "BLP": number;
    "Lend": number;
}>;
export type I3tfkbkbc856i7 = AnonymousEnum<{
    "ASG": undefined;
    "BNC": undefined;
    "KUSD": undefined;
    "DOT": undefined;
    "KSM": undefined;
    "ETH": undefined;
    "KAR": undefined;
    "ZLK": undefined;
    "PHA": undefined;
    "RMRK": undefined;
    "MOVR": undefined;
}>;
export type I1452l7htqmdul = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "from": SS58String;
    "to": SS58String;
    "amount": bigint;
};
export type I5k7trgmhddpc9 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "from": SS58String;
    "to": SS58String;
    "amount": bigint;
    "status": BalanceStatus;
};
export type Ifg1v23kle5pvs = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": SS58String;
    "free": bigint;
    "reserved": bigint;
};
export type Ic7aob2k1l1jfu = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "amount": bigint;
};
export type Idog3297nuhubu = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": SS58String;
    "free_amount": bigint;
    "reserved_amount": bigint;
};
export type I7aphsup25pr8u = {
    "lock_id": FixedSizeBinary<8>;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": SS58String;
    "amount": bigint;
};
export type Id9ivc2gke7kda = {
    "lock_id": FixedSizeBinary<8>;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": SS58String;
};
export type Iacevcg18ig1av = AnonymousEnum<{
    /**
     * Deposit success.
     */
    "Deposited": Anonymize<I32sqi67deo8lb>;
    /**
     * Withdraw success.
     */
    "Withdrawn": Anonymize<I32sqi67deo8lb>;
}>;
export type I32sqi67deo8lb = {
    "asset": Anonymize<Iffh1nc5e1mod6>;
    "who": Anonymize<If9iqq7i64mur8>;
};
export type Iclksjsco5l5ll = AnonymousEnum<{
    /**
     * XCM message sent. \[to, message\]
     */
    "Sent": Anonymize<I7dhoiqi8n693s>;
}>;
export type I7dhoiqi8n693s = {
    "to": Anonymize<If9iqq7i64mur8>;
    "message": Anonymize<Ict03eedr8de9s>;
};
export type I148v60cekcg36 = AnonymousEnum<{
    /**
     * Foreign Asset
     * Some assets were transferred. \[asset_id, owner, target, amount\]
     */
    "Transferred": Anonymize<I1kmrn95024uj4>;
    /**
     * Some assets were burned. \[asset_id, owner, amount\]
     */
    "Burned": Anonymize<Ibianp5jdpolv7>;
    /**
     * Some assets were minted. \[asset_id, owner, amount\]
     */
    "Minted": Anonymize<Ibianp5jdpolv7>;
    /**
     * Swap
     * Create a trading pair. \[asset_0, asset_1\]
     */
    "PairCreated": Anonymize<I84fmreorpmm3e>;
    /**
     * Add liquidity. \[owner, asset_0, asset_1, add_balance_0, add_balance_1,
     * mint_balance_lp\]
     */
    "LiquidityAdded": Anonymize<I9e73asfoaqs2i>;
    /**
     * Remove liquidity. \[owner, recipient, asset_0, asset_1, rm_balance_0, rm_balance_1,
     * burn_balance_lp\]
     */
    "LiquidityRemoved": Anonymize<I9ugpnf3tjcb6b>;
    /**
     * Transact in trading \[owner, recipient, swap_path, balances\]
     */
    "AssetSwap": Anonymize<Idg56vb718jpor>;
    /**
     * Transfer by xcm
     * Transferred to parachain. \[asset_id, src, para_id, dest, amount, used_weight\]
     */
    "TransferredToParachain": Anonymize<Icjttivfuq4kl0>;
    /**
     * Contribute to bootstrap pair. \[who, asset_0, asset_0_contribute, asset_1_contribute\]
     */
    "BootstrapContribute": Anonymize<I7aqqpfb5d3acb>;
    /**
     * A bootstrap pair end. \[asset_0, asset_1, asset_0_amount, asset_1_amount,
     * total_lp_supply]
     */
    "BootstrapEnd": Anonymize<I67tkv8m7b9as3>;
    /**
     * Create a bootstrap pair. \[bootstrap_pair_account, asset_0, asset_1,
     * total_supply_0,total_supply_1, capacity_supply_0,capacity_supply_1, end\]
     */
    "BootstrapCreated": Anonymize<I53hhk4qo3m9a6>;
    /**
     * Claim a bootstrap pair. \[bootstrap_pair_account, claimer, receiver, asset_0, asset_1,
     * asset_0_refund, asset_1_refund, lp_amount\]
     */
    "BootstrapClaim": Anonymize<I73e059ch622rh>;
    /**
     * Update a bootstrap pair. \[caller, asset_0, asset_1,
     * total_supply_0,total_supply_1, capacity_supply_0,capacity_supply_1\]
     */
    "BootstrapUpdate": Anonymize<I53hhk4qo3m9a6>;
    /**
     * Refund from disable bootstrap pair. \[bootstrap_pair_account, caller, asset_0, asset_1,
     * asset_0_refund, asset_1_refund\]
     */
    "BootstrapRefund": Anonymize<I8s0297rim8oc1>;
    /**
     * Bootstrap distribute some rewards to contributors.
     */
    "DistributeReward": Anonymize<Ibanc5bru9o3gt>;
    /**
     * Charge reward into a bootstrap.
     */
    "ChargeReward": Anonymize<Ibanc5bru9o3gt>;
    /**
     * Withdraw all reward from a bootstrap.
     */
    "WithdrawReward": Anonymize<Ia9haecbvl560l>;
}>;
export type I1kmrn95024uj4 = [Anonymize<Icu3qllmbdnj89>, SS58String, SS58String, bigint];
export type Icu3qllmbdnj89 = {
    "chain_id": number;
    "asset_type": number;
    "asset_index": bigint;
};
export type Ibianp5jdpolv7 = [Anonymize<Icu3qllmbdnj89>, SS58String, bigint];
export type I84fmreorpmm3e = FixedSizeArray<2, Anonymize<Icu3qllmbdnj89>>;
export type I9e73asfoaqs2i = [SS58String, Anonymize<Icu3qllmbdnj89>, Anonymize<Icu3qllmbdnj89>, bigint, bigint, bigint];
export type I9ugpnf3tjcb6b = [SS58String, SS58String, Anonymize<Icu3qllmbdnj89>, Anonymize<Icu3qllmbdnj89>, bigint, bigint, bigint];
export type Idg56vb718jpor = [SS58String, SS58String, Anonymize<Idhafor8sovqeu>, Anonymize<Iafqnechp3omqg>];
export type Idhafor8sovqeu = Array<Anonymize<Icu3qllmbdnj89>>;
export type Icjttivfuq4kl0 = [Anonymize<Icu3qllmbdnj89>, SS58String, number, SS58String, bigint, bigint];
export type I7aqqpfb5d3acb = [SS58String, Anonymize<Icu3qllmbdnj89>, bigint, Anonymize<Icu3qllmbdnj89>, bigint];
export type I67tkv8m7b9as3 = [Anonymize<Icu3qllmbdnj89>, Anonymize<Icu3qllmbdnj89>, bigint, bigint, bigint];
export type I53hhk4qo3m9a6 = [SS58String, Anonymize<Icu3qllmbdnj89>, Anonymize<Icu3qllmbdnj89>, bigint, bigint, bigint, bigint, number];
export type I73e059ch622rh = [SS58String, SS58String, SS58String, Anonymize<Icu3qllmbdnj89>, Anonymize<Icu3qllmbdnj89>, bigint, bigint, bigint];
export type I8s0297rim8oc1 = [SS58String, SS58String, Anonymize<Icu3qllmbdnj89>, Anonymize<Icu3qllmbdnj89>, bigint, bigint];
export type Ibanc5bru9o3gt = [Anonymize<Icu3qllmbdnj89>, Anonymize<Icu3qllmbdnj89>, SS58String, Anonymize<I6sn46nd9sjbst>];
export type I6sn46nd9sjbst = Array<[Anonymize<Icu3qllmbdnj89>, bigint]>;
export type Ia9haecbvl560l = [Anonymize<Icu3qllmbdnj89>, Anonymize<Icu3qllmbdnj89>, SS58String];
export type Icmkq9kpsciiub = AnonymousEnum<{
    /**
     * Emitted when a state machine is successfully updated to a new height
     */
    "StateMachineUpdated": Anonymize<Ial9kpmfj9nsqr>;
    /**
     * Emitted when a state commitment is vetoed by a fisherman
     */
    "StateCommitmentVetoed": Anonymize<I2ra3uepvk35si>;
    /**
     * Indicates that a consensus client has been created
     */
    "ConsensusClientCreated": Anonymize<I9ljfa9qc631nt>;
    /**
     * Indicates that a consensus client has been created
     */
    "ConsensusClientFrozen": Anonymize<I9ljfa9qc631nt>;
    /**
     * An Outgoing Response has been deposited
     */
    "Response": Anonymize<I1apjv9m70hqn0>;
    /**
     * An Outgoing Request has been deposited
     */
    "Request": Anonymize<I68i9mkj0i3heo>;
    /**
     * Some errors handling some ismp messages
     */
    "Errors": Anonymize<I6vqpfjes12rn2>;
    /**
     * Post Request Handled
     */
    "PostRequestHandled": Anonymize<I7qo7cp2e3aerl>;
    /**
     * Post Response Handled
     */
    "PostResponseHandled": Anonymize<I7qo7cp2e3aerl>;
    /**
     * Get Response Handled
     */
    "GetRequestHandled": Anonymize<I7qo7cp2e3aerl>;
    /**
     * Post request timeout handled
     */
    "PostRequestTimeoutHandled": Anonymize<I53bm5fak9v07m>;
    /**
     * Post response timeout handled
     */
    "PostResponseTimeoutHandled": Anonymize<I53bm5fak9v07m>;
    /**
     * Get request timeout handled
     */
    "GetRequestTimeoutHandled": Anonymize<I53bm5fak9v07m>;
}>;
export type Ial9kpmfj9nsqr = {
    /**
     * State machine identifier
     */
    "state_machine_id": Anonymize<Ieitt970a26jef>;
    /**
     * State machine latest height
     */
    "latest_height": bigint;
};
export type Ieitt970a26jef = {
    "state_id": Anonymize<Icctse4hug509d>;
    "consensus_state_id": FixedSizeBinary<4>;
};
export type Icctse4hug509d = AnonymousEnum<{
    "Evm": number;
    "Polkadot": number;
    "Kusama": number;
    "Substrate": FixedSizeBinary<4>;
    "Tendermint": FixedSizeBinary<4>;
    "Relay": {
        "relay": FixedSizeBinary<4>;
        "para_id": number;
    };
}>;
export type I2ra3uepvk35si = {
    /**
     * State machine height
     */
    "height": Anonymize<Ifm3n51g640vse>;
    /**
     * responsible fisherman
     */
    "fisherman": Binary;
};
export type Ifm3n51g640vse = {
    "id": Anonymize<Ieitt970a26jef>;
    "height": bigint;
};
export type I9ljfa9qc631nt = {
    /**
     * Consensus client id
     */
    "consensus_client_id": FixedSizeBinary<4>;
};
export type I1apjv9m70hqn0 = {
    /**
     * Chain that this response will be routed to
     */
    "dest_chain": Anonymize<Icctse4hug509d>;
    /**
     * Source Chain for this response
     */
    "source_chain": Anonymize<Icctse4hug509d>;
    /**
     * Nonce for the request which this response is for
     */
    "request_nonce": bigint;
    /**
     * Response Commitment
     */
    "commitment": FixedSizeBinary<32>;
    /**
     * Request commitment
     */
    "req_commitment": FixedSizeBinary<32>;
};
export type I68i9mkj0i3heo = {
    /**
     * Chain that this request will be routed to
     */
    "dest_chain": Anonymize<Icctse4hug509d>;
    /**
     * Source Chain for request
     */
    "source_chain": Anonymize<Icctse4hug509d>;
    /**
     * Request nonce
     */
    "request_nonce": bigint;
    /**
     * Commitment
     */
    "commitment": FixedSizeBinary<32>;
};
export type I6vqpfjes12rn2 = {
    /**
     * Message handling errors
     */
    "errors": Anonymize<Itom7fk49o0c9>;
};
export type I7qo7cp2e3aerl = {
    "commitment": FixedSizeBinary<32>;
    "relayer": Binary;
};
export type I53bm5fak9v07m = {
    "commitment": FixedSizeBinary<32>;
    "source": Anonymize<Icctse4hug509d>;
    "dest": Anonymize<Icctse4hug509d>;
};
export type Ie6qh3o3afje2f = AnonymousEnum<{
    /**
     * Parachains with the `para_ids` have been added to the whitelist
     */
    "ParachainsAdded": Anonymize<Ivalbtb85o2h0>;
    /**
     * Parachains with the `para_ids` have been removed from the whitelist
     */
    "ParachainsRemoved": Anonymize<Ic8hk838gccoml>;
}>;
export type Ivalbtb85o2h0 = {
    /**
     * The parachains in question
     */
    "para_ids": Array<{
        "id": number;
        "slot_duration": bigint;
    }>;
};
export type Ic8hk838gccoml = {
    /**
     * The parachains in question
     */
    "para_ids": Anonymize<Icgljjb6j82uhn>;
};
export type I98tlgsrsat2ne = AnonymousEnum<{
    /**
     * Hyperbridge governance has now updated it's host params on this chain.
     */
    "HostParamsUpdated": Anonymize<If7o6tu2tbpm0f>;
    /**
     * A relayer has withdrawn some fees
     */
    "RelayerFeeWithdrawn": Anonymize<Ic262ibdoec56a>;
    /**
     * Hyperbridge has withdrawn it's protocol revenue
     */
    "ProtocolRevenueWithdrawn": Anonymize<Ic262ibdoec56a>;
}>;
export type If7o6tu2tbpm0f = {
    /**
     * The old host params
     */
    "old": Anonymize<I2gcf5pphcpi9h>;
    /**
     * The new host params
     */
    "new": Anonymize<I2gcf5pphcpi9h>;
};
export type I2gcf5pphcpi9h = AnonymousEnum<{
    "V1": {
        "default_per_byte_fee": bigint;
        "per_byte_fees": Anonymize<I4eijtuhk9st5q>;
        "asset_registration_fee": bigint;
    };
}>;
export type I4eijtuhk9st5q = Array<[Anonymize<Icctse4hug509d>, bigint]>;
export type I4e096t1b1rrk7 = AnonymousEnum<{
    /**
     * An asset has been teleported
     */
    "AssetTeleported": Anonymize<I9cdaua1ufuf68>;
    /**
     * An asset has been received and transferred to the beneficiary's account
     */
    "AssetReceived": Anonymize<Ibd4ev4rmnpul7>;
    /**
     * An asset has been refunded and transferred to the beneficiary's account
     */
    "AssetRefunded": Anonymize<Ibd4ev4rmnpul7>;
    /**
     * ERC6160 asset creation request dispatched to hyperbridge
     */
    "ERC6160AssetRegistrationDispatched": Anonymize<Icr3t2kod9dj5d>;
    /**
     * Whitelist has been reset
     */
    "WhitelistReset": Anonymize<I9b25mq8qrg0o8>;
}>;
export type I9cdaua1ufuf68 = {
    /**
     * Source account on the relaychain
     */
    "from": SS58String;
    /**
     * beneficiary account on destination
     */
    "to": FixedSizeBinary<32>;
    /**
     * asset id on destination
     */
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * Amount transferred
     */
    "amount": bigint;
    /**
     * Destination chain
     */
    "dest": Anonymize<Icctse4hug509d>;
    /**
     * Request commitment
     */
    "commitment": FixedSizeBinary<32>;
};
export type Ibd4ev4rmnpul7 = {
    /**
     * beneficiary account on relaychain
     */
    "beneficiary": SS58String;
    /**
     * Amount transferred
     */
    "amount": bigint;
    /**
     * Destination chain
     */
    "source": Anonymize<Icctse4hug509d>;
};
export type Icr3t2kod9dj5d = {
    /**
     * Request commitment
     */
    "commitment": FixedSizeBinary<32>;
};
export type I9b25mq8qrg0o8 = {
    /**
     * Destination chain
     */
    "chain": Anonymize<Icctse4hug509d>;
    /**
     * Whitelist asress set
     */
    "whitelist": Anonymize<Itom7fk49o0c9>;
};
export type I951u7mq7pq6i7 = AnonymousEnum<{
    /**
     * Transfer to another chain
     */
    "TransferTo": Anonymize<I7c48q22j7l1q8>;
    /**
     * Set user default fee currency
     */
    "SetDefaultFeeCurrency": Anonymize<I3shlhcndrf1f0>;
    /**
     * Set universal fee currency order list
     */
    "SetFeeCurrencyList": Anonymize<Ia85jfgnieg7o0>;
    /**
     * Set extra fee by call
     */
    "SetExtraFee": Anonymize<I4j50qh0n84qes>;
}>;
export type I7c48q22j7l1q8 = {
    "from": SS58String;
    "target_chain": Enum<{
        "AssetHub": undefined;
        "RelayChain": undefined;
    }>;
    "amount": bigint;
};
export type I3shlhcndrf1f0 = {
    "who": SS58String;
    "currency_id"?: Anonymize<I1c99t35ku3g7a>;
};
export type I1c99t35ku3g7a = (Anonymize<Iebirugq1dbhv6>) | undefined;
export type Ia85jfgnieg7o0 = {
    "currency_list": Anonymize<I6ae21pstqk9et>;
};
export type I6ae21pstqk9et = Array<Anonymize<Iebirugq1dbhv6>>;
export type I4j50qh0n84qes = {
    /**
     * The raw call name to be set as the extra fee call.
     */
    "raw_call_name": Binary;
    /**
     * currency_id, fee_amount, receiver
     */
    "fee_info"?: (Anonymize<I8pmg4u740mebc>) | undefined;
};
export type I8pmg4u740mebc = [Anonymize<Iebirugq1dbhv6>, bigint, SS58String];
export type I87g1igl7tl927 = AnonymousEnum<{
    /**
     * Create a new crowdloaning campaign. [fund_index]
     */
    "Created": number;
    /**
     * Contributing to a crowd sale. [who, fund_index, amount]
     */
    "Contributing": Anonymize<Ic4lis4f2abd9o>;
    /**
     * Contributed to a crowd sale. [who, fund_index, amount]
     */
    "Contributed": Anonymize<I7fcree6lak6uv>;
    /**
     * Fail on contribute to crowd sale. [who, fund_index, amount]
     */
    "ContributeFailed": Anonymize<I7fcree6lak6uv>;
    /**
     * Withdrew full balance of a contributor. [who, fund_index, amount]
     */
    "Withdrew": Anonymize<I4ojmnsk1dchql>;
    /**
     * refund to account. [who, fund_index,value]
     */
    "Refunded": Anonymize<Icl5s4108hio7m>;
    /**
     * all refund
     */
    "AllRefunded": number;
    /**
     * redeem to account. [who, fund_index, first_slot, last_slot, value]
     */
    "Redeemed": Anonymize<Icl5s4108hio7m>;
    /**
     * Fund is edited. [fund_index]
     */
    "Edited": number;
    /**
     * Fund is dissolved. [fund_index]
     */
    "Dissolved": number;
    /**
     * The vsToken/vsBond was be unlocked. [who, fund_index, value]
     */
    "Unlocked": Anonymize<I7fcree6lak6uv>;
    "AllUnlocked": number;
    /**
     * Fund status change
     */
    "Failed": number;
    "Success": number;
    "Retired": number;
    "End": number;
    "Continued": Anonymize<Ielgh4t8o7rcvt>;
    "RefundedDissolved": Anonymize<Ielgh4t8o7rcvt>;
    "Buyback": bigint;
    "VstokenUnlocked": SS58String;
    "BuybackByStablePool": Anonymize<Iv901693moogd>;
    "Reserved": Anonymize<I93gagnlb9gm3u>;
    "ReservationCancelled": Anonymize<Idn2ghub1o4i40>;
    "ReservationFullyHandled": Anonymize<I37r4bdai8o9mp>;
    "ReservationHandled": Anonymize<I37r4bdai8o9mp>;
}>;
export type Ic4lis4f2abd9o = [SS58String, number, bigint, FixedSizeBinary<32>];
export type Icl5s4108hio7m = [SS58String, number, number, number, bigint];
export type Ielgh4t8o7rcvt = FixedSizeArray<3, number>;
export type Iv901693moogd = {
    "pool_id": number;
    "currency_id_in": Anonymize<Iebirugq1dbhv6>;
    "value": bigint;
};
export type I93gagnlb9gm3u = {
    "who": SS58String;
    "para_id": number;
    "value": bigint;
    "if_mint": boolean;
};
export type Idk7vijisib25n = AnonymousEnum<{
    /**
     * The asset registered.
     */
    "AssetRegistered": Anonymize<Ij8p6ct1brfmo>;
    /**
     * The asset updated.
     */
    "AssetUpdated": Anonymize<Ij8p6ct1brfmo>;
    /**
     * The CurrencyId registered.
     */
    "CurrencyIdRegistered": Anonymize<I7utese4puubr9>;
    /**
     * Location Force set.
     */
    "LocationSet": Anonymize<I3qdgms9h4is9n>;
    /**
     * The CurrencyId updated.
     */
    "CurrencyIdUpdated": Anonymize<I7utese4puubr9>;
}>;
export type Ij8p6ct1brfmo = {
    "asset_id": Anonymize<I810b83nplvppm>;
    "metadata": Anonymize<Ievgjq5dn6rae7>;
};
export type I810b83nplvppm = AnonymousEnum<{
    "ForeignAssetId": number;
    "NativeAssetId": Anonymize<Iebirugq1dbhv6>;
}>;
export type Ievgjq5dn6rae7 = {
    "name": Binary;
    "symbol": Binary;
    "decimals": number;
    "minimal_balance": bigint;
};
export type I7utese4puubr9 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "metadata": Anonymize<Ievgjq5dn6rae7>;
};
export type I3qdgms9h4is9n = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "location": Anonymize<If9iqq7i64mur8>;
    "weight": Anonymize<I4q39t5hn830vp>;
};
export type Ibe1mbk3j43vrp = AnonymousEnum<{
    /**
     * Vtoken minted successfully.
     */
    "Minted": Anonymize<I8e477rrh15djf>;
    /**
     * Vtoken redeemed successfully.
     */
    "Redeemed": Anonymize<I3nuinrik5mleq>;
    /**
     * Process redeem successfully.
     */
    "RedeemSuccess": Anonymize<I49iq2qck2mkkq>;
    /**
     * Vtoken rebonded successfully.
     */
    "Rebonded": Anonymize<I2qaqth7uqvdf9>;
    /**
     * Vtoken rebonded by unlock_id successfully.
     */
    "RebondedByUnlockId": Anonymize<I7hgbfjfqur3o0>;
    /**
     * Set unlock duration.
     */
    "UnlockDurationSet": Anonymize<I95h8ge6oaumen>;
    /**
     * Set minimum mint amount.
     */
    "MinimumMintSet": Anonymize<I9gla6h44u54mh>;
    /**
     * Set minimum redeem amount.
     */
    "MinimumRedeemSet": Anonymize<I9gla6h44u54mh>;
    /**
     * Support rebond token added.
     */
    "SupportRebondTokenAdded": Anonymize<I6dlum3cbrie3d>;
    /**
     * Support rebond token removed.
     */
    "SupportRebondTokenRemoved": Anonymize<I6dlum3cbrie3d>;
    /**
     * Set mint fee and redeem fee.
     */
    "FeeSet": Anonymize<Idkdd97l7v4t7o>;
    /**
     * Set hook iteration limit.
     */
    "HookIterationLimitSet": Anonymize<Iamlqp3gs21baf>;
    /**
     * Set unlock total amount.
     */
    "UnlockingTotalSet": Anonymize<Icmnhhde8qv456>;
    /**
     * Set minimum time unit.
     */
    "MinTimeUnitSet": Anonymize<I4qh6vjmbpl1a6>;
    /**
     * Fast redeem failed.
     */
    "FastRedeemFailed": Anonymize<Id3k8o0e2cab51>;
    /**
     * Set ongoing time unit.
     */
    "SetOngoingTimeUnit": Anonymize<I4qh6vjmbpl1a6>;
    /**
     * Incentivized minting.
     */
    "IncentivizedMinting": Anonymize<Ib754le9rlkqse>;
    /**
     * Incentive coefficient set.
     */
    "VtokenIncentiveCoefSet": Anonymize<I3pbnpd5raifhq>;
    /**
     * Incentive lock blocks set.
     */
    "VtokenIncentiveLockBlocksSet": Anonymize<I18s38m9j5bg00>;
    /**
     * Set Supported eths.
     */
    "SupportedEthSet": Anonymize<Ifsksfqf7mb05t>;
    /**
     * VToken issuance adjusted.
     */
    "VtokenIssuanceSet": Anonymize<Ifgbhtfo78kca0>;
}>;
export type I8e477rrh15djf = {
    /**
     * The minter account.
     */
    "minter": SS58String;
    /**
     * The currency id minted.
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The currency amount minted.
     */
    "currency_amount": bigint;
    /**
     * The v_currency amount minted.
     */
    "v_currency_amount": bigint;
    /**
     * The mint fee.
     */
    "mint_fee": bigint;
    /**
     * The remark of minting.
     */
    "remark": Binary;
    /**
     * The channel id of minting.
     */
    "channel_id"?: Anonymize<I4arjljr6dpflb>;
};
export type I3nuinrik5mleq = {
    /**
     * The redeemer account.
     */
    "redeemer": SS58String;
    /**
     * The currency id redeemed.
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * Will be received currency amount.
     */
    "currency_amount": bigint;
    /**
     * The v_currency amount redeemed.
     */
    "v_currency_amount": bigint;
    /**
     * The redeem fee.
     */
    "redeem_fee": bigint;
    /**
     * The unlock_id of redeeming.
     */
    "unlock_id": number;
};
export type I49iq2qck2mkkq = {
    /**
     * The redeemer account.
     */
    "redeemer": SS58String;
    /**
     * The unlock_id redeemed.
     */
    "unlock_id": number;
    /**
     * The currency id redeemed.
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * Will transfer to this account.
     */
    "to": Enum<{
        "Native": SS58String;
        "Astar": SS58String;
        "Moonbeam": FixedSizeBinary<20>;
        "Hydradx": SS58String;
        "Interlay": SS58String;
        "Manta": SS58String;
        "HyperBridge": Anonymize<Ia46odf30322a1>;
    }>;
    /**
     * The redeem amount.
     */
    "currency_amount": bigint;
};
export type Ia46odf30322a1 = [number, FixedSizeBinary<20>];
export type I2qaqth7uqvdf9 = {
    /**
     * The rebonder account.
     */
    "rebonder": SS58String;
    /**
     * The currency id rebonded.
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The currency amount rebonded.
     */
    "currency_amount": bigint;
    /**
     * The v_currency amount rebonded.
     */
    "v_currency_amount": bigint;
    /**
     * Mint fee
     */
    "fee": bigint;
};
export type I7hgbfjfqur3o0 = {
    /**
     * The rebonder account.
     */
    "rebonder": SS58String;
    /**
     * The currency id rebonded.
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The currency amount rebonded.
     */
    "currency_amount": bigint;
    /**
     * The v_currency amount rebonded.
     */
    "v_currency_amount": bigint;
    /**
     * Mint fee
     */
    "fee": bigint;
    /**
     * The unlock_id rebonded.
     */
    "unlock_id": number;
};
export type I95h8ge6oaumen = {
    /**
     * The currency id set unlock duration.
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The unlock duration set.
     */
    "unlock_duration": Anonymize<Id6ihttoi261us>;
};
export type Id6ihttoi261us = AnonymousEnum<{
    "Era": number;
    "SlashingSpan": number;
    "Round": number;
    "Kblock": number;
    "Hour": number;
}>;
export type I9gla6h44u54mh = {
    /**
     * The currency id set minimum mint amount.
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The minimum mint amount set.
     */
    "minimum_amount": bigint;
};
export type I6dlum3cbrie3d = {
    /**
     * The currency id support rebond.
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
};
export type Idkdd97l7v4t7o = {
    /**
     * The mint fee rate set.
     */
    "mint_fee": number;
    /**
     * The redeem fee rate set.
     */
    "redeem_fee": number;
};
export type Iamlqp3gs21baf = {
    "limit": number;
};
export type Icmnhhde8qv456 = {
    /**
     * The currency id set unlock total amount.
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The unlock total amount set.
     */
    "currency_amount": bigint;
};
export type I4qh6vjmbpl1a6 = {
    /**
     * The currency id set minimum time unit.
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The minimum time unit set.
     */
    "time_unit": Anonymize<Id6ihttoi261us>;
};
export type Id3k8o0e2cab51 = {
    "err": Anonymize<I46mg5gru1rk0a>;
};
export type Ib754le9rlkqse = {
    "address": SS58String;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "currency_amount": bigint;
    "locked_vtoken_amount": bigint;
    "incentive_vtoken_amount": bigint;
};
export type I3pbnpd5raifhq = {
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
    "coefficient"?: Anonymize<I35p85j063s0il>;
};
export type I18s38m9j5bg00 = {
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
    "blocks"?: Anonymize<I4arjljr6dpflb>;
};
export type Ifsksfqf7mb05t = {
    "eths": Anonymize<I6ae21pstqk9et>;
};
export type Ifgbhtfo78kca0 = {
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
    "issuance": bigint;
};
export type I5jumpe7oiv3dr = AnonymousEnum<{
    "DelegatorInitialized": Anonymize<Iab17gup71picv>;
    "DelegatorBonded": Anonymize<I2p503tvhr95gj>;
    "DelegatorBondExtra": Anonymize<I9grg7g6ua578n>;
    "DelegatorUnbond": Anonymize<I6umd4hgu2puph>;
    "DelegatorUnbondAll": Anonymize<I44127qd8nvu47>;
    "DelegatorRebond": Anonymize<I5tdcum59p9pac>;
    "Delegated": Anonymize<I2dgahqu6ln4jl>;
    "Undelegated": Anonymize<I1hn8tvlbussv>;
    "Payout": Anonymize<I96on68vm4ih94>;
    "Liquidize": Anonymize<Idgas9g0pc3k9g>;
    "Chill": Anonymize<I44127qd8nvu47>;
    "TransferBack": Anonymize<Ibu6i8jb58o30n>;
    "TransferTo": Anonymize<Ibu6i8jb58o30n>;
    "ConvertAsset": Anonymize<Iaevo3h2jsoemi>;
    "DelegatorAdded": Anonymize<Iep8a74k7e6r72>;
    "DelegatorRemoved": Anonymize<Iab17gup71picv>;
    "ValidatorsAdded": Anonymize<Ib6t0ubljgp22u>;
    "ValidatorsRemoved": Anonymize<Ib6t0ubljgp22u>;
    "Refund": Anonymize<I3rgoh4223434f>;
    "FundMoveFromExitToEntrance": Anonymize<Ic7aob2k1l1jfu>;
    "TimeUnitUpdated": Anonymize<I2vfuukfl5d6al>;
    "PoolTokenIncreased": Anonymize<Ic7aob2k1l1jfu>;
    "HostingFeeCharged": Anonymize<Ic7aob2k1l1jfu>;
    "PoolTokenDecreased": Anonymize<Ic7aob2k1l1jfu>;
    "FeeSupplemented": Anonymize<Ibu6i8jb58o30n>;
    "ValidatorsByDelegatorSet": Anonymize<I9ns66h5mcst21>;
    "OperateOriginSet": Anonymize<I5ch6hqvso9cfc>;
    "FeeSourceSet": Anonymize<Inp8hn3mu8c5j>;
    "DelegatorLedgerSet": Anonymize<I81p9lds919n0g>;
    "DelegatorLedgerQueryResponseConfirmed": Anonymize<I87hura2cobcv1>;
    "DelegatorLedgerQueryResponseFailed": Anonymize<I30pg328m00nr3>;
    "ValidatorsByDelegatorQueryResponseConfirmed": Anonymize<I3lbtb6q8ittcg>;
    "ValidatorsByDelegatorQueryResponseFailed": Anonymize<I30pg328m00nr3>;
    "MinimumsMaximumsSet": Anonymize<I788n87nobc2o6>;
    "CurrencyDelaysSet": Anonymize<I99tkds5qdlj77>;
    "HostingFeesSet": Anonymize<Ian267bdq9joaf>;
    "CurrencyTuneExchangeRateLimitSet": Anonymize<I91fa8tnsgpjgh>;
    "OngoingTimeUnitUpdateIntervalSet": Anonymize<Iemo1133hhf28q>;
    "SupplementFeeAccountWhitelistAdded": Anonymize<Iaba972j3va7k>;
    "SupplementFeeAccountWhitelistRemoved": Anonymize<Iaba972j3va7k>;
    "ValidatorsReset": Anonymize<Id37b9l6bk2ii9>;
    "ValidatorBoostListSet": Anonymize<I8o6tg2fcd6krf>;
    "ValidatorBoostListAdded": Anonymize<Iouj49kqoegp1>;
    "RemovedFromBoostList": Anonymize<Iaba972j3va7k>;
    "OutdatedValidatorBoostListCleaned": Anonymize<Ife8sj002g6s56>;
    "BurnFeeFailed": Anonymize<Ic7aob2k1l1jfu>;
}>;
export type Iab17gup71picv = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "delegator_id": Anonymize<I4c0s5cioidn76>;
};
export type I2p503tvhr95gj = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "delegator_id": Anonymize<I4c0s5cioidn76>;
    "bonded_amount": bigint;
    "query_id": bigint;
    "query_id_hash": FixedSizeBinary<32>;
    "validator"?: Anonymize<Ia9cgf4r40b26h>;
};
export type I9grg7g6ua578n = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "delegator_id": Anonymize<I4c0s5cioidn76>;
    "extra_bonded_amount": bigint;
    "query_id": bigint;
    "query_id_hash": FixedSizeBinary<32>;
    "validator"?: Anonymize<Ia9cgf4r40b26h>;
};
export type I6umd4hgu2puph = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "delegator_id": Anonymize<I4c0s5cioidn76>;
    "unbond_amount": bigint;
    "query_id": bigint;
    "query_id_hash": FixedSizeBinary<32>;
    "validator"?: Anonymize<Ia9cgf4r40b26h>;
};
export type I44127qd8nvu47 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "delegator_id": Anonymize<I4c0s5cioidn76>;
    "query_id": bigint;
    "query_id_hash": FixedSizeBinary<32>;
};
export type I5tdcum59p9pac = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "delegator_id": Anonymize<I4c0s5cioidn76>;
    "rebond_amount"?: Anonymize<I35p85j063s0il>;
    "query_id": bigint;
    "query_id_hash": FixedSizeBinary<32>;
    "validator"?: Anonymize<Ia9cgf4r40b26h>;
};
export type I2dgahqu6ln4jl = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "delegator_id": Anonymize<I4c0s5cioidn76>;
    "targets"?: Anonymize<Ia866hqrh833qa>;
    "query_id": bigint;
    "query_id_hash": FixedSizeBinary<32>;
};
export type Ia866hqrh833qa = (Anonymize<Ia88a8r9e89e2p>) | undefined;
export type Ia88a8r9e89e2p = Array<Anonymize<I4c0s5cioidn76>>;
export type I1hn8tvlbussv = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "delegator_id": Anonymize<I4c0s5cioidn76>;
    "targets": Anonymize<Ia88a8r9e89e2p>;
    "query_id": bigint;
    "query_id_hash": FixedSizeBinary<32>;
};
export type I96on68vm4ih94 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "validator": Anonymize<I4c0s5cioidn76>;
    "time_unit"?: Anonymize<I6o0vlee7cr3h2>;
};
export type I6o0vlee7cr3h2 = (Anonymize<Id6ihttoi261us>) | undefined;
export type Idgas9g0pc3k9g = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "delegator_id": Anonymize<I4c0s5cioidn76>;
    "time_unit"?: Anonymize<I6o0vlee7cr3h2>;
    "query_id": bigint;
    "query_id_hash": FixedSizeBinary<32>;
    "amount"?: Anonymize<I35p85j063s0il>;
};
export type Ibu6i8jb58o30n = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "from": Anonymize<I4c0s5cioidn76>;
    "to": Anonymize<I4c0s5cioidn76>;
    "amount": bigint;
};
export type Iaevo3h2jsoemi = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
    "amount": bigint;
};
export type Iep8a74k7e6r72 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "index": number;
    "delegator_id": Anonymize<I4c0s5cioidn76>;
};
export type Ib6t0ubljgp22u = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "validator_id": Anonymize<I4c0s5cioidn76>;
};
export type I3rgoh4223434f = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "time_unit": Anonymize<Id6ihttoi261us>;
    "index": number;
    "amount": bigint;
};
export type I2vfuukfl5d6al = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "old"?: Anonymize<I6o0vlee7cr3h2>;
    "new": Anonymize<Id6ihttoi261us>;
};
export type I9ns66h5mcst21 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "validators_list": Anonymize<Ia88a8r9e89e2p>;
    "delegator_id": Anonymize<I4c0s5cioidn76>;
};
export type I5ch6hqvso9cfc = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "operator"?: Anonymize<Ihfphjolmsqq1>;
};
export type Inp8hn3mu8c5j = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who_and_fee"?: (Anonymize<Iadrpn9mhdu2rp>) | undefined;
};
export type Iadrpn9mhdu2rp = [Anonymize<I4c0s5cioidn76>, bigint];
export type I81p9lds919n0g = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "delegator": Anonymize<I4c0s5cioidn76>;
    "ledger"?: Anonymize<I9plp53g8mj92d>;
};
export type I9plp53g8mj92d = (Anonymize<I65gcqchov0ds9>) | undefined;
export type I65gcqchov0ds9 = AnonymousEnum<{
    "Substrate": {
        "account": Anonymize<I4c0s5cioidn76>;
        "total": bigint;
        "active": bigint;
        "unlocking": Array<{
            "value": bigint;
            "unlock_time": Anonymize<Id6ihttoi261us>;
        }>;
    };
    "Moonbeam": {
        "account": Anonymize<I4c0s5cioidn76>;
        "delegations": Array<Anonymize<Iadrpn9mhdu2rp>>;
        "total": bigint;
        "less_total": bigint;
        "requests": Array<{
            "validator": Anonymize<I4c0s5cioidn76>;
            "when_executable": Anonymize<Id6ihttoi261us>;
            "action": Anonymize<Ibtq25m1pbdmfs>;
        }>;
        "request_briefs": Array<[Anonymize<I4c0s5cioidn76>, [Anonymize<Id6ihttoi261us>, bigint]]>;
        "status": Enum<{
            "Active": undefined;
            "Leaving": Anonymize<Id6ihttoi261us>;
        }>;
    };
    "ParachainStaking": {
        "account": Anonymize<I4c0s5cioidn76>;
        "delegations": Array<Anonymize<Iadrpn9mhdu2rp>>;
        "total": bigint;
        "less_total": bigint;
        "requests": Array<{
            "validator": Anonymize<I4c0s5cioidn76>;
            "when_executable": Anonymize<Id6ihttoi261us>;
            "action": Anonymize<Ibtq25m1pbdmfs>;
        }>;
        "request_briefs": Array<[Anonymize<I4c0s5cioidn76>, [Anonymize<Id6ihttoi261us>, bigint]]>;
        "status": Enum<{
            "Active": undefined;
            "Leaving": Anonymize<Id6ihttoi261us>;
        }>;
    };
    "Filecoin": {
        "account": Anonymize<I4c0s5cioidn76>;
        "initial_pledge": bigint;
    };
    "Phala": {
        "account": Anonymize<I4c0s5cioidn76>;
        "active_shares": bigint;
        "unlocking_shares": bigint;
        "unlocking_time_unit"?: Anonymize<I6o0vlee7cr3h2>;
        "bonded_pool_id"?: Anonymize<I35p85j063s0il>;
        "bonded_pool_collection_id"?: Anonymize<I4arjljr6dpflb>;
        "bonded_is_vault"?: Anonymize<I8ie0dco0kcuq5>;
    };
}>;
export type I87hura2cobcv1 = {
    "query_id": bigint;
    "entry": Anonymize<Ib9sn2bmfqddi7>;
};
export type Ib9sn2bmfqddi7 = AnonymousEnum<{
    "Substrate": {
        "currency_id": Anonymize<Iebirugq1dbhv6>;
        "delegator_id": Anonymize<I4c0s5cioidn76>;
        "update_operation": Enum<{
            "Bond": undefined;
            "Unlock": undefined;
            "Rebond": undefined;
            "Liquidize": undefined;
        }>;
        "amount": bigint;
        "unlock_time"?: Anonymize<I6o0vlee7cr3h2>;
    };
    "Moonbeam": {
        "currency_id": Anonymize<Iebirugq1dbhv6>;
        "delegator_id": Anonymize<I4c0s5cioidn76>;
        "validator_id"?: Anonymize<Ia9cgf4r40b26h>;
        "update_operation": Enum<{
            "Bond": undefined;
            "BondLess": undefined;
            "Revoke": undefined;
            "CancelRequest": undefined;
            "LeaveDelegator": undefined;
            "CancelLeave": undefined;
            "ExecuteLeave": undefined;
            "ExecuteRequest": undefined;
        }>;
        "amount": bigint;
        "unlock_time"?: Anonymize<I6o0vlee7cr3h2>;
    };
    "ParachainStaking": {
        "currency_id": Anonymize<Iebirugq1dbhv6>;
        "delegator_id": Anonymize<I4c0s5cioidn76>;
        "validator_id"?: Anonymize<Ia9cgf4r40b26h>;
        "update_operation": Enum<{
            "Bond": undefined;
            "BondLess": undefined;
            "Revoke": undefined;
            "CancelRequest": undefined;
            "LeaveDelegator": undefined;
            "CancelLeave": undefined;
            "ExecuteLeave": undefined;
            "ExecuteRequest": undefined;
        }>;
        "amount": bigint;
        "unlock_time"?: Anonymize<I6o0vlee7cr3h2>;
    };
}>;
export type I3lbtb6q8ittcg = {
    "query_id": bigint;
    "entry": Anonymize<I14u04kl21424d>;
};
export type I14u04kl21424d = AnonymousEnum<{
    "Substrate": {
        "currency_id": Anonymize<Iebirugq1dbhv6>;
        "delegator_id": Anonymize<I4c0s5cioidn76>;
        "validators": Anonymize<Ia88a8r9e89e2p>;
    };
}>;
export type I788n87nobc2o6 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "minimums_and_maximums"?: Anonymize<Iavcon0kdmah9g>;
};
export type Iavcon0kdmah9g = (Anonymize<Idmnfldthdnj8h>) | undefined;
export type Idmnfldthdnj8h = {
    "delegator_bonded_minimum": bigint;
    "bond_extra_minimum": bigint;
    "unbond_minimum": bigint;
    "rebond_minimum": bigint;
    "unbond_record_maximum": number;
    "validators_back_maximum": number;
    "delegator_active_staking_maximum": bigint;
    "validators_reward_maximum": number;
    "delegation_amount_minimum": bigint;
    "delegators_maximum": number;
    "validators_maximum": number;
};
export type I99tkds5qdlj77 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "delays"?: Anonymize<I2fl7rg40jnqc3>;
};
export type I2fl7rg40jnqc3 = (Anonymize<I98pjho0jvtfaa>) | undefined;
export type I98pjho0jvtfaa = {
    "unlock_delay": Anonymize<Id6ihttoi261us>;
    "leave_delegators_delay": Anonymize<Id6ihttoi261us>;
};
export type Ian267bdq9joaf = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "fees"?: Anonymize<Ibpetveugk1l63>;
};
export type Ibpetveugk1l63 = (Anonymize<I7uhs5s0pidt2q>) | undefined;
export type I7uhs5s0pidt2q = [number, Anonymize<I4c0s5cioidn76>];
export type I91fa8tnsgpjgh = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "tune_exchange_rate_limit"?: Anonymize<Iep7au1720bm0e>;
};
export type Iemo1133hhf28q = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "interval"?: Anonymize<I4arjljr6dpflb>;
};
export type Iaba972j3va7k = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
};
export type Id37b9l6bk2ii9 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "validator_list": Anonymize<Ia88a8r9e89e2p>;
};
export type I8o6tg2fcd6krf = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "validator_boost_list": Anonymize<I4qitokr7lpmpu>;
};
export type I4qitokr7lpmpu = Array<[Anonymize<I4c0s5cioidn76>, number]>;
export type Iouj49kqoegp1 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
    "due_block_number": number;
};
export type Ife8sj002g6s56 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "page": number;
    "remove_num": number;
    "num_left": number;
};
export type Iu4qso82fll8 = AnonymousEnum<{
    "XcmDestWeightAndFeeUpdated": Anonymize<I400tsccl54f69>;
    "TransferredEthereumAssets": Anonymize<I7i2rquf9o1sc4>;
}>;
export type I400tsccl54f69 = [Anonymize<I8vi5hrpkv8lci>, Anonymize<Iebirugq1dbhv6>, Anonymize<I4q39t5hn830vp>, bigint];
export type I8vi5hrpkv8lci = AnonymousEnum<{
    "UmpContributeTransact": undefined;
    "StatemineTransfer": undefined;
    "Bond": undefined;
    "WithdrawUnbonded": undefined;
    "BondExtra": undefined;
    "Unbond": undefined;
    "Rebond": undefined;
    "Delegate": undefined;
    "Payout": undefined;
    "Liquidize": undefined;
    "TransferBack": undefined;
    "TransferTo": undefined;
    "Chill": undefined;
    "Undelegate": undefined;
    "CancelLeave": undefined;
    "XtokensTransferBack": undefined;
    "ExecuteLeave": undefined;
    "ConvertAsset": undefined;
    "Vote": undefined;
    "RemoveVote": undefined;
    "Any": undefined;
    "SupplementaryFee": undefined;
    "EthereumTransfer": undefined;
    "TeleportAssets": undefined;
}>;
export type I7i2rquf9o1sc4 = [SS58String, FixedSizeBinary<20>, bigint];
export type I6rndlmfeiieis = AnonymousEnum<{
    "VsbondConvertToVsksm": Anonymize<I41epceuu5tcos>;
    "VsksmConvertToVsbond": Anonymize<I41epceuu5tcos>;
    "VsbondConvertToVsdot": Anonymize<I44sdvnu7uoqf6>;
    "VsdotConvertToVsbond": Anonymize<I44sdvnu7uoqf6>;
    "VsbondConvertToVstoken": Anonymize<I75rts6phosqgv>;
    "VstokenConvertToVsbond": Anonymize<I75rts6phosqgv>;
    "ExchangeFeeSet": Anonymize<I7dim4s22d4cc>;
    "ExchangeRateSet": Anonymize<I9adoavqh7j1qm>;
    "RelaychainLeaseSet": Anonymize<I2cnb8psb4ovvm>;
}>;
export type I41epceuu5tcos = {
    "address": SS58String;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "vsbond_amount": bigint;
    "vsksm_amount": bigint;
};
export type I44sdvnu7uoqf6 = {
    "address": SS58String;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "vsbond_amount": bigint;
    "vsdot_amount": bigint;
};
export type I75rts6phosqgv = {
    "address": SS58String;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "vsbond_amount": bigint;
    "vstoken_amount": bigint;
};
export type I7dim4s22d4cc = {
    "exchange_fee": Anonymize<I8pl16po8ngde>;
};
export type I8pl16po8ngde = {
    "vstoken_exchange_fee": bigint;
    "vsbond_exchange_fee_of_vstoken": bigint;
};
export type I9adoavqh7j1qm = {
    "lease": number;
    "exchange_rate": Anonymize<Icq8st9st73vh1>;
};
export type Icq8st9st73vh1 = {
    "vsbond_convert_to_vstoken": number;
    "vstoken_convert_to_vsbond": number;
};
export type I2cnb8psb4ovvm = {
    "lease": number;
};
export type I3rtmkbgfdecd4 = AnonymousEnum<{
    /**
     * A farming pool is created.
     */
    "FarmingPoolCreated": Anonymize<Ier970hnn9pgrj>;
    /**
     * The farming pool is reset.
     */
    "FarmingPoolReset": Anonymize<Ier970hnn9pgrj>;
    /**
     * The farming pool is closed.
     */
    "FarmingPoolClosed": Anonymize<Ier970hnn9pgrj>;
    /**
     * The farming pool is killed.
     */
    "FarmingPoolKilled": Anonymize<Ier970hnn9pgrj>;
    /**
     * The farming pool is edited.
     */
    "FarmingPoolEdited": Anonymize<Ier970hnn9pgrj>;
    /**
     * The pool is charged.
     */
    "Charged": Anonymize<Id05qchr7uq1gj>;
    /**
     * The pool is deposited.
     */
    "Deposited": Anonymize<Ibppp57f2thdnk>;
    /**
     * The pool is withdrawn.
     */
    "Withdrawn": Anonymize<Ibjg5nv0nue710>;
    /**
     * The pool is claimed.
     */
    "Claimed": Anonymize<Ic7bjpulvng8ff>;
    /**
     * The pool is withdrawn claimed.
     */
    "WithdrawClaimed": Anonymize<Ic7bjpulvng8ff>;
    /**
     * The gauge pool is withdrawn.
     */
    "GaugeWithdrawn": Anonymize<I821hq5m5igcn>;
    /**
     * All gauge pools have been claimed.
     */
    "AllForceGaugeClaimed": Anonymize<Ial5va0b0vs25o>;
    /**
     * Partially gauge pools have been claimed.
     */
    "PartiallyForceGaugeClaimed": Anonymize<Ial5va0b0vs25o>;
    /**
     * All pools is retired.
     */
    "AllRetired": Anonymize<Ier970hnn9pgrj>;
    /**
     * Partially pools is retired.
     */
    "PartiallyRetired": Anonymize<Ier970hnn9pgrj>;
    /**
     * The retire limit is set.
     */
    "RetireLimitSet": Anonymize<Iamlqp3gs21baf>;
    /**
     * The round has ended.
     */
    "RoundEnd": Anonymize<I1fd2u5ls04lpi>;
    /**
     * The round has started to fail.
     */
    "RoundStartError": Anonymize<I55nu158c3eng2>;
    /**
     * The round has started.
     */
    "RoundStart": Anonymize<Icn7fuqv1aq0de>;
    /**
     * The exchanger is voted.
     */
    "Voted": Anonymize<I2d67dgvoue7rb>;
    /**
     * The boost pool is charged.
     */
    "BoostCharged": Anonymize<I2sfpbn9h49adg>;
}>;
export type Ier970hnn9pgrj = {
    /**
     * The pool id of the new pool.
     */
    "pid": number;
};
export type Id05qchr7uq1gj = {
    /**
     * The exchanger who charged the pool.
     */
    "who": SS58String;
    /**
     * Charged pool id.
     */
    "pid": number;
    /**
     * Charged rewards.
     */
    "rewards": Anonymize<I2dbamvpq4935>;
};
export type I2dbamvpq4935 = Array<Anonymize<Ifrnnpj83g127a>>;
export type Ifrnnpj83g127a = [Anonymize<Iebirugq1dbhv6>, bigint];
export type Ibppp57f2thdnk = {
    /**
     * The exchanger who deposited the pool.
     */
    "who": SS58String;
    /**
     * Deposited pool id.
     */
    "pid": number;
    /**
     * Deposited value.
     */
    "add_value": bigint;
};
export type Ibjg5nv0nue710 = {
    /**
     * The exchanger who withdrew the pool.
     */
    "who": SS58String;
    /**
     * Withdrawn pool id.
     */
    "pid": number;
    /**
     * Withdrawn value.
     */
    "remove_value"?: Anonymize<I35p85j063s0il>;
};
export type Ic7bjpulvng8ff = {
    /**
     * The exchanger who claimed the pool.
     */
    "who": SS58String;
    /**
     * Claimed pool id.
     */
    "pid": number;
};
export type I821hq5m5igcn = {
    /**
     * The exchanger who withdrew the gauge pool.
     */
    "who": SS58String;
    /**
     * Withdrawn gauge pool id.
     */
    "gid": number;
};
export type Ial5va0b0vs25o = {
    /**
     * Last claimed gauge pool id.
     */
    "gid": number;
};
export type I1fd2u5ls04lpi = {
    "total_votes": bigint;
    /**
     * The start block of the round.
     */
    "start_round": number;
    /**
     * The end block of the round.
     */
    "end_round": number;
};
export type I55nu158c3eng2 = {
    /**
     * The error
     */
    "info": Anonymize<I46mg5gru1rk0a>;
};
export type Icn7fuqv1aq0de = {
    /**
     * The length of the round.
     */
    "round_length": number;
};
export type I2d67dgvoue7rb = {
    /**
     * The exchanger who voted.
     */
    "who": SS58String;
    /**
     * Voted pool id.
     */
    "vote_list": Anonymize<Iep4uo61810hfs>;
};
export type I2sfpbn9h49adg = {
    /**
     * The exchanger who charged the boost pool.
     */
    "who": SS58String;
    /**
     * Charged boost pool id.
     */
    "rewards": Anonymize<I2dbamvpq4935>;
};
export type I3oonoiudj95ud = AnonymousEnum<{
    /**
     * A new staking round has started.
     *
     * - `current`: The index of the current round.
     * - `first`: The block number at which this round started.
     * - `length`: The length of the round in blocks.
     */
    "NewRound": Anonymize<Ial6i7mt9utr8>;
    /**
     * Configuration of a token has been changed.
     *
     * - `token`: The identifier of the token whose configuration changed.
     * - `exec_delay`: The delay in blocks before the changes take effect.
     * - `system_stakable_base`: The base value of system-stakable assets.
     */
    "TokenConfigChanged": Anonymize<Ib6jm3sbjvr41g>;
    /**
     * A deposit operation has failed.
     *
     * - `token`: The identifier of the token being deposited.
     * - `amount`: The amount of the token to be deposited.
     * - `system_stakable_amount`: The amount staked in the system-stakable pool.
     * - `system_shadow_amount`: The amount shadow-staked in the system.
     * - `pending_redeem_amount`: The amount pending redemption.
     */
    "DepositFailed": Anonymize<I32m7n87450pqk>;
    /**
     * Minting operation succeeded.
     *
     * - `token`: The identifier of the token being minted.
     * - `amount`: The amount of the token to be minted.
     * - `system_stakable_amount`: The amount staked in the system-stakable pool.
     * - `system_shadow_amount`: The amount shadow-staked in the system.
     * - `pending_redeem_amount`: The amount pending redemption.
     */
    "MintSuccess": Anonymize<I32m7n87450pqk>;
    /**
     * Minting operation failed.
     *
     * # Parameters
     * (Same as MintSuccess)
     */
    "MintFailed": Anonymize<I32m7n87450pqk>;
    /**
     * Withdrawal operation succeeded.
     *
     * # Parameters
     * (Same as MintSuccess)
     */
    "WithdrawSuccess": Anonymize<I32m7n87450pqk>;
    /**
     * Withdrawal operation failed.
     *
     * # Parameters
     * (Same as MintSuccess)
     */
    "WithdrawFailed": Anonymize<I32m7n87450pqk>;
    /**
     * A redemption operation has succeeded.
     *
     * # Parameters
     * (Same as MintSuccess)
     */
    "Redeemed": Anonymize<I32m7n87450pqk>;
    /**
     * A redemption operation has failed.
     *
     * # Parameters
     * (Same as MintSuccess)
     */
    "RedeemFailed": Anonymize<I32m7n87450pqk>;
    /**
     * The specified token could not be found.
     *
     * - `token`: The identifier of the token that was not found.
     */
    "VtokenNotFound": Anonymize<Ibmoqhjadutned>;
    /**
     * Token information has been refreshed.
     *
     * - `token`: The identifier of the token whose information was refreshed.
     */
    "TokenInfoRefreshed": Anonymize<Ibmoqhjadutned>;
    /**
     * A payout has been made.
     *
     * - `token`: The identifier of the token involved in the payout.
     * - `vtoken`: The identifier of the vtoken involved.
     * - `from`: The account from which the payout originated.
     * - `to`: The account to which the payout was made.
     * - `amount`: The total amount of the payout.
     * - `free`: The amount of free balance after the payout.
     * - `vfree`: The amount of vtoken free balance after the payout.
     * - `shadow`: The shadow balance after the payout.
     */
    "Payout": Anonymize<Idmkbek876hj4c>;
    /**
     * payout error
     */
    "PayoutFailed": Anonymize<Ibmoqhjadutned>;
}>;
export type Ial6i7mt9utr8 = {
    "current": number;
    "first": number;
    "length": number;
};
export type Ib6jm3sbjvr41g = {
    "token": Anonymize<Iebirugq1dbhv6>;
    "exec_delay": number;
    "system_stakable_base": bigint;
};
export type I32m7n87450pqk = {
    "token": Anonymize<Iebirugq1dbhv6>;
    "amount": bigint;
    "system_stakable_amount": bigint;
    "system_shadow_amount": bigint;
    "pending_redeem_amount": bigint;
};
export type Ibmoqhjadutned = {
    "token": Anonymize<Iebirugq1dbhv6>;
};
export type Idmkbek876hj4c = {
    "token": Anonymize<Iebirugq1dbhv6>;
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "from": SS58String;
    "to": SS58String;
    "amount": bigint;
    "free": bigint;
    "vfree": bigint;
    "shadow": bigint;
};
export type Ickekbsj4u887j = AnonymousEnum<{
    /**
     * A successful call of the `CreateDistribution` extrinsic will create this event.
     */
    "Created": Anonymize<I3096t0on20q3r>;
    /**
     * A successful call of the `EditDistribution` extrinsic will create this event.
     */
    "Edited": Anonymize<I3096t0on20q3r>;
    /**
     * A successful call of the `SetEraLength` extrinsic will create this event.
     */
    "EraLengthSet": Anonymize<I1s5stmgs1hmpi>;
    /**
     * A successful call of the `ExecuteDistribute` extrinsic will create this event.
     */
    "Executed": Anonymize<I6d2fsv919ackd>;
    /**
     * A successful call of the `DeleteDistribution` extrinsic will create this event.
     */
    "Deleted": Anonymize<I6d2fsv919ackd>;
    /**
     * A failed call of the `ExecuteDistribute` extrinsic will create this event.
     */
    "ExecuteFailed": Anonymize<Im4b2ikida3i9>;
    /**
     * A successful call of the `SetUSDConfig` extrinsic will create this event.
     */
    "USDConfigSet": Anonymize<Ia6mtguicisar7>;
}>;
export type I3096t0on20q3r = {
    /**
     * Distribution ID
     */
    "distribution_id": number;
    /**
     * Distribution information
     */
    "info": Anonymize<Ifm7mj15s63a8e>;
};
export type Ifm7mj15s63a8e = {
    "fee_share_account_id": SS58String;
    "token_type": Anonymize<I6ae21pstqk9et>;
    "if_auto": boolean;
};
export type I1s5stmgs1hmpi = {
    /**
     * The interval between distribution executions
     */
    "era_length": number;
    /**
     * The block number of the next era
     */
    "next_era": number;
};
export type I6d2fsv919ackd = {
    /**
     * Distribution ID
     */
    "distribution_id": number;
};
export type Im4b2ikida3i9 = {
    /**
     * Distribution ID
     */
    "distribution_id": number;
    /**
     * Distribution information
     */
    "info": Anonymize<Ifm7mj15s63a8e>;
    /**
     * The block number of the next era
     */
    "next_era": number;
};
export type Ia6mtguicisar7 = {
    /**
     * Distribution ID
     */
    "distribution_id": number;
    /**
     * USD standard information
     */
    "info": Anonymize<Ieqteqhnicu2mf>;
};
export type Ieqteqhnicu2mf = {
    "target_value": bigint;
    "cumulative": bigint;
    "target_account_id": SS58String;
    "target_block": number;
    "interval": number;
};
export type I1siqn564k36so = AnonymousEnum<{
    /**
     * Event emitted when a currency is successfully crossed out from a location.
     */
    "CrossedOut": Anonymize<Ibm9jk932uhjiv>;
    /**
     * Event emitted when a currency is deregistered.
     */
    "CurrencyDeregistered": Anonymize<I6dlum3cbrie3d>;
    /**
     * Event emitted when a linked account is successfully registered.
     */
    "LinkedAccountRegistered": Anonymize<Idraqa5k2q8rna>;
    /**
     * Event emitted when an account is added to the register list.
     */
    "AddedToRegisterList": Anonymize<Iapol5cojcq8jr>;
    /**
     * Event emitted when an account is removed from the register list.
     */
    "RemovedFromRegisterList": Anonymize<Iapol5cojcq8jr>;
    /**
     * Event emitted when the crossing minimum amounts are set for a currency.
     */
    "CrossingMinimumAmountSet": Anonymize<Iarqih3rei93nj>;
}>;
export type Ibm9jk932uhjiv = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "crosser": SS58String;
    "location": Anonymize<I4c0s5cioidn76>;
    "amount": bigint;
};
export type Idraqa5k2q8rna = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": SS58String;
    "foreign_location": Anonymize<I4c0s5cioidn76>;
};
export type Iapol5cojcq8jr = {
    "account": SS58String;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
};
export type Iarqih3rei93nj = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "cross_in_minimum": bigint;
    "cross_out_minimum": bigint;
};
export type I3lfnu67umnl7t = AnonymousEnum<{
    /**
     * The minimum number of TokenType and minimum time that users can lock has been set.
     */
    "ConfigSet": Anonymize<I4l0aflet4nrh2>;
    /**
     * A successful call of the `create_lock` function.
     */
    "Minted": Anonymize<I1d1m4pqd4gk9n>;
    /**
     * Change in TokenType locked after calling.
     */
    "Supply": Anonymize<I9l001vgvntb06>;
    /**
     * A position was created.
     */
    "LockCreated": Anonymize<I4n99li1ojr2lt>;
    /**
     * A position was extended.
     */
    "UnlockTimeIncreased": Anonymize<I11eppnh5mek19>;
    /**
     * A position was increased.
     */
    "AmountIncreased": Anonymize<I583v57rub6gg>;
    /**
     * A position was withdrawn.
     */
    "Withdrawn": Anonymize<I583v57rub6gg>;
    /**
     * Incentive config set.
     */
    "IncentiveSet": Anonymize<I4jhonprkmaiu3>;
    /**
     * The rewards for this round have been added to the system account.
     */
    "RewardAdded": Anonymize<I9l30vpvn51jcs>;
    /**
     * The user has received the reward.
     */
    "Rewarded": Anonymize<I2sfpbn9h49adg>;
    /**
     * This currency_id has been refreshed.
     */
    "AllRefreshed": Anonymize<I6dlum3cbrie3d>;
    /**
     * This currency_id has been partially refreshed.
     */
    "PartiallyRefreshed": Anonymize<I6dlum3cbrie3d>;
    /**
     * Notify reward failed.
     */
    "NotifyRewardFailed": Anonymize<I9l30vpvn51jcs>;
    /**
     * Markup has been deposited.
     */
    "MarkupDeposited": Anonymize<Icglvublte8208>;
    /**
     * Markup has been withdrawn.
     */
    "MarkupWithdrawn": Anonymize<Iabmnrd4204mhc>;
}>;
export type I4l0aflet4nrh2 = {
    "config": Anonymize<I4os3q75qs0t9f>;
};
export type I4os3q75qs0t9f = {
    "min_mint": bigint;
    "min_block": number;
    "max_positions_per_block": number;
};
export type I1d1m4pqd4gk9n = {
    /**
     * the user who mint
     */
    "who": SS58String;
    /**
     * the position of this minting
     */
    "position": bigint;
    /**
     * the value of this minting
     */
    "value": bigint;
    /**
     * total mint value for this user
     */
    "total_value": bigint;
    /**
     * old withdrawable time
     */
    "old_end": number;
    /**
     * new withdrawable time
     */
    "end": number;
    /**
     * current time
     */
    "now": number;
};
export type I9l001vgvntb06 = {
    /**
     * The balance before the change.
     */
    "supply_before": bigint;
    /**
     * The balance after the change.
     */
    "supply": bigint;
};
export type I4n99li1ojr2lt = {
    /**
     * Position owner
     */
    "who": SS58String;
    /**
     * Position ID
     */
    "position": bigint;
    /**
     * Locked value
     */
    "value": bigint;
    /**
     * old withdrawable time
     */
    "old_unlock_time": number;
    /**
     * new withdrawable time
     */
    "unlock_time": number;
};
export type I11eppnh5mek19 = {
    /**
     * Position owner
     */
    "who": SS58String;
    /**
     * Position ID
     */
    "position": bigint;
    /**
     * Old withdrawable time
     */
    "old_unlock_time": number;
    /**
     * New withdrawable time
     */
    "unlock_time": number;
};
export type I583v57rub6gg = {
    /**
     * Position owner
     */
    "who": SS58String;
    /**
     * Position ID
     */
    "position": bigint;
    /**
     * Increased value, not new locked value
     */
    "value": bigint;
};
export type I4jhonprkmaiu3 = {
    "incentive_config": Anonymize<I4bv41jk9n83m8>;
};
export type I4bv41jk9n83m8 = {
    "reward_rate": Anonymize<I2dbamvpq4935>;
    "reward_per_token_stored": Anonymize<I2dbamvpq4935>;
    "rewards_duration": number;
    "period_finish": number;
    "last_update_time": number;
    "incentive_controller"?: Anonymize<Ihfphjolmsqq1>;
    "last_reward": Anonymize<I6ae21pstqk9et>;
};
export type I9l30vpvn51jcs = {
    "rewards": Anonymize<I6ae21pstqk9et>;
};
export type Icglvublte8208 = {
    /**
     * The user who deposited
     */
    "who": SS58String;
    /**
     * The token type of the deposit
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The amount of currency_id to be deposited this time
     */
    "value": bigint;
};
export type Iabmnrd4204mhc = {
    "who": SS58String;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
};
export type I4ursntiif5vp5 = AnonymousEnum<{
    /**
     * Add the contract account to the whitelist
     */
    "AddWhitelistAccountId": Anonymize<I3r2vobfen6tu5>;
    /**
     * Remove the contract account from the whitelist
     */
    "RemoveWhitelistAccountId": Anonymize<I3r2vobfen6tu5>;
    /**
     * Set the transfer fee for the currency, only for Moonbeam
     */
    "SetTransferToFee": Anonymize<I6s65kicknm51n>;
    /**
     * Set the execution fee for the order
     */
    "SetExecutionFee": Anonymize<I7u9oegj4csj51>;
    /**
     * Support currency to xcm oracle
     */
    "SupportXcmOracle": Anonymize<Ifuaakr3i6qaje>;
    /**
     * Set the xcm oracle configuration
     */
    "SetXcmOracleConfiguration": Anonymize<I792urf76hgnm9>;
    /**
     * Send Xcm message
     */
    "XcmOracle": Anonymize<I2trdp5iask9k1>;
    /**
     * Set the currency to support the XCM fee
     */
    "SetCurrencyToSupportXcmFee": Anonymize<Ifuaakr3i6qaje>;
    /**
     * Set the delay block
     */
    "SetDelayBlock": Anonymize<I7j4i782lpafvm>;
    /**
     * Create order
     */
    "CreateOrder": Anonymize<Ic72ofb1evmh8f>;
    /**
     * Order handled
     */
    "OrderHandled": Anonymize<Ic72ofb1evmh8f>;
    /**
     * Order failed
     */
    "OrderFailed": Anonymize<Ic72ofb1evmh8f>;
    /**
     * Xcm oracle failed
     */
    "XcmOracleFailed": Anonymize<Ia74hfkpnt69k4>;
    /**
     * Withdraw xcm fee
     */
    "InsufficientAssets": undefined;
    /**
     * Set HyperBridge Oracle Config
     */
    "SetHyperBridgeOracleConfig": Anonymize<Ido7vo1b67803n>;
    /**
     * Set Hydration Oracle Config
     */
    "SetHydrationOracleConfig": Anonymize<Iqdolbo3k85bf>;
    /**
     * Async Mint executed
     */
    "AsyncMintExecuted": Anonymize<I1s6n791iat49a>;
    /**
     * Async Mint configuration updated
     */
    "AsyncMintConfigUpdated": Anonymize<If9ob1e8r14nrm>;
    /**
     * Async Mint execution failed
     */
    "AsyncMintExecutionFailed": Anonymize<Icb87m5nbt8smg>;
}>;
export type I3r2vobfen6tu5 = {
    /**
     * The support chain of Slpx
     */
    "support_chain": Anonymize<I3em9l2q88o7if>;
    /**
     * The contract address of the contract
     */
    "contract_address": FixedSizeBinary<20>;
    /**
     * Xcm derivative account id
     */
    "evm_contract_account_id": SS58String;
};
export type I3em9l2q88o7if = AnonymousEnum<{
    "Astar": undefined;
    "Moonbeam": undefined;
    "Hydradx": undefined;
    "Interlay": undefined;
    "Manta": undefined;
}>;
export type I6s65kicknm51n = {
    /**
     * The support chain of Slpx
     */
    "support_chain": Anonymize<I3em9l2q88o7if>;
    /**
     * The transfer fee of the token
     */
    "transfer_to_fee": bigint;
};
export type I7u9oegj4csj51 = {
    /**
     * The currency id of the token
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The execution fee of the order
     */
    "execution_fee": bigint;
};
export type Ifuaakr3i6qaje = {
    /**
     * The currency id of the token
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * Whether to support the xcm oracle
     */
    "is_support": boolean;
};
export type I792urf76hgnm9 = {
    /**
     * The XCM fee of Sending Xcm
     */
    "xcm_fee": bigint;
    /**
     * The XCM weight of Sending Xcm
     */
    "xcm_weight": Anonymize<I4q39t5hn830vp>;
    /**
     * The period of Sending Xcm
     */
    "period": number;
    /**
     * The address of XcmOracle
     */
    "contract": FixedSizeBinary<20>;
};
export type I2trdp5iask9k1 = {
    /**
     * The currency id of the token
     */
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The currency amount of staking
     */
    "staking_currency_amount": bigint;
    /**
     * The currency id of the vtoken
     */
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The currency total supply of vtoken
     */
    "v_currency_total_supply": bigint;
};
export type I7j4i782lpafvm = {
    /**
     * The delay block
     */
    "delay_block": number;
};
export type Ic72ofb1evmh8f = {
    "order": Anonymize<I3rsia7pa3ke9b>;
};
export type I3rsia7pa3ke9b = {
    "source_chain_caller": Anonymize<Ibbodv9tjmq4ua>;
    "source_chain_id": bigint;
    "source_chain_block_number"?: Anonymize<I35p85j063s0il>;
    "bifrost_chain_caller": SS58String;
    "derivative_account": SS58String;
    "create_block_number": number;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "currency_amount": bigint;
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
    "v_currency_amount": bigint;
    "order_type": Enum<{
        "Mint": undefined;
        "Redeem": undefined;
    }>;
    "remark": Binary;
    "target_chain": Anonymize<Ibi4k1clc8t3vv>;
    "channel_id": number;
};
export type Ibbodv9tjmq4ua = AnonymousEnum<{
    "Substrate": SS58String;
    "Evm": FixedSizeBinary<20>;
}>;
export type Ibi4k1clc8t3vv = AnonymousEnum<{
    "Astar": FixedSizeBinary<20>;
    "Moonbeam": FixedSizeBinary<20>;
    "Hydradx": SS58String;
    "Interlay": SS58String;
    "Manta": SS58String;
    "HyperBridge": Anonymize<Ia46odf30322a1>;
}>;
export type Ido7vo1b67803n = {
    "chain_id": number;
    "to": FixedSizeBinary<20>;
    "timeout": bigint;
    "period": number;
    "tokens": Anonymize<Ifbg8drm29v6va>;
};
export type Ifbg8drm29v6va = Array<[Anonymize<Iebirugq1dbhv6>, FixedSizeBinary<20>]>;
export type Iqdolbo3k85bf = {
    "period": number;
    "tokens": Anonymize<Ic4m824gh8aavk>;
};
export type Ic4m824gh8aavk = Array<[Anonymize<Iebirugq1dbhv6>, Anonymize<If9iqq7i64mur8>, Anonymize<If9iqq7i64mur8>]>;
export type I1s6n791iat49a = {
    /**
     * The caller of the async mint
     */
    "caller": SS58String;
    /**
     * The chain id of the target chain
     */
    "from_chain_id": number;
    /**
     * The currency id of the token
     */
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The amount of vToken minted
     */
    "minted_v_currency_amount": bigint;
    /**
     * The amount of vToken issued
     */
    "additional_v_currency_amount": bigint;
};
export type If9ob1e8r14nrm = {
    /**
     * The new configuration
     */
    "config": Anonymize<Iefb7gficrner>;
};
export type Iefb7gficrner = {
    "max_issuance_ratio": bigint;
    "block_interval": number;
};
export type Icb87m5nbt8smg = {
    /**
     * The chain id of the target chain
     */
    "from_chain_id": number;
    /**
     * The currency id of the token
     */
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The v_currency amount of the token
     */
    "additional_v_currency_amount": bigint;
};
export type Ifuucdgpuglunu = AnonymousEnum<{
    /**
     * A member `who` has been added.
     */
    "MemberAdded": Anonymize<I4cbvqmqadhrea>;
    /**
     * The member `who`se rank has been changed to the given `rank`.
     */
    "RankChanged": Anonymize<Im1pm2vf6llcn>;
    /**
     * The member `who` of given `rank` has been removed from the collective.
     */
    "MemberRemoved": Anonymize<Im1pm2vf6llcn>;
    /**
     * The member `who` has voted for the `poll` with the given `vote` leading to an updated
     * `tally`.
     */
    "Voted": Anonymize<I21jsoeb0o6476>;
    /**
     * The member `who` had their `AccountId` changed to `new_who`.
     */
    "MemberExchanged": Anonymize<Ier6ck0tpfo7>;
}>;
export type Im1pm2vf6llcn = {
    "who": SS58String;
    "rank": number;
};
export type I21jsoeb0o6476 = {
    "who": SS58String;
    "poll": number;
    "vote": Anonymize<I3gg47bgkgq9tr>;
    "tally": Anonymize<I6d634btv7misu>;
};
export type I3gg47bgkgq9tr = AnonymousEnum<{
    "Aye": number;
    "Nay": number;
}>;
export type I6d634btv7misu = {
    "bare_ayes": number;
    "ayes": number;
    "nays": number;
};
export type Ier6ck0tpfo7 = {
    "who": SS58String;
    "new_who": SS58String;
};
export type I28aoa43r171jt = AnonymousEnum<{
    /**
     * A referendum has been submitted.
     */
    "Submitted": Anonymize<I229ijht536qdu>;
    /**
     * The decision deposit has been placed.
     */
    "DecisionDepositPlaced": Anonymize<I62nte77gksm0f>;
    /**
     * The decision deposit has been refunded.
     */
    "DecisionDepositRefunded": Anonymize<I62nte77gksm0f>;
    /**
     * A deposit has been slashed.
     */
    "DepositSlashed": Anonymize<Id5fm4p8lj5qgi>;
    /**
     * A referendum has moved into the deciding phase.
     */
    "DecisionStarted": Anonymize<Ic6ecdcp9ut7jd>;
    "ConfirmStarted": Anonymize<I666bl2fqjkejo>;
    "ConfirmAborted": Anonymize<I666bl2fqjkejo>;
    /**
     * A referendum has ended its confirmation phase and is ready for approval.
     */
    "Confirmed": Anonymize<I27notaksll8qt>;
    /**
     * A referendum has been approved and its proposal has been scheduled.
     */
    "Approved": Anonymize<I666bl2fqjkejo>;
    /**
     * A proposal has been rejected by referendum.
     */
    "Rejected": Anonymize<I27notaksll8qt>;
    /**
     * A referendum has been timed out without being decided.
     */
    "TimedOut": Anonymize<I27notaksll8qt>;
    /**
     * A referendum has been cancelled.
     */
    "Cancelled": Anonymize<I27notaksll8qt>;
    /**
     * A referendum has been killed.
     */
    "Killed": Anonymize<I27notaksll8qt>;
    /**
     * The submission deposit has been refunded.
     */
    "SubmissionDepositRefunded": Anonymize<I62nte77gksm0f>;
    /**
     * Metadata for a referendum has been set.
     */
    "MetadataSet": Anonymize<I4f1hv034jf1dt>;
    /**
     * Metadata for a referendum has been cleared.
     */
    "MetadataCleared": Anonymize<I4f1hv034jf1dt>;
}>;
export type Ic6ecdcp9ut7jd = {
    /**
     * Index of the referendum.
     */
    "index": number;
    /**
     * The track (and by extension proposal dispatch origin) of this referendum.
     */
    "track": number;
    /**
     * The proposal for the referendum.
     */
    "proposal": PreimagesBounded;
    /**
     * The current tally of votes in this referendum.
     */
    "tally": Anonymize<I6d634btv7misu>;
};
export type I27notaksll8qt = {
    /**
     * Index of the referendum.
     */
    "index": number;
    /**
     * The final tally of votes in this referendum.
     */
    "tally": Anonymize<I6d634btv7misu>;
};
export type I9449gf1cit5 = AnonymousEnum<{
    /**
     * A new pool is created.
     */
    "CreatePool": Anonymize<I54dj4621btbog>;
    /**
     * Liquidity is added to the pool.
     */
    "LiquidityAdded": Anonymize<I8eeivtdimg5sg>;
    /**
     * Token is swapped.
     */
    "TokenSwapped": Anonymize<I2i1mj9dta3f5r>;
    /**
     * Token is redeemed by proportion.
     */
    "RedeemedProportion": Anonymize<Ie26sa5pkqc7lh>;
    /**
     * Token is redeemed by single asset.
     */
    "RedeemedSingle": Anonymize<I5a9b1h9uneb16>;
    /**
     * Token is redeemed by multiple assets.
     */
    "RedeemedMulti": Anonymize<It3rcku7atiln>;
    /**
     * The pool field balances is updated.
     */
    "BalanceUpdated": Anonymize<I2e6ar36i5p9qo>;
    /**
     * Yield is collected.
     */
    "YieldCollected": Anonymize<Ifssptimng3fig>;
    /**
     * Fee is collected.
     */
    "FeeCollected": Anonymize<I2d4kqt7h8dvva>;
    /**
     * The pool amplification coefficient is modified.
     */
    "AModified": Anonymize<I6ou90sd9g7cje>;
    /**
     * The pool fees are modified.
     */
    "FeeModified": Anonymize<I3dqh1v95db76q>;
    /**
     * The pool recipients are modified.
     */
    "RecipientModified": Anonymize<Iec84e3i3f9e7f>;
    /**
     * The token rate is set.
     */
    "TokenRateSet": Anonymize<Id99ueqaguc9dv>;
    /**
     * The hardcap of the token rate is configured.
     */
    "TokenRateHardcapConfigured": Anonymize<Icu74rtf3kd9gd>;
    /**
     * The hardcap of the token rate is removed.
     */
    "TokenRateHardcapRemoved": Anonymize<I8v7akpi7cdcp5>;
    /**
     * The token rate is refreshed.
     */
    "TokenRateRefreshFailed": Anonymize<I931cottvong90>;
    /**
     * Rate adjustment was limited by hardcap
     * Parameters: [pool_id, vtoken, current_rate, target_rate, adjusted_rate]
     */
    "RateAdjustmentLimited": Anonymize<I4km0f35j8vt1e>;
}>;
export type I54dj4621btbog = {
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * Amplification coefficient of the pool.
     */
    "a": bigint;
    /**
     * The system account of the pool.
     */
    "swap_id": SS58String;
    /**
     * Pallet id.
     */
    "pallet_id": SS58String;
};
export type I8eeivtdimg5sg = {
    /**
     * The account who added the liquidity.
     */
    "minter": SS58String;
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * Amplification coefficient of the pool.
     */
    "a": bigint;
    /**
     * The input amounts of the assets.
     */
    "input_amounts": Anonymize<Iafqnechp3omqg>;
    /**
     * Expected minimum output amount.
     */
    "min_output_amount": bigint;
    /**
     * Balances data.
     */
    "balances": Anonymize<Iafqnechp3omqg>;
    /**
     * The total supply of the pool asset.
     */
    "total_supply": bigint;
    /**
     * fee amount of the pool asset.
     */
    "fee_amount": bigint;
    /**
     * Actual minimum output amount.
     */
    "output_amount": bigint;
};
export type I2i1mj9dta3f5r = {
    /**
     * The account who swapped the token.
     */
    "swapper": SS58String;
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * Amplification coefficient of the pool.
     */
    "a": bigint;
    /**
     * The input asset type.
     */
    "input_asset": Anonymize<Iebirugq1dbhv6>;
    /**
     * The output asset type.
     */
    "output_asset": Anonymize<Iebirugq1dbhv6>;
    /**
     * The input amount of the input asset.
     */
    "input_amount": bigint;
    /**
     * The expected minimum output amount of the output asset.
     */
    "min_output_amount": bigint;
    /**
     * Balances data.
     */
    "balances": Anonymize<Iafqnechp3omqg>;
    /**
     * The total supply of the pool asset.
     */
    "total_supply": bigint;
    /**
     * Actual output amount of the output asset.
     */
    "output_amount": bigint;
};
export type Ie26sa5pkqc7lh = {
    /**
     * The account who redeemed the token.
     */
    "redeemer": SS58String;
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * Amplification coefficient of the pool.
     */
    "a": bigint;
    /**
     * The input amount of the pool asset.
     */
    "input_amount": bigint;
    /**
     * The expected minimum output amounts of the assets.
     */
    "min_output_amounts": Anonymize<Iafqnechp3omqg>;
    /**
     * Balances data.
     */
    "balances": Anonymize<Iafqnechp3omqg>;
    /**
     * The total supply of the pool asset.
     */
    "total_supply": bigint;
    /**
     * fee amount of the pool asset.
     */
    "fee_amount": bigint;
    /**
     * Actual output amounts of the assets.
     */
    "output_amounts": Anonymize<Iafqnechp3omqg>;
};
export type I5a9b1h9uneb16 = {
    /**
     * The account who redeemed the token.
     */
    "redeemer": SS58String;
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * Amplification coefficient of the pool.
     */
    "a": bigint;
    /**
     * The input asset type.
     */
    "input_amount": bigint;
    /**
     * The output asset type.
     */
    "output_asset": Anonymize<Iebirugq1dbhv6>;
    /**
     * The expected minimum output amount of the output asset.
     */
    "min_output_amount": bigint;
    /**
     * Balances data.
     */
    "balances": Anonymize<Iafqnechp3omqg>;
    /**
     * The total supply of the pool asset.
     */
    "total_supply": bigint;
    /**
     * fee amount of the pool asset.
     */
    "fee_amount": bigint;
    /**
     * Actual output amount of the output asset.
     */
    "output_amount": bigint;
};
export type It3rcku7atiln = {
    /**
     * The account who redeemed the token.
     */
    "redeemer": SS58String;
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * Amplification coefficient of the pool.
     */
    "a": bigint;
    /**
     * The expected output amounts.
     */
    "output_amounts": Anonymize<Iafqnechp3omqg>;
    /**
     * The maximum input amount of the pool asset to get the output amounts.
     */
    "max_input_amount": bigint;
    /**
     * Balances data.
     */
    "balances": Anonymize<Iafqnechp3omqg>;
    /**
     * The total supply of the pool asset.
     */
    "total_supply": bigint;
    /**
     * fee amount of the pool asset.
     */
    "fee_amount": bigint;
    /**
     * Actual input amount of the pool asset.
     */
    "input_amount": bigint;
};
export type I2e6ar36i5p9qo = {
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * The old balances.
     */
    "old_balances": Anonymize<Iafqnechp3omqg>;
    /**
     * The new balances.
     */
    "new_balances": Anonymize<Iafqnechp3omqg>;
};
export type Ifssptimng3fig = {
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * Amplification coefficient of the pool.
     */
    "a": bigint;
    /**
     * The old total supply of the pool asset.
     */
    "old_total_supply": bigint;
    /**
     * The new total supply of the pool asset.
     */
    "new_total_supply": bigint;
    /**
     * The account who collected the yield.
     */
    "who": SS58String;
    /**
     * The amount of the pool asset collected.
     */
    "amount": bigint;
};
export type I2d4kqt7h8dvva = {
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * Amplification coefficient of the pool.
     */
    "a": bigint;
    /**
     * The old balances.
     */
    "old_balances": Anonymize<Iafqnechp3omqg>;
    /**
     * The new balances.
     */
    "new_balances": Anonymize<Iafqnechp3omqg>;
    /**
     * The old total supply of the pool asset.
     */
    "old_total_supply": bigint;
    /**
     * The new total supply of the pool asset.
     */
    "new_total_supply": bigint;
    /**
     * The account who has been collected the fee.
     */
    "who": SS58String;
    /**
     * The fee amount of the pool asset.
     */
    "amount": bigint;
};
export type I6ou90sd9g7cje = {
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * The new amplification coefficient.
     */
    "value": bigint;
    /**
     * The block number when the new amplification coefficient will be effective.
     */
    "time": number;
};
export type I3dqh1v95db76q = {
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * The new mint fee.
     */
    "mint_fee": bigint;
    /**
     * The new swap fee.
     */
    "swap_fee": bigint;
    /**
     * The new redeem fee.
     */
    "redeem_fee": bigint;
};
export type Iec84e3i3f9e7f = {
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * The new fee recipient.
     */
    "fee_recipient": SS58String;
    /**
     * The new yield recipient.
     */
    "yield_recipient": SS58String;
};
export type Id99ueqaguc9dv = {
    /**
     * The pool id.
     */
    "pool_id": number;
    /**
     * The token rate info[(currency_id, (denominator, numerator))].
     */
    "token_rate": Anonymize<Idtci0ovsdvku6>;
};
export type Idtci0ovsdvku6 = Array<[Anonymize<Iebirugq1dbhv6>, Anonymize<I200n1ov5tbcvr>]>;
export type Icu74rtf3kd9gd = {
    /**
     * The token type.
     */
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    /**
     * The hardcap of the token rate.
     */
    "hardcap": number;
};
export type I8v7akpi7cdcp5 = {
    /**
     * The token type.
     */
    "vtoken": Anonymize<Iebirugq1dbhv6>;
};
export type I4km0f35j8vt1e = [number, Anonymize<Iebirugq1dbhv6>, Anonymize<I4totqt881mlti>, Anonymize<I4totqt881mlti>, Anonymize<I4totqt881mlti>];
export type I7s7ajrmv13hni = AnonymousEnum<{
    /**
     * A vote has been cast.
     *
     * - `who`: The account that cast the vote.
     * - `vtoken`: The token used for voting.
     * - `poll_index`: The index of the poll being voted on.
     * - `token_vote`: The vote cast using the token.
     * - `delegator_vote`: The vote cast by a delegator.
     */
    "Voted": Anonymize<I1u6hbnc76ae0b>;
    /**
     * A user's vote has been unlocked, allowing them to retrieve their tokens.
     *
     * - `who`: The account whose tokens are unlocked.
     * - `vtoken`: The token that was locked during voting.
     * - `poll_index`: The index of the poll associated with the unlocking,
     * If set to none, the unlocked assets are those voted for by users through delegation.
     */
    "Unlocked": Anonymize<Ie0lvd1qdm103>;
    /**
     * A delegator's vote has been removed.
     *
     * - `who`: The account that dispatched remove_delegator_vote.
     * - `vtoken`: The token associated with the delegator's vote.
     * - `derivative_index`: The index of the derivative.
     */
    "DelegatorVoteRemoved": Anonymize<Ib3hb8lrtttf9v>;
    /**
     * A delegator has been added.
     *
     * - `vtoken`: The token associated with the delegator.
     * - `derivative_index`: The index of the derivative being added for the delegator.
     */
    "DelegatorAdded": Anonymize<Iefli0cgm44m3b>;
    /**
     * A new referendum information has been created.
     *
     * - `vtoken`: The token associated with the referendum.
     * - `poll_index`: The index of the poll.
     * - `info`: The referendum information (details about the poll).
     */
    "ReferendumInfoCreated": Anonymize<Iaij9kantm3v0b>;
    /**
     * Referendum information has been updated.
     *
     * - `vtoken`: The token associated with the referendum.
     * - `poll_index`: The index of the poll.
     * - `info`: The updated referendum information.
     */
    "ReferendumInfoSet": Anonymize<Iaij9kantm3v0b>;
    /**
     * The vote locking period has been set.
     *
     * - `vtoken`: The token for which the locking period is being set.
     * - `locking_period`: The period for which votes will be locked (in block numbers).
     */
    "VoteLockingPeriodSet": Anonymize<I8l8g9smisvqei>;
    /**
     * The undeciding timeout period has been set.
     *
     * - `vtoken`: The token associated with the timeout.
     * - `undeciding_timeout`: The period of time before a poll is considered undecided.
     */
    "UndecidingTimeoutSet": Anonymize<I2ce5d3bnbbfhi>;
    /**
     * A referendum has been killed (cancelled or ended).
     *
     * - `vtoken`: The token associated with the referendum.
     * - `poll_index`: The index of the poll being killed.
     */
    "ReferendumKilled": Anonymize<Iaj42ghmtrj594>;
    /**
     * A notification about the result of a vote has been sent.
     *
     * - `vtoken`: The token associated with the poll.
     * - `poll_index`: The index of the poll.
     * - `success`: Whether the notification was successful or not.
     */
    "VoteNotified": Anonymize<Iet09kgtjdhfi9>;
    /**
     * A notification about the removal of a delegator's vote has been sent.
     *
     * - `vtoken`: The token associated with the poll.
     * - `poll_index`: The index of the poll.
     * - `success`: Whether the notification was successful or not.
     */
    "DelegatorVoteRemovedNotified": Anonymize<Iet09kgtjdhfi9>;
    /**
     * A response has been received from a specific location.
     *
     * - `responder`: The location that sent the response.
     * - `query_id`: The ID of the query that was responded to.
     * - `response`: The content of the response.
     */
    "ResponseReceived": Anonymize<Ierak47ctqnjrn>;
    /**
     * The vote cap ratio has been set.
     *
     * - `vtoken`: The token associated with the cap.
     * - `vote_cap_ratio`: The maximum allowed ratio for the vote.
     */
    "VoteCapRatioSet": Anonymize<Ifuh1k8nfv6s7l>;
    /**
     * A referendum's status was updated.
     */
    "ReferendumStatusUpdated": Anonymize<I5ca2goaq3h8bs>;
    /**
     * An account has delegated their vote to another account. \[who, target\]
     */
    "Delegated": Anonymize<I10r7il4gvbcae>;
    /**
     * An \[account\] has cancelled a previous delegation operation.
     */
    "Undelegated": SS58String;
}>;
export type I1u6hbnc76ae0b = {
    "who": SS58String;
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "poll_index": number;
    "token_vote": ConvictionVotingVoteAccountVote;
    "delegator_vote": ConvictionVotingVoteAccountVote;
};
export type Ie0lvd1qdm103 = {
    "who": SS58String;
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "maybe_poll_index"?: Anonymize<I4arjljr6dpflb>;
};
export type Ib3hb8lrtttf9v = {
    "who": SS58String;
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "derivative_index": number;
};
export type Iefli0cgm44m3b = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "derivative_index": number;
};
export type Iaij9kantm3v0b = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "poll_index": number;
    "info": Anonymize<I5m768sb1iam8f>;
};
export type I5m768sb1iam8f = AnonymousEnum<{
    "Ongoing": {
        "submitted"?: Anonymize<I4arjljr6dpflb>;
        "tally": Anonymize<Ifsk7cbmtit1jd>;
    };
    "Completed": number;
    "Killed": number;
}>;
export type I8l8g9smisvqei = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "locking_period": number;
};
export type I2ce5d3bnbbfhi = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "undeciding_timeout": number;
};
export type Iaj42ghmtrj594 = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "poll_index": number;
};
export type Iet09kgtjdhfi9 = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "poll_index": number;
    "success": boolean;
};
export type Ierak47ctqnjrn = {
    "responder": Anonymize<If9iqq7i64mur8>;
    "query_id": bigint;
    "response": Anonymize<I7vucpgm2c6959>;
};
export type Ifuh1k8nfv6s7l = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "vote_cap_ratio": number;
};
export type I5ca2goaq3h8bs = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "poll_index": number;
    "new_status": Anonymize<I6kqftg4r08qah>;
};
export type I6kqftg4r08qah = AnonymousEnum<{
    "Approved": undefined;
    "Rejected": undefined;
    "None": undefined;
    "Ongoing": undefined;
}>;
export type I10r7il4gvbcae = {
    "who": SS58String;
    "target": SS58String;
};
export type Iff94km1u4n3pd = AnonymousEnum<{
    /**
     * Enable collateral for certain asset
     * [sender, asset_id]
     */
    "CollateralAssetAdded": Anonymize<Icoe72r8pkf564>;
    /**
     * Disable collateral for certain asset
     * [sender, asset_id]
     */
    "CollateralAssetRemoved": Anonymize<Icoe72r8pkf564>;
    /**
     * Event emitted when assets are deposited
     * [sender, asset_id, amount]
     */
    "Deposited": Anonymize<I82kd33a80644k>;
    /**
     * Event emitted when assets are redeemed
     * [sender, asset_id, amount]
     */
    "Redeemed": Anonymize<I82kd33a80644k>;
    /**
     * Event emitted when cash is borrowed
     * [sender, asset_id, amount]
     */
    "Borrowed": Anonymize<I82kd33a80644k>;
    /**
     * Event emitted when a borrow is repaid
     * [sender, asset_id, amount]
     */
    "RepaidBorrow": Anonymize<I82kd33a80644k>;
    /**
     * Event emitted when a borrow is liquidated
     * [liquidator, borrower, liquidation_asset_id, collateral_asset_id, repay_amount,
     * collateral_amount]
     */
    "LiquidatedBorrow": Anonymize<Ibnls8eh7606j5>;
    /**
     * Event emitted when the reserves are reduced
     * [admin, asset_id, reduced_amount, total_reserves]
     */
    "ReservesReduced": Anonymize<I2jen5a002vjo5>;
    /**
     * Event emitted when the reserves are added
     * [admin, asset_id, added_amount, total_reserves]
     */
    "ReservesAdded": Anonymize<I2jen5a002vjo5>;
    /**
     * New market is set
     * [new_interest_rate_model]
     */
    "NewMarket": Anonymize<I7gtc6jb6l82np>;
    /**
     * Event emitted when a market is activated
     * [admin, asset_id]
     */
    "ActivatedMarket": Anonymize<Iebirugq1dbhv6>;
    /**
     * New market parameters is updated
     * [admin, asset_id]
     */
    "UpdatedMarket": Anonymize<I7gtc6jb6l82np>;
    /**
     * Reward added
     */
    "RewardAdded": Anonymize<I95l2k9b1re95f>;
    /**
     * Reward withdrawed
     */
    "RewardWithdrawn": Anonymize<I95l2k9b1re95f>;
    /**
     * Event emitted when market reward speed updated.
     */
    "MarketRewardSpeedUpdated": Anonymize<Icj4504vnoorlb>;
    /**
     * Deposited when Reward is distributed to a supplier
     */
    "DistributedSupplierReward": Anonymize<Iedc2b32l00pnc>;
    /**
     * Deposited when Reward is distributed to a borrower
     */
    "DistributedBorrowerReward": Anonymize<Iedc2b32l00pnc>;
    /**
     * Reward Paid for user
     */
    "RewardPaid": Anonymize<I95l2k9b1re95f>;
    /**
     * Event emitted when the incentive reserves are redeemed and transfer to receiver's
     * account [receive_account_id, asset_id, reduced_amount]
     */
    "IncentiveReservesReduced": Anonymize<I82kd33a80644k>;
    /**
     * Liquidation free collaterals has been updated
     */
    "LiquidationFreeCollateralsUpdated": Anonymize<I6ae21pstqk9et>;
    "MarketBonded": Anonymize<Ie5efe5gkg0kqs>;
}>;
export type Icoe72r8pkf564 = [SS58String, Anonymize<Iebirugq1dbhv6>];
export type I82kd33a80644k = [SS58String, Anonymize<Iebirugq1dbhv6>, bigint];
export type Ibnls8eh7606j5 = [SS58String, SS58String, Anonymize<Iebirugq1dbhv6>, Anonymize<Iebirugq1dbhv6>, bigint, bigint];
export type I2jen5a002vjo5 = [SS58String, Anonymize<Iebirugq1dbhv6>, bigint, bigint];
export type I7gtc6jb6l82np = [Anonymize<Iebirugq1dbhv6>, Anonymize<I1i2kfunpgo63g>];
export type I1i2kfunpgo63g = {
    "collateral_factor": number;
    "liquidation_threshold": number;
    "reserve_factor": number;
    "close_factor": number;
    "liquidate_incentive": bigint;
    "liquidate_incentive_reserved_factor": number;
    "rate_model": Anonymize<Ibfnd42bovd7un>;
    "state": Enum<{
        "Active": undefined;
        "Pending": undefined;
        "Supervision": undefined;
    }>;
    "supply_cap": bigint;
    "borrow_cap": bigint;
    "lend_token_id": Anonymize<Iebirugq1dbhv6>;
};
export type Ibfnd42bovd7un = AnonymousEnum<{
    "Jump": {
        "base_rate": bigint;
        "jump_rate": bigint;
        "full_rate": bigint;
        "jump_utilization": number;
    };
    "Curve": bigint;
}>;
export type Icj4504vnoorlb = [Anonymize<Iebirugq1dbhv6>, bigint, bigint];
export type Iedc2b32l00pnc = [Anonymize<Iebirugq1dbhv6>, SS58String, bigint, bigint];
export type Ie5efe5gkg0kqs = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "market_bond": Anonymize<I6ae21pstqk9et>;
};
export type Iaja1q8oji7pdd = AnonymousEnum<{
    /**
     * Set emergency price. \[asset_id, price_detail\]
     */
    "SetPrice": Anonymize<Ifrnnpj83g127a>;
    /**
     * Reset emergency price. \[asset_id\]
     */
    "ResetPrice": Anonymize<Iebirugq1dbhv6>;
}>;
export type Iepf7s9r1cn7ph = AnonymousEnum<{
    /**
     * New feed data is submitted.
     */
    "NewFeedData": Anonymize<I1eml7ojrir0mf>;
    "FeedValueReachingLimit": Anonymize<I9ah39ggsni5h8>;
}>;
export type I1eml7ojrir0mf = {
    "sender": SS58String;
    "values": Anonymize<I2dbamvpq4935>;
};
export type I9ah39ggsni5h8 = {
    "value": Anonymize<I9055m3udr8982>;
    "prev": Anonymize<I9055m3udr8982>;
};
export type I9055m3udr8982 = {
    "value": bigint;
    "timestamp": bigint;
};
export type Ibraem55mlft17 = AnonymousEnum<{
    /**
     * The given member was added; see the transaction for who.
     */
    "MemberAdded": undefined;
    /**
     * The given member was removed; see the transaction for who.
     */
    "MemberRemoved": undefined;
    /**
     * Two members were swapped; see the transaction for who.
     */
    "MembersSwapped": undefined;
    /**
     * The membership was reset; see the transaction for who the new set is.
     */
    "MembersReset": undefined;
    /**
     * One of the members' keys changed.
     */
    "KeyChanged": undefined;
    /**
     * Phantom member, never used.
     */
    "Dummy": undefined;
}>;
export type I7t9fm1af55at9 = AnonymousEnum<{
    /**
     * User's leverage rate has been changed.
     */
    "FlashLoanDeposited": Anonymize<I64s470272rog7>;
}>;
export type I64s470272rog7 = {
    /**
     * Account who change the leverage rate.
     */
    "who": SS58String;
    /**
     * The asset id of the token.
     */
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The old leverage rate.
     */
    "old_rate": bigint;
    /**
     * The new leverage rate.
     */
    "new_rate": bigint;
};
export type Idnhi30b9nageu = AnonymousEnum<{
    "ChannelRegistered": Anonymize<Ifq40td50oojcr>;
    "ChannelRemoved": Anonymize<Ib73p6n69t2jsn>;
    "ChannelReceiveAccountUpdated": Anonymize<I4pgd6mkjk426o>;
    "CommissionTokenSet": Anonymize<I98hpr879arfv5>;
    "ChannelCommissionSet": Anonymize<Ievk931u2c7sqn>;
    "CommissionClaimed": Anonymize<I7rjrrm2njpd6g>;
    "ChannelVtokenSharesUpdated": Anonymize<Ielfbmscl7ukmv>;
    "VtokenIssuanceSnapshotUpdated": Anonymize<I673slhfrj1s4r>;
    "PeriodVtokenTotalMintUpdated": Anonymize<Iedejl9np3oh6e>;
    "PeriodVtokenTotalRedeemUpdated": Anonymize<I59j15t8ardoqh>;
    "PeriodChannelVtokenMintUpdated": Anonymize<Id5kb2ocrab7gs>;
    "PeriodTotalCommissionsUpdated": Anonymize<Ie0kb5p5oqesib>;
    "ChannelClaimableCommissionUpdated": Anonymize<I7rjrrm2njpd6g>;
    /**
     * Emitted when a Permill calculation fails.
     * This event carries the numerator and denominator that caused the failure.
     */
    "CalculationFailed": Anonymize<Ic8tdmoaknl87u>;
    /**
     * Bifrost commission transfer failed.
     * Parameters are the commission token and the amount that failed to transfer.
     */
    "BifrostCommissionTransferFailed": Anonymize<I1iscme8538ekh>;
    /**
     * Error event indicating that the removal process of clearing was not completed.
     */
    "RemovalNotCompleteError": Anonymize<Ia9at2kloifkm>;
    /**
     * Error event indicating that the clearing environment setting failed.
     */
    "SetClearingEnvironmentFailed": Anonymize<Ibe6clpska8jpe>;
}>;
export type Ifq40td50oojcr = {
    "channel_id": number;
    "receive_account": SS58String;
    "name": Binary;
};
export type Ib73p6n69t2jsn = {
    "channel_id": number;
};
export type I4pgd6mkjk426o = {
    "channel_id": number;
    "receiver": SS58String;
};
export type I98hpr879arfv5 = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "commission_token"?: Anonymize<I1c99t35ku3g7a>;
};
export type Ievk931u2c7sqn = {
    "channel_id": number;
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "rate": number;
};
export type I7rjrrm2njpd6g = {
    "channel_id": number;
    "commission_token": Anonymize<Iebirugq1dbhv6>;
    "amount": bigint;
};
export type Ielfbmscl7ukmv = {
    "channel_id": number;
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "share": number;
};
export type I673slhfrj1s4r = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "old_issuance": bigint;
    "new_issuance": bigint;
};
export type Iedejl9np3oh6e = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "old_total_mint": bigint;
    "new_total_mint": bigint;
};
export type I59j15t8ardoqh = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "old_total_redeem": bigint;
    "new_total_redeem": bigint;
};
export type Id5kb2ocrab7gs = {
    "channel_id": number;
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "old_mint_amount": bigint;
    "new_mint_amount": bigint;
};
export type Ie0kb5p5oqesib = {
    "commission_token": Anonymize<Iebirugq1dbhv6>;
    "old_amount": bigint;
    "new_amount": bigint;
};
export type Ic8tdmoaknl87u = {
    "numerator": bigint;
    "denominator": bigint;
};
export type I1iscme8538ekh = {
    "from": SS58String;
    "to": SS58String;
    "commission_token": Anonymize<Iebirugq1dbhv6>;
    "amount": bigint;
};
export type Ia9at2kloifkm = {
    "target_num": number;
    "limit": number;
    "executed_num": number;
};
export type Ibe6clpska8jpe = {
    "block_number": number;
};
export type I3tig0oab4mvlr = AnonymousEnum<{
    "CloudsConverted": Anonymize<Ic5ic29aibpkll>;
    "VbncCharged": Anonymize<I6v3aulqfb3eps>;
}>;
export type Ic5ic29aibpkll = {
    "clouds": bigint;
    "vebnc": bigint;
};
export type I6v3aulqfb3eps = {
    "vbnc": bigint;
};
export type I2kcq0r7qlj1i7 = AnonymousEnum<{
    /**
     * A successful call of the `Charge` extrinsic will create this event.
     */
    "Charged": Anonymize<Icglvublte8208>;
    /**
     * A successful call of the `SetVtoken` extrinsic will create this event.
     */
    "ConfigSet": Anonymize<I3o2122ij3mdp9>;
    /**
     * A successful call of the `RemoveVtoken` extrinsic will create this event.
     */
    "Removed": Anonymize<I6dlum3cbrie3d>;
    /**
     * A failed call of the `BuyBack` extrinsic will create this event.
     */
    "BuyBackFailed": Anonymize<Idu9ifj08mb2m9>;
    /**
     * A successful call of the `BuyBack` extrinsic will create this event.
     */
    "BuyBackSuccess": Anonymize<Idu9ifj08mb2m9>;
    /**
     * A failed call of the `AddLiquidity` extrinsic will create this event.
     */
    "AddLiquidityFailed": Anonymize<Idu9ifj08mb2m9>;
    /**
     * A successful call of the `AddLiquidity` extrinsic will create this event.
     */
    "AddLiquiditySuccess": Anonymize<Idu9ifj08mb2m9>;
    /**
     * A failed call of the `SetSwapOutMin` extrinsic will create this event.
     */
    "SetSwapOutMinFailed": Anonymize<Idu9ifj08mb2m9>;
    /**
     * A successful call of the `SetSwapOutMin` extrinsic will create this event.
     */
    "SetSwapOutMinSuccess": Anonymize<Idu9ifj08mb2m9>;
}>;
export type I3o2122ij3mdp9 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "info": Anonymize<Ilqs3opgrh80o>;
};
export type Ilqs3opgrh80o = {
    "min_swap_value": bigint;
    "if_auto": boolean;
    "proportion": number;
    "buyback_duration": number;
    "last_buyback": number;
    "last_buyback_cycle": number;
    "add_liquidity_duration": number;
    "last_add_liquidity": number;
    "destruction_ratio"?: Anonymize<I4arjljr6dpflb>;
    "bias": number;
};
export type Idu9ifj08mb2m9 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "block_number": number;
};
export type I4uk3228gmrfd9 = AnonymousEnum<{
    /**
     * Add a delegator to the staking protocol.
     */
    "AddDelegator": Anonymize<I1rrnio7jcs0u8>;
    /**
     * Remove a delegator from the staking protocol.
     */
    "RemoveDelegator": Anonymize<I1rrnio7jcs0u8>;
    /**
     * Add a validator to the staking protocol.
     */
    "AddValidator": Anonymize<Ieprlpg14vh08o>;
    /**
     * Remove a validator from the staking protocol.
     */
    "RemoveValidator": Anonymize<Ieprlpg14vh08o>;
    /**
     * Set configuration for a specific staking protocol.
     */
    "SetConfiguration": Anonymize<Iok3ke9gllunv>;
    /**
     * Set ledger for a specific delegator.
     */
    "SetLedger": Anonymize<Ifvladst7gf7jp>;
    /**
     * Send xcm task.
     */
    "SendXcmTask": Anonymize<Iat73h6pu514au>;
    /**
     * Xcm task response received.
     */
    "NotifyResponseReceived": Anonymize<I5lh65scrfj49b>;
    /**
     * Time unit updated.
     */
    "TimeUnitUpdated": Anonymize<I6v46ileea69h8>;
    /**
     * Token exchange rate updated.
     */
    "TokenExchangeRateUpdated": Anonymize<I8sdd7udi8ebmk>;
    /**
     * Transfer the staking token to remote chain.
     */
    "TransferTo": Anonymize<Ifldp5atp2n26t>;
    /**
     * Transfer the staking token back from remote chain.
     */
    "TransferBack": Anonymize<I3hd4vted81pma>;
    /**
     * Ethereum staking task.
     */
    "EthereumStaking": Anonymize<I4c9kt1ip8g4lh>;
}>;
export type I1rrnio7jcs0u8 = {
    /**
     * Slp supports staking protocols.
     */
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    /**
     * Delegator index.
     */
    "delegator_index": number;
    /**
     * Delegator account.
     */
    "delegator": Anonymize<Ickhdoqhl8bqbi>;
};
export type Icj6nnp3j96bc6 = AnonymousEnum<{
    "AstarDappStaking": undefined;
    "MoonbeamParachainStaking": undefined;
    "PolkadotStaking": undefined;
    "EthereumStaking": undefined;
}>;
export type Ickhdoqhl8bqbi = AnonymousEnum<{
    "Substrate": SS58String;
    "Ethereum": FixedSizeBinary<20>;
}>;
export type Ieprlpg14vh08o = {
    /**
     * Slp supports staking protocols.
     */
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    /**
     * Delegator account.
     */
    "delegator": Anonymize<Ickhdoqhl8bqbi>;
    /**
     * Validator account.
     */
    "validator": Anonymize<Iforlaqra2bnai>;
};
export type Iforlaqra2bnai = AnonymousEnum<{
    "AstarDappStaking": Anonymize<Iav11gpk2hk471>;
    "MoonbeamParachainStaking": FixedSizeBinary<20>;
    "PolkadotStaking": SS58String;
    "EthereumStaking": FixedSizeBinary<20>;
}>;
export type Iav11gpk2hk471 = AnonymousEnum<{
    "Evm": FixedSizeBinary<20>;
    "Wasm": SS58String;
}>;
export type Iok3ke9gllunv = {
    /**
     * Slp supports staking protocols.
     */
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    /**
     * The staking protocol configuration.
     */
    "configuration": Anonymize<Iamub7qfj1haap>;
};
export type Iamub7qfj1haap = {
    "xcm_task_fee": {
        "weight": Anonymize<I4q39t5hn830vp>;
        "fee": bigint;
    };
    "protocol_fee_rate": number;
    "unlock_period": Anonymize<Id6ihttoi261us>;
    "operator": SS58String;
    "max_update_token_exchange_rate": number;
    "update_time_unit_interval": number;
    "update_exchange_rate_interval": number;
};
export type Ifvladst7gf7jp = {
    /**
     * Slp supports staking protocols.
     */
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    /**
     * Delegator account.
     */
    "delegator": Anonymize<Ickhdoqhl8bqbi>;
    /**
     * Ledger.
     */
    "ledger": Anonymize<I4r7b9kd9ea9vf>;
};
export type I4r7b9kd9ea9vf = AnonymousEnum<{
    "AstarDappStaking": {
        "locked": bigint;
        "unlocking": Array<{
            "amount": bigint;
            "unlock_time": Anonymize<Id6ihttoi261us>;
        }>;
    };
    "EthereumStaking": bigint;
}>;
export type Iat73h6pu514au = {
    /**
     * Xcm Message Query id.
     */
    "query_id"?: Anonymize<I35p85j063s0il>;
    /**
     * Delegator account.
     */
    "delegator": Anonymize<Ickhdoqhl8bqbi>;
    /**
     * Xcm task.
     */
    "task": Enum<{
        "AstarDappStaking": Anonymize<I5iigfm374t7es>;
    }>;
    /**
     * Pending confirmation status.
     */
    "pending_status"?: (Anonymize<I9p3c3ohdngoau>) | undefined;
    /**
     * Destination.
     */
    "dest_location": Anonymize<If9iqq7i64mur8>;
};
export type I5iigfm374t7es = AnonymousEnum<{
    "Lock": bigint;
    "Unlock": bigint;
    "ClaimUnlocked": undefined;
    "RelockUnlocking": undefined;
    "Stake": [Anonymize<Iav11gpk2hk471>, bigint];
    "Unstake": [Anonymize<Iav11gpk2hk471>, bigint];
    "ClaimStakerRewards": undefined;
    "ClaimBonusReward": Anonymize<Iav11gpk2hk471>;
}>;
export type I9p3c3ohdngoau = AnonymousEnum<{
    "AstarDappStaking": Enum<{
        "Lock": [Anonymize<Ickhdoqhl8bqbi>, bigint];
        "UnLock": [Anonymize<Ickhdoqhl8bqbi>, bigint];
        "ClaimUnlocked": Anonymize<Ickhdoqhl8bqbi>;
    }>;
}>;
export type I5lh65scrfj49b = {
    /**
     * Xcm responder.
     */
    "responder": Anonymize<If9iqq7i64mur8>;
    /**
     * Pending confirmation status.
     */
    "pending_status": Anonymize<I9p3c3ohdngoau>;
};
export type I6v46ileea69h8 = {
    /**
     * Slp supports staking protocols.
     */
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    /**
     * Time unit.
     */
    "time_unit": Anonymize<Id6ihttoi261us>;
};
export type I8sdd7udi8ebmk = {
    /**
     * Slp supports staking protocols.
     */
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    /**
     * Delegator account.
     */
    "delegator": Anonymize<Ickhdoqhl8bqbi>;
    /**
     * The type of token that the fee is charged to
     */
    "protocol_fee_currency_id": Anonymize<Iebirugq1dbhv6>;
    /**
     * The amount of the fee charged to the protocol
     */
    "protocol_fee": bigint;
    /**
     * Amount of pool value updated
     */
    "pool_value": bigint;
    /**
     * Amount of delegator value updated
     */
    "delegator_value": bigint;
};
export type Ifldp5atp2n26t = {
    /**
     * Slp supports staking protocols.
     */
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    /**
     * Bifrost Account
     */
    "from": SS58String;
    /**
     * Delegator account.
     */
    "to": Anonymize<Ickhdoqhl8bqbi>;
    /**
     * Amount
     */
    "amount": bigint;
};
export type I3hd4vted81pma = {
    /**
     * Slp supports staking protocols.
     */
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    /**
     * Delegator account.
     */
    "from": Anonymize<Ickhdoqhl8bqbi>;
    /**
     * Bifrost Account.
     */
    "to": SS58String;
    /**
     * Amount
     */
    "amount": bigint;
};
export type I4c9kt1ip8g4lh = {
    "delegator": Anonymize<Ickhdoqhl8bqbi>;
    "task": Enum<{
        "Stake": bigint;
        "Unstake": bigint;
    }>;
};
export type Iapg7gbu5966ul = Array<{
    "id": Enum<{
        "PolkadotXcm": Anonymize<Ideiof6273rsoe>;
        "Preimage": PreimagePalletHoldReason;
    }>;
    "amount": bigint;
}>;
export type Ifvgo9568rpmqc = Array<Anonymize<I8uo3fpd3bcc6f>>;
export type I9sa8q0f4qa941 = {
    "account": SS58String;
    "percent": number;
    "payment_in_round": bigint;
};
export type I5ucuicjqgd7dh = {
    "id": SS58String;
    "delegations": Anonymize<Ifc31u3dkrqbco>;
    "total": bigint;
    "less_total": bigint;
    "status": Anonymize<I91jcpjd7q6d1i>;
};
export type Ifc31u3dkrqbco = Array<{
    "owner": SS58String;
    "amount": bigint;
}>;
export type I69mra87kqkj6d = Array<{
    "delegator": SS58String;
    "when_executable": number;
    "action": Anonymize<Ibtq25m1pbdmfs>;
}>;
export type Ififtooll71avi = {
    "delegations": Anonymize<Ifc31u3dkrqbco>;
    "total": bigint;
};
export type Ifo10l87an05tl = {
    "bond": bigint;
    "delegations": Anonymize<Ifc31u3dkrqbco>;
    "total": bigint;
};
export type Ias3agfr1nmpr3 = AnonymousEnum<{
    "Ongoing": {
        "track": number;
        "origin": Anonymize<Ifohkba1aph7uu>;
        "proposal": PreimagesBounded;
        "enactment": TraitsScheduleDispatchTime;
        "submitted": number;
        "submission_deposit": Anonymize<Id5fm4p8lj5qgi>;
        "decision_deposit"?: Anonymize<Ibd24caul84kv2>;
        "deciding"?: Anonymize<Ibcbcndfmk0jd9>;
        "tally": Anonymize<Ifsk7cbmtit1jd>;
        "in_queue": boolean;
        "alarm"?: Anonymize<I3aj03qk2o5mdm>;
    };
    "Approved": Anonymize<Ini94eljn5lj8>;
    "Rejected": Anonymize<Ini94eljn5lj8>;
    "Cancelled": Anonymize<Ini94eljn5lj8>;
    "TimedOut": Anonymize<Ini94eljn5lj8>;
    "Killed": number;
}>;
export type Ifohkba1aph7uu = AnonymousEnum<{
    "system": DispatchRawOrigin;
    "Origins": Enum<{
        "WhitelistedCaller": undefined;
        "FellowshipAdmin": undefined;
        "ReferendumCanceller": undefined;
        "ReferendumKiller": undefined;
        "LiquidStaking": undefined;
        "SALPAdmin": undefined;
        "FellowshipInitiates": undefined;
        "Fellows": undefined;
        "FellowshipExperts": undefined;
        "FellowshipMasters": undefined;
        "Fellowship1Dan": undefined;
        "Fellowship2Dan": undefined;
        "Fellowship3Dan": undefined;
        "Fellowship4Dan": undefined;
        "Fellowship5Dan": undefined;
        "Fellowship6Dan": undefined;
        "Fellowship7Dan": undefined;
        "Fellowship8Dan": undefined;
        "Fellowship9Dan": undefined;
        "TechAdmin": undefined;
        "CoreAdmin": undefined;
        "TreasurySpend": undefined;
        "DelegatedVotingAdmin": undefined;
    }>;
    "PolkadotXcm": Anonymize<Icvilmd7qu30i4>;
    "CumulusXcm": Anonymize<I3in0d0lb61qi8>;
    "Ethereum": Anonymize<I9hp9au9bfqil7>;
}>;
export type I76ljmosd7jlii = Array<({
    "maybe_id"?: Anonymize<I4s6vifaf8k998>;
    "priority": number;
    "call": PreimagesBounded;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "origin": Anonymize<Ifohkba1aph7uu>;
}) | undefined>;
export type Icfvb3a12856o5 = [Array<{
    "delegate": SS58String;
    "proxy_type": Anonymize<Iebopc45bqaiad>;
    "delay": number;
}>, bigint];
export type I910puuahutflf = [SS58String, IdentityData];
export type I4nfjdef0ibh44 = [bigint, Anonymize<Ia2lhg7l2hilo3>];
export type I74af64m08r6as = Array<({
    "account": SS58String;
    "fee": bigint;
    "fields": bigint;
}) | undefined>;
export type Ic8ann3kre6vdm = {
    "account_id": SS58String;
    "allocation": number;
};
export type I1j72qfgdejqsv = {
    "owner": SS58String;
    "provider": Anonymize<Idib8jf3ve40bj>;
};
export type I60biiepd74113 = [SS58String, number, Anonymize<Idib8jf3ve40bj>];
export type Ie9j1itogtv7p5 = {
    "amount": bigint;
    "beneficiary": SS58String;
    "valid_from": number;
    "expire_at": number;
    "status": Anonymize<Ier5jvvb5iqu1g>;
};
export type Ic3l568el19b24 = [Anonymize<Ibjuap2vk03rp6>, Anonymize<Ifoernv5r40rfc>, Anonymize<Ideko6oeomboa6>];
export type Ibjuap2vk03rp6 = AnonymousEnum<{
    "Legacy": Anonymize<I22u79j4u5as1p>;
    "EIP2930": {
        "chain_id": bigint;
        "nonce": Anonymize<I4totqt881mlti>;
        "gas_price": Anonymize<I4totqt881mlti>;
        "gas_limit": Anonymize<I4totqt881mlti>;
        "action": Anonymize<I2do93a3gr3ege>;
        "value": Anonymize<I4totqt881mlti>;
        "input": Binary;
        "access_list": Anonymize<Ieap15h2pjii9u>;
        "signature": Anonymize<I9veufneid0sta>;
    };
    "EIP1559": {
        "chain_id": bigint;
        "nonce": Anonymize<I4totqt881mlti>;
        "max_priority_fee_per_gas": Anonymize<I4totqt881mlti>;
        "max_fee_per_gas": Anonymize<I4totqt881mlti>;
        "gas_limit": Anonymize<I4totqt881mlti>;
        "action": Anonymize<I2do93a3gr3ege>;
        "value": Anonymize<I4totqt881mlti>;
        "input": Binary;
        "access_list": Anonymize<Ieap15h2pjii9u>;
        "signature": Anonymize<I9veufneid0sta>;
    };
    "EIP7702": {
        "chain_id": bigint;
        "nonce": Anonymize<I4totqt881mlti>;
        "max_priority_fee_per_gas": Anonymize<I4totqt881mlti>;
        "max_fee_per_gas": Anonymize<I4totqt881mlti>;
        "gas_limit": Anonymize<I4totqt881mlti>;
        "destination": Anonymize<I2do93a3gr3ege>;
        "value": Anonymize<I4totqt881mlti>;
        "data": Binary;
        "access_list": Anonymize<Ieap15h2pjii9u>;
        "authorization_list": Anonymize<Idg0qi60379vnh>;
        "signature": Anonymize<I9veufneid0sta>;
    };
}>;
export type I9veufneid0sta = {
    "odd_y_parity": boolean;
    "r": FixedSizeBinary<32>;
    "s": FixedSizeBinary<32>;
};
export type Idg0qi60379vnh = Array<{
    "chain_id": bigint;
    "address": FixedSizeBinary<20>;
    "nonce": Anonymize<I4totqt881mlti>;
    "signature": Anonymize<I9veufneid0sta>;
}>;
export type Ideko6oeomboa6 = AnonymousEnum<{
    "Legacy": Anonymize<I16nm875k0bak5>;
    "EIP2930": Anonymize<I16nm875k0bak5>;
    "EIP1559": Anonymize<I16nm875k0bak5>;
    "EIP7702": Anonymize<I16nm875k0bak5>;
}>;
export type Ib0hfhkohlekcj = {
    "header": Anonymize<I4v962mnhj6j6r>;
    "transactions": Anonymize<Ie30stbbeaul1o>;
    "ommers": Anonymize<I78ffku0ve5fgm>;
};
export type Ie30stbbeaul1o = Array<Anonymize<Ibjuap2vk03rp6>>;
export type I32lgu058i52q9 = Array<Anonymize<Ideko6oeomboa6>>;
export type Ic02kut0350gb0 = {
    "free": bigint;
    "reserved": bigint;
    "frozen": bigint;
};
export type If21n82i0516em = FixedSizeArray<2, Anonymize<If9iqq7i64mur8>>;
export type I3ebs7dujjiusf = [Anonymize<If9iqq7i64mur8>, Binary];
export type Iettgnma0t3a0g = [Anonymize<Icu3qllmbdnj89>, SS58String];
export type I3t5icadd1rvs1 = [Anonymize<Ihfphjolmsqq1>, number];
export type I76qpl5pst2d4o = (Anonymize<Icu3qllmbdnj89>) | undefined;
export type Ik66om7cc050c = AnonymousEnum<{
    "Trading": {
        "pair_account": SS58String;
        "total_supply": bigint;
    };
    "Bootstrap": {
        "target_supply": Anonymize<I200n1ov5tbcvr>;
        "capacity_supply": Anonymize<I200n1ov5tbcvr>;
        "accumulated_supply": Anonymize<I200n1ov5tbcvr>;
        "end_block_number": number;
        "pair_account": SS58String;
    };
    "Disable": undefined;
}>;
export type Iaa4kemhg4eh7v = [Anonymize<I84fmreorpmm3e>, SS58String];
export type Idqnu98dduluv8 = {
    "timestamp": bigint;
    "overlay_root"?: Anonymize<I4s6vifaf8k998>;
    "state_root": FixedSizeBinary<32>;
};
export type Icsknfl0f6r973 = [number, SS58String, bigint];
export type I2j3o5sgk562ak = ({
    "raised": bigint;
    "cap": bigint;
    "first_slot": number;
    "last_slot": number;
    "trie_index": number;
    "status": Anonymize<I3dj8kkj3l70n5>;
}) | undefined;
export type I3dj8kkj3l70n5 = AnonymousEnum<{
    "Ongoing": undefined;
    "Retired": undefined;
    "Success": undefined;
    "Failed": undefined;
    "RefundWithdrew": undefined;
    "RedeemWithdrew": undefined;
    "FailedToContinue": undefined;
    "End": undefined;
}>;
export type I2q82ekqn8jp9r = {
    "value": bigint;
    "if_mint": boolean;
};
export type Id4hmbnsqek288 = [SS58String, bigint, Anonymize<Id6ihttoi261us>, Enum<{
    "Native": undefined;
    "Astar": SS58String;
    "Moonbeam": FixedSizeBinary<20>;
    "Hydradx": SS58String;
    "Interlay": SS58String;
    "Manta": SS58String;
    "HyperBridge": Anonymize<Ia46odf30322a1>;
}>];
export type I3thiua0nporjs = [Anonymize<Iebirugq1dbhv6>, number];
export type I9v3gj6frc0u13 = [bigint, Anonymize<Icgljjb6j82uhn>];
export type Iapmb49b0eddb4 = [bigint, Anonymize<Icgljjb6j82uhn>, Anonymize<Iebirugq1dbhv6>];
export type I8d057oj36rajf = [Anonymize<Id6ihttoi261us>, Anonymize<Iebirugq1dbhv6>];
export type I2eq26k0hguoqq = [bigint, Anonymize<Ifip05kcrl65am>];
export type I6ge61lbhbulha = [Anonymize<Iebirugq1dbhv6>, Anonymize<I4c0s5cioidn76>];
export type I34jhssnacefoe = [Anonymize<I14u04kl21424d>, number];
export type I9egg64gafs7r7 = [Anonymize<Ib9sn2bmfqddi7>, number];
export type I69hlrlj6ggqgm = [Anonymize<Id6ihttoi261us>, number];
export type I7t012gg35hgm4 = Array<[Anonymize<I4c0s5cioidn76>, FixedSizeBinary<32>]>;
export type I1js2aelrc7fbg = [Anonymize<I4q39t5hn830vp>, bigint];
export type Ib8nbo9p8dn6s1 = [Anonymize<Iebirugq1dbhv6>, Anonymize<I8vi5hrpkv8lci>];
export type I4kcv5272ambf0 = {
    "tokens_proportion": Anonymize<I7p4is2lmk8vmo>;
    "basic_token": Anonymize<I3thiua0nporjs>;
    "total_shares": bigint;
    "basic_rewards": Anonymize<I2dbamvpq4935>;
    "rewards": Anonymize<Idtci0ovsdvku6>;
    "state": Enum<{
        "UnCharged": undefined;
        "Charged": undefined;
        "Ongoing": undefined;
        "Dead": undefined;
        "Retired": undefined;
    }>;
    "keeper": SS58String;
    "reward_issuer": SS58String;
    "gauge"?: Anonymize<I4arjljr6dpflb>;
    "block_startup"?: Anonymize<I4arjljr6dpflb>;
    "min_deposit_to_start": bigint;
    "after_block_to_start": number;
    "withdraw_limit_time": number;
    "claim_limit_time": number;
    "withdraw_limit_count": number;
};
export type I7p4is2lmk8vmo = Array<Anonymize<I3thiua0nporjs>>;
export type I970q50juj0l2 = {
    "pid": number;
    "token": Anonymize<Iebirugq1dbhv6>;
    "keeper": SS58String;
    "reward_issuer": SS58String;
    "rewards": Array<[Anonymize<Iebirugq1dbhv6>, FixedSizeArray<3, bigint>]>;
    "gauge_basic_rewards": Anonymize<I2dbamvpq4935>;
    "max_block": number;
    "gauge_amount": bigint;
    "total_time_factor": bigint;
    "gauge_state": Enum<{
        "Unbond": undefined;
        "Bonded": undefined;
    }>;
    "gauge_last_block": number;
};
export type Ifpaals567gacp = {
    "who": SS58String;
    "gauge_amount": bigint;
    "total_time_factor": bigint;
    "latest_time_factor": bigint;
    "claimed_time_factor": bigint;
    "gauge_start_block": number;
    "gauge_stop_block": number;
    "gauge_last_block": number;
    "last_claim_block": number;
};
export type Ilivuv1vkc02s = {
    "who": SS58String;
    "share": bigint;
    "withdrawn_rewards": Anonymize<I2dbamvpq4935>;
    "claim_last_block": number;
    "withdraw_list": Anonymize<If9jidduiuq7vv>;
};
export type Ianombrc3en111 = {
    "total_votes": bigint;
    "start_round": number;
    "end_round": number;
    "round_length": number;
};
export type I1755v7kcv6nfl = {
    "vote_amount": bigint;
    "vote_list": Anonymize<Iep4uo61810hfs>;
    "last_vote": number;
};
export type I26t6htp1ghfm3 = [number, Anonymize<Iebirugq1dbhv6>];
export type Iam3cim0m4gpdq = {
    "system_stakable_amount": bigint;
    "system_shadow_amount": bigint;
    "pending_redeem_amount": bigint;
    "current_config": {
        "exec_delay": number;
        "system_stakable_base": bigint;
    };
    "new_config": {
        "exec_delay": number;
        "system_stakable_base": bigint;
    };
};
export type Ifptjqqj04qat7 = [Anonymize<Iebirugq1dbhv6>, SS58String];
export type I93ot7g316idsl = {
    "amount": bigint;
    "end": number;
};
export type I393gnb7kgq98v = {
    "bias": bigint;
    "slope": bigint;
    "block": number;
    "amount": bigint;
};
export type Ifvilitm1tdmqi = [bigint, Anonymize<I4totqt881mlti>];
export type Iarr20ag9rpg5c = {
    "old_markup_coefficient": bigint;
    "markup_coefficient": bigint;
};
export type I5o39ti65l0u4e = {
    "amount": bigint;
    "markup_coefficient": bigint;
    "refresh_block": number;
};
export type Ibrbnb4fv7rbdd = {
    "markup_coefficient": bigint;
    "hardcap": bigint;
    "update_block": number;
    "rwi": bigint;
};
export type Imng78fk88871 = {
    "xcm_fee": bigint;
    "xcm_weight": Anonymize<I4q39t5hn830vp>;
    "period": number;
    "last_block": number;
    "contract": FixedSizeBinary<20>;
};
export type Iec27c137mjssc = Array<Anonymize<I3rsia7pa3ke9b>>;
export type Ifbdrgce969o4a = {
    "to": FixedSizeBinary<20>;
    "timeout": bigint;
    "period": number;
    "last_block": number;
    "tokens": Anonymize<Ifbg8drm29v6va>;
    "payer": SS58String;
    "fee": bigint;
};
export type I2dtppeq1iec09 = {
    "period": number;
    "last_block": number;
    "weight": Anonymize<I4q39t5hn830vp>;
    "fee": bigint;
    "tokens": Anonymize<Ic4m824gh8aavk>;
};
export type Icoeje77srd9e5 = AnonymousEnum<{
    "Ongoing": {
        "track": number;
        "origin": Anonymize<Ifohkba1aph7uu>;
        "proposal": PreimagesBounded;
        "enactment": TraitsScheduleDispatchTime;
        "submitted": number;
        "submission_deposit": Anonymize<Id5fm4p8lj5qgi>;
        "decision_deposit"?: Anonymize<Ibd24caul84kv2>;
        "deciding"?: Anonymize<Ibcbcndfmk0jd9>;
        "tally": Anonymize<I6d634btv7misu>;
        "in_queue": boolean;
        "alarm"?: Anonymize<I3aj03qk2o5mdm>;
    };
    "Approved": Anonymize<Ini94eljn5lj8>;
    "Rejected": Anonymize<Ini94eljn5lj8>;
    "Cancelled": Anonymize<Ini94eljn5lj8>;
    "TimedOut": Anonymize<Ini94eljn5lj8>;
    "Killed": number;
}>;
export type Ibe2akds4krf80 = {
    "pool_id": number;
    "pool_asset": Anonymize<Iebirugq1dbhv6>;
    "assets": Anonymize<I6ae21pstqk9et>;
    "precisions": Anonymize<Iafqnechp3omqg>;
    "mint_fee": bigint;
    "swap_fee": bigint;
    "redeem_fee": bigint;
    "total_supply": bigint;
    "a": bigint;
    "a_block": number;
    "future_a": bigint;
    "future_a_block": number;
    "balances": Anonymize<Iafqnechp3omqg>;
    "fee_recipient": SS58String;
    "account_id": SS58String;
    "yield_recipient": SS58String;
    "precision": bigint;
};
export type I2uhe6v3aqlo79 = AnonymousEnum<{
    "Casting": {
        "votes": Array<[number, ConvictionVotingVoteAccountVote, number, bigint]>;
        "delegations": Anonymize<I538qha8r4j3ii>;
        "prior": Anonymize<I4ojmnsk1dchql>;
    };
    "Delegating": Anonymize<I251o9sbu5566f>;
}>;
export type If5lnhvjis90k = [Anonymize<Iebirugq1dbhv6>, number, number, SS58String, ([ConvictionVotingVoteAccountVote, bigint]) | undefined];
export type I22oifipsnuvk4 = [Anonymize<Iebirugq1dbhv6>, number, number];
export type I3udg9qslb775f = [SS58String, Anonymize<Iebirugq1dbhv6>, number];
export type Iavngg6vh7nl2j = {
    "principal": bigint;
    "borrow_index": bigint;
};
export type Iao359lc45ru9s = {
    "voucher_balance": bigint;
    "is_collateral": boolean;
};
export type I1ifiaqhtj7c9 = {
    "total_earned_prior": bigint;
    "exchange_rate_prior": bigint;
};
export type I6km05m2f6usv7 = {
    "index": bigint;
    "block": number;
};
export type I92tce08cbhnmn = [SS58String, Binary];
export type I8dlobfoa2kkke = [Anonymize<Icj6nnp3j96bc6>, number];
export type I1hif5qruqj4v = [Anonymize<Icj6nnp3j96bc6>, Anonymize<Ickhdoqhl8bqbi>];
export type Ie3rr1ggdh7418 = Array<Anonymize<Iforlaqra2bnai>>;
export type Ibjoagskivshoc = AnonymousEnum<{
    /**
     * Assign an previously unassigned index.
     *
     * Payment: `Deposit` is reserved from the sender account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `index`: the index to be claimed. This must not be in use.
     *
     * Emits `IndexAssigned` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "claim": Anonymize<I666bl2fqjkejo>;
    /**
     * Assign an index already owned by the sender to another account. The balance reservation
     * is effectively transferred to the new account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `index`: the index to be re-assigned. This must be owned by the sender.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     *
     * Emits `IndexAssigned` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "transfer": Anonymize<I1u3ac7lafvv5b>;
    /**
     * Free up an index owned by the sender.
     *
     * Payment: Any previous deposit placed for the index is unreserved in the sender account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must own the index.
     *
     * - `index`: the index to be freed. This must be owned by the sender.
     *
     * Emits `IndexFreed` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "free": Anonymize<I666bl2fqjkejo>;
    /**
     * Force an index to an account. This doesn't require a deposit. If the index is already
     * held, then any deposit is reimbursed to its current owner.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `index`: the index to be (re-)assigned.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
     *
     * Emits `IndexAssigned` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "force_transfer": Anonymize<I5teebeg0opib2>;
    /**
     * Freeze an index so it will always point to the sender account. This consumes the
     * deposit.
     *
     * The dispatch origin for this call must be _Signed_ and the signing account must have a
     * non-frozen account `index`.
     *
     * - `index`: the index to be frozen in place.
     *
     * Emits `IndexFrozen` if successful.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "freeze": Anonymize<I666bl2fqjkejo>;
    /**
     * Poke the deposit reserved for an index.
     *
     * The dispatch origin for this call must be _Signed_ and the signing account must have a
     * non-frozen account `index`.
     *
     * The transaction fees is waived if the deposit is changed after poking/reconsideration.
     *
     * - `index`: the index whose deposit is to be poked/reconsidered.
     *
     * Emits `DepositPoked` if successful.
     */
    "poke_deposit": Anonymize<I666bl2fqjkejo>;
}>;
export type I1u3ac7lafvv5b = {
    "new": Anonymize<I4su1fqci7afjt>;
    "index": number;
};
export type I4su1fqci7afjt = AnonymousEnum<{
    "Id": SS58String;
    "Index": number;
    "Raw": Binary;
    "Address32": FixedSizeBinary<32>;
    "Address20": FixedSizeBinary<20>;
}>;
export type I5teebeg0opib2 = {
    "new": Anonymize<I4su1fqci7afjt>;
    "index": number;
    "freeze": boolean;
};
export type Ieci88jft3cpv9 = AnonymousEnum<{
    /**
     * Pause a call.
     *
     * Can only be called by [`Config::PauseOrigin`].
     * Emits an [`Event::CallPaused`] event on success.
     */
    "pause": Anonymize<Iba7pefg0d11kh>;
    /**
     * Un-pause a call.
     *
     * Can only be called by [`Config::UnpauseOrigin`].
     * Emits an [`Event::CallUnpaused`] event on success.
     */
    "unpause": Anonymize<I2pjehun5ehh5i>;
}>;
export type I2pjehun5ehh5i = {
    "ident": Anonymize<Idkbvh6dahk1v7>;
};
export type I9fktnrlinnre4 = AnonymousEnum<{
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     */
    "transfer_allow_death": Anonymize<I65i612een2ak>;
    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     */
    "force_transfer": Anonymize<I5vvf47ira6s09>;
    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     */
    "transfer_keep_alive": Anonymize<I65i612een2ak>;
    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     */
    "transfer_all": Anonymize<I5ns79ftlq8cnl>;
    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     */
    "force_unreserve": Anonymize<I59ofijoau4bjh>;
    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     */
    "upgrade_accounts": Anonymize<Ibmr18suc9ikh9>;
    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     */
    "force_set_balance": Anonymize<Ieka2e164ntfss>;
    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     */
    "force_adjust_total_issuance": Anonymize<I5u8olqbbvfnvf>;
    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     */
    "burn": Anonymize<I5utcetro501ir>;
}>;
export type I65i612een2ak = {
    "dest": Anonymize<I4su1fqci7afjt>;
    "value": bigint;
};
export type I5vvf47ira6s09 = {
    "source": Anonymize<I4su1fqci7afjt>;
    "dest": Anonymize<I4su1fqci7afjt>;
    "value": bigint;
};
export type I5ns79ftlq8cnl = {
    "dest": Anonymize<I4su1fqci7afjt>;
    "keep_alive": boolean;
};
export type I59ofijoau4bjh = {
    "who": Anonymize<I4su1fqci7afjt>;
    "amount": bigint;
};
export type Ieka2e164ntfss = {
    "who": Anonymize<I4su1fqci7afjt>;
    "new_free": bigint;
};
export type I77dda7hps0u37 = AnonymousEnum<{
    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be signed.
     *
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     * fixed.
     */
    "set_keys": Anonymize<I81vt5eq60l4b6>;
    /**
     * Removes any session key(s) of the function caller.
     *
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     *
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     * `T::Keys::key_ids()` which is fixed.
     */
    "purge_keys": undefined;
}>;
export type I81vt5eq60l4b6 = {
    "keys": FixedSizeBinary<32>;
    "proof": Binary;
};
export type Ievfetjbuchs5m = AnonymousEnum<{
    /**
     * Set the expectations for total staked. These expectations determine the issuance for
     * the round according to logic in `fn compute_issuance`
     */
    "set_staking_expectations": Anonymize<I6m4od67mjs4l8>;
    /**
     * Set the annual inflation rate to derive per-round inflation
     */
    "set_inflation": Anonymize<I19e29tp35ff1j>;
    /**
     * Set the account that will hold funds set aside for parachain bond
     */
    "set_parachain_bond_account": Anonymize<Idhlknhp7vndhp>;
    /**
     * Set the percent of inflation set aside for parachain bond
     */
    "set_parachain_bond_reserve_percent": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the total number of collator candidates selected per round
     * - changes are not applied until the start of the next round
     */
    "set_total_selected": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set the commission for all collators
     */
    "set_collator_commission": Anonymize<I3vh014cqgmrfd>;
    /**
     * Set blocks per round
     * - if called with `new` less than length of current round, will transition immediately
     * in the next block
     * - also updates per-round inflation config
     */
    "set_blocks_per_round": Anonymize<I3vh014cqgmrfd>;
    /**
     * Join the set of collator candidates
     */
    "join_candidates": Anonymize<I4vasl07tasls>;
    /**
     * Request to leave the set of candidates. If successful, the account is immediately
     * removed from the candidate pool to prevent selection as a collator.
     */
    "schedule_leave_candidates": Anonymize<I98vh5ccjtf1ev>;
    /**
     * Execute leave candidates request
     */
    "execute_leave_candidates": Anonymize<I6imgsrdabjjdm>;
    /**
     * Cancel open request to leave candidates
     * - only callable by collator account
     * - result upon successful call is the candidate is active in the candidate pool
     */
    "cancel_leave_candidates": Anonymize<I98vh5ccjtf1ev>;
    /**
     * Temporarily leave the set of collator candidates without unbonding
     */
    "go_offline": undefined;
    /**
     * Rejoin the set of collator candidates if previously had called `go_offline`
     */
    "go_online": undefined;
    /**
     * Increase collator candidate self bond by `more`
     */
    "candidate_bond_more": Anonymize<Ievnk06j48hi6e>;
    /**
     * Request by collator candidate to decrease self bond by `less`
     */
    "schedule_candidate_bond_less": Anonymize<Ibrbas2gu3j75d>;
    /**
     * Execute pending request to adjust the collator candidate self bond
     */
    "execute_candidate_bond_less": Anonymize<I4b66js88p45m8>;
    /**
     * Cancel pending request to adjust the collator candidate self bond
     */
    "cancel_candidate_bond_less": undefined;
    /**
     * If caller is not a delegator and not a collator, then join the set of delegators
     * If caller is a delegator, then makes delegation to change their delegation state
     */
    "delegate": Anonymize<If353osofrqjga>;
    /**
     * DEPRECATED use batch util with schedule_revoke_delegation for all delegations
     * Request to leave the set of delegators. If successful, the caller is scheduled to be
     * allowed to exit via a [DelegationAction::Revoke] towards all existing delegations.
     * Success forbids future delegation requests until the request is invoked or cancelled.
     */
    "schedule_leave_delegators": undefined;
    /**
     * DEPRECATED use batch util with execute_delegation_request for all delegations
     * Execute the right to exit the set of delegators and revoke all ongoing delegations.
     */
    "execute_leave_delegators": Anonymize<Id7ht3qmm0pmas>;
    /**
     * DEPRECATED use batch util with cancel_delegation_request for all delegations
     * Cancel a pending request to exit the set of delegators. Success clears the pending exit
     * request (thereby resetting the delay upon another `leave_delegators` call).
     */
    "cancel_leave_delegators": undefined;
    /**
     * Request to revoke an existing delegation. If successful, the delegation is scheduled
     * to be allowed to be revoked via the `execute_delegation_request` extrinsic.
     */
    "schedule_revoke_delegation": Anonymize<Ieinuidojqh902>;
    /**
     * Bond more for delegators wrt a specific collator candidate.
     */
    "delegator_bond_more": Anonymize<I6ec8i49vphpbo>;
    /**
     * Request bond less for delegators wrt a specific collator candidate.
     */
    "schedule_delegator_bond_less": Anonymize<I78tmt4lg2noo1>;
    /**
     * Execute pending request to change an existing delegation
     */
    "execute_delegation_request": Anonymize<Ifj50lknlp6i9t>;
    /**
     * Cancel request to change an existing delegation.
     */
    "cancel_delegation_request": Anonymize<I4b66js88p45m8>;
    /**
     * Hotfix to remove existing empty entries for candidates that have left.
     */
    "hotfix_remove_delegation_requests_exited_candidates": Anonymize<Icolvgjhpn5o0s>;
}>;
export type Idhlknhp7vndhp = {
    "new": SS58String;
};
export type I6imgsrdabjjdm = {
    "candidate": SS58String;
    "candidate_delegation_count": number;
};
export type If353osofrqjga = {
    "candidate": SS58String;
    "amount": bigint;
    "candidate_delegation_count": number;
    "delegation_count": number;
};
export type Id7ht3qmm0pmas = {
    "delegator": SS58String;
    "delegation_count": number;
};
export type Ieinuidojqh902 = {
    "collator": SS58String;
};
export type I6ec8i49vphpbo = {
    "candidate": SS58String;
    "more": bigint;
};
export type I78tmt4lg2noo1 = {
    "candidate": SS58String;
    "less": bigint;
};
export type Ifj50lknlp6i9t = {
    "delegator": SS58String;
    "candidate": SS58String;
};
export type Icolvgjhpn5o0s = {
    "candidates": Anonymize<Ia2lhg7l2hilo3>;
};
export type I99hrhstt9euff = AnonymousEnum<{
    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     *
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     */
    "vote": Anonymize<Idnsr2pndm36h0>;
    /**
     * Delegate the voting power (with some given conviction) of the sending account for a
     * particular class of polls.
     *
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     *
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     * - be delegating already; or
     * - have no voting activity (if there is, then it will need to be removed through
     * `remove_vote`).
     *
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
     * to this function are required.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     * account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     * be more than the account's current balance.
     *
     * Emits `Delegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    "delegate": Anonymize<Iam6m7eerh6h6v>;
    /**
     * Undelegate the voting power of the sending account for a particular class of polls.
     *
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued has passed.
     *
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     *
     * - `class`: The class of polls to remove the delegation from.
     *
     * Emits `Undelegated`.
     *
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     * voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    "undelegate": Anonymize<I8steo882k7qns>;
    /**
     * Remove the lock caused by prior voting/delegating which has expired within a particular
     * class.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     *
     * Weight: `O(R)` with R number of vote of target.
     */
    "unlock": Anonymize<Ic8m623qbgr5mp>;
    /**
     * Remove a vote for a poll.
     *
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     * - the vote of the account was in opposition to the result; or
     * - there was no conviction to the account's vote; or
     * - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     *
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     *
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     *
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     * which have finished or are cancelled, this must be `Some`.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     */
    "remove_vote": Anonymize<I5f178ab6b89t3>;
    /**
     * Remove a vote for a poll.
     *
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     * `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     *
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     */
    "remove_other_vote": Anonymize<Ieg7p9mojce0qk>;
}>;
export type Iam6m7eerh6h6v = {
    "class": number;
    "to": Anonymize<I4su1fqci7afjt>;
    "conviction": VotingConviction;
    "balance": bigint;
};
export type Ic8m623qbgr5mp = {
    "class": number;
    "target": Anonymize<I4su1fqci7afjt>;
};
export type Ieg7p9mojce0qk = {
    "target": Anonymize<I4su1fqci7afjt>;
    "class": number;
    "index": number;
};
export type Iem8t94ck8brd9 = AnonymousEnum<{
    /**
     * Propose a referendum on a privileged action.
     *
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     * available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     *
     * Emits `Submitted`.
     */
    "submit": Anonymize<Ib9pt0t7gno7q4>;
    /**
     * Post the Decision Deposit for a referendum.
     *
     * - `origin`: must be `Signed` and the account must have funds available for the
     * referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     * posted.
     *
     * Emits `DecisionDepositPlaced`.
     */
    "place_decision_deposit": Anonymize<I666bl2fqjkejo>;
    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     * refunded.
     *
     * Emits `DecisionDepositRefunded`.
     */
    "refund_decision_deposit": Anonymize<I666bl2fqjkejo>;
    /**
     * Cancel an ongoing referendum.
     *
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Cancelled`.
     */
    "cancel": Anonymize<I666bl2fqjkejo>;
    /**
     * Cancel an ongoing referendum and slash the deposits.
     *
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Killed` and `DepositSlashed`.
     */
    "kill": Anonymize<I666bl2fqjkejo>;
    /**
     * Advance a referendum onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     */
    "nudge_referendum": Anonymize<I666bl2fqjkejo>;
    /**
     * Advance a track onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     *
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     */
    "one_fewer_deciding": Anonymize<Icbio0e1f0034b>;
    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     * refunded.
     *
     * Emits `SubmissionDepositRefunded`.
     */
    "refund_submission_deposit": Anonymize<I666bl2fqjkejo>;
    /**
     * Set or clear metadata of a referendum.
     *
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     * metadata of a finished referendum.
     * - `index`:  The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     */
    "set_metadata": Anonymize<I8c0vkqjjipnuj>;
}>;
export type Ib9pt0t7gno7q4 = {
    "proposal_origin": Anonymize<Ifohkba1aph7uu>;
    "proposal": PreimagesBounded;
    "enactment_moment": TraitsScheduleDispatchTime;
};
export type I33skh82kfvj1c = AnonymousEnum<{
    "whitelist_call": Anonymize<I1adbcfi5uc62r>;
    "remove_whitelisted_call": Anonymize<I1adbcfi5uc62r>;
    "dispatch_whitelisted_call": Anonymize<Ibf6ucefn8fh49>;
    "dispatch_whitelisted_call_with_preimage": Anonymize<I7v5c9tuldh45d>;
}>;
export type I7v5c9tuldh45d = {
    "call": TxCallData;
};
export type Ib7tahn20bvsep = AnonymousEnum<{
    /**
     * Suspends all XCM executions for the XCMP queue, regardless of the sender's origin.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     */
    "suspend_xcm_execution": undefined;
    /**
     * Resumes all XCM executions for the XCMP queue.
     *
     * Note that this function doesn't change the status of the in/out bound channels.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     */
    "resume_xcm_execution": undefined;
    /**
     * Overwrites the number of pages which must be in the queue for the other side to be
     * told to suspend their sending.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.suspend_value`
     */
    "update_suspend_threshold": Anonymize<I3vh014cqgmrfd>;
    /**
     * Overwrites the number of pages which must be in the queue after which we drop any
     * further messages from the channel.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.drop_threshold`
     */
    "update_drop_threshold": Anonymize<I3vh014cqgmrfd>;
    /**
     * Overwrites the number of pages which the queue must be reduced to before it signals
     * that message sending may recommence after it has been suspended.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.resume_threshold`
     */
    "update_resume_threshold": Anonymize<I3vh014cqgmrfd>;
}>;
export type I6p7dfe157nddg = AnonymousEnum<{
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    "batch": Anonymize<If9h84vop1ud2e>;
    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     */
    "as_derivative": Anonymize<I95iqinn1v9f4s>;
    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    "batch_all": Anonymize<If9h84vop1ud2e>;
    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     */
    "dispatch_as": Anonymize<Iefva374rimroe>;
    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    "force_batch": Anonymize<If9h84vop1ud2e>;
    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     */
    "with_weight": Anonymize<I9sf1boihdee4o>;
    /**
     * Dispatch a fallback call in the event the main call fails to execute.
     * May be called from any origin except `None`.
     *
     * This function first attempts to dispatch the `main` call.
     * If the `main` call fails, the `fallback` is attemted.
     * if the fallback is successfully dispatched, the weights of both calls
     * are accumulated and an event containing the main call error is deposited.
     *
     * In the event of a fallback failure the whole call fails
     * with the weights returned.
     *
     * - `main`: The main call to be dispatched. This is the primary action to execute.
     * - `fallback`: The fallback call to be dispatched in case the `main` call fails.
     *
     * ## Dispatch Logic
     * - If the origin is `root`, both the main and fallback calls are executed without
     * applying any origin filters.
     * - If the origin is not `root`, the origin filter is applied to both the `main` and
     * `fallback` calls.
     *
     * ## Use Case
     * - Some use cases might involve submitting a `batch` type call in either main, fallback
     * or both.
     */
    "if_else": Anonymize<Ib3il1re0kddul>;
    /**
     * Dispatches a function call with a provided origin.
     *
     * Almost the same as [`Pallet::dispatch_as`] but forwards any error of the inner call.
     *
     * The dispatch origin for this call must be _Root_.
     */
    "dispatch_as_fallible": Anonymize<Iefva374rimroe>;
}>;
export type If9h84vop1ud2e = {
    "calls": Array<TxCallData>;
};
export type I95iqinn1v9f4s = {
    "index": number;
    "call": TxCallData;
};
export type Iefva374rimroe = {
    "as_origin": Anonymize<Ifohkba1aph7uu>;
    "call": TxCallData;
};
export type I9sf1boihdee4o = {
    "call": TxCallData;
    "weight": Anonymize<I4q39t5hn830vp>;
};
export type Ib3il1re0kddul = {
    "main": TxCallData;
    "fallback": TxCallData;
};
export type Idmq3gcajulc6r = AnonymousEnum<{
    /**
     * Anonymously schedule a task.
     */
    "schedule": Anonymize<I3q1qmerq329s7>;
    /**
     * Cancel an anonymously scheduled task.
     */
    "cancel": Anonymize<I5n4sebgkfr760>;
    /**
     * Schedule a named task.
     */
    "schedule_named": Anonymize<I6eg824e6fjb9c>;
    /**
     * Cancel a named scheduled task.
     */
    "cancel_named": Anonymize<Ifs1i5fk9cqvr6>;
    /**
     * Anonymously schedule a task after a delay.
     */
    "schedule_after": Anonymize<I7qjbmfe885ov4>;
    /**
     * Schedule a named task after a delay.
     */
    "schedule_named_after": Anonymize<I373fom61ldpl>;
    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     */
    "set_retry": Anonymize<Ieg3fd8p4pkt10>;
    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     */
    "set_retry_named": Anonymize<I8kg5ll427kfqq>;
    /**
     * Removes the retry configuration of a task.
     */
    "cancel_retry": Anonymize<I467333262q1l9>;
    /**
     * Cancel the retry configuration of a named task.
     */
    "cancel_retry_named": Anonymize<Ifs1i5fk9cqvr6>;
}>;
export type I3q1qmerq329s7 = {
    "when": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I6eg824e6fjb9c = {
    "id": FixedSizeBinary<32>;
    "when": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I7qjbmfe885ov4 = {
    "after": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I373fom61ldpl = {
    "id": FixedSizeBinary<32>;
    "after": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type Idhal6edn5k25n = AnonymousEnum<{
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    "proxy": Anonymize<If9sbgppso3l3r>;
    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     */
    "add_proxy": Anonymize<I36o7ps27f842k>;
    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     */
    "remove_proxy": Anonymize<I36o7ps27f842k>;
    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     */
    "remove_proxies": undefined;
    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     */
    "create_pure": Anonymize<Ie4ebalp1vm5ac>;
    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     */
    "kill_pure": Anonymize<Iuqevbnrvdkd8>;
    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    "announce": Anonymize<Idj9faf6hgsdur>;
    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    "remove_announcement": Anonymize<Idj9faf6hgsdur>;
    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     */
    "reject_announcement": Anonymize<I8mj1nm903hpts>;
    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    "proxy_announced": Anonymize<I4h7mqkdp0u1ih>;
    /**
     * Poke / Adjust deposits made for proxies and announcements based on current values.
     * This can be used by accounts to possibly lower their locked amount.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * The transaction fee is waived if the deposit amount has changed.
     *
     * Emits `DepositPoked` if successful.
     */
    "poke_deposit": undefined;
}>;
export type If9sbgppso3l3r = {
    "real": Anonymize<I4su1fqci7afjt>;
    "force_proxy_type"?: Anonymize<Ie3ut0no76jc8k>;
    "call": TxCallData;
};
export type Ie3ut0no76jc8k = (Anonymize<Iebopc45bqaiad>) | undefined;
export type I36o7ps27f842k = {
    "delegate": Anonymize<I4su1fqci7afjt>;
    "proxy_type": Anonymize<Iebopc45bqaiad>;
    "delay": number;
};
export type Ie4ebalp1vm5ac = {
    "proxy_type": Anonymize<Iebopc45bqaiad>;
    "delay": number;
    "index": number;
};
export type Iuqevbnrvdkd8 = {
    "spawner": Anonymize<I4su1fqci7afjt>;
    "proxy_type": Anonymize<Iebopc45bqaiad>;
    "index": number;
    "height": number;
    "ext_index": number;
};
export type Idj9faf6hgsdur = {
    "real": Anonymize<I4su1fqci7afjt>;
    "call_hash": FixedSizeBinary<32>;
};
export type I8mj1nm903hpts = {
    "delegate": Anonymize<I4su1fqci7afjt>;
    "call_hash": FixedSizeBinary<32>;
};
export type I4h7mqkdp0u1ih = {
    "delegate": Anonymize<I4su1fqci7afjt>;
    "real": Anonymize<I4su1fqci7afjt>;
    "force_proxy_type"?: Anonymize<Ie3ut0no76jc8k>;
    "call": TxCallData;
};
export type I1nlok85f3lnbu = AnonymousEnum<{
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    "as_multi_threshold_1": Anonymize<Ia69km3o2rblpi>;
    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    "as_multi": Anonymize<I4kapheqtplrhh>;
    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    "approve_as_multi": Anonymize<Ideaemvoneh309>;
    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     */
    "cancel_as_multi": Anonymize<I3d9o9d7epp66v>;
    /**
     * Poke the deposit reserved for an existing multisig operation.
     *
     * The dispatch origin for this call must be _Signed_ and must be the original depositor of
     * the multisig operation.
     *
     * The transaction fee is waived if the deposit amount has changed.
     *
     * - `threshold`: The total number of approvals needed for this multisig.
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multisig.
     * - `call_hash`: The hash of the call this deposit is reserved for.
     *
     * Emits `DepositPoked` if successful.
     */
    "poke_deposit": Anonymize<I6lqh1vgb4mcja>;
}>;
export type Ia69km3o2rblpi = {
    "other_signatories": Anonymize<Ia2lhg7l2hilo3>;
    "call": TxCallData;
};
export type I4kapheqtplrhh = {
    "threshold": number;
    "other_signatories": Anonymize<Ia2lhg7l2hilo3>;
    "maybe_timepoint"?: Anonymize<I95jfd8j5cr5eh>;
    "call": TxCallData;
    "max_weight": Anonymize<I4q39t5hn830vp>;
};
export type Ias6m7696errt5 = AnonymousEnum<{
    /**
     * Add a registrar to the system.
     *
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     *
     * - `account`: the account of the registrar.
     *
     * Emits `RegistrarAdded` if successful.
     */
    "add_registrar": Anonymize<I73kffnn32g4c7>;
    /**
     * Set an account's identity information and reserve the appropriate deposit.
     *
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `info`: The identity information.
     *
     * Emits `IdentitySet` if successful.
     */
    "set_identity": Anonymize<I2kds5jji7slh8>;
    /**
     * Set the sub-accounts of the sender.
     *
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * - `subs`: The identity's (new) sub-accounts.
     */
    "set_subs": Anonymize<Ia9mkdf6l44shb>;
    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     *
     * Payment: All reserved balances on the account are returned.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * Emits `IdentityCleared` if successful.
     */
    "clear_identity": undefined;
    /**
     * Request a judgement from a registrar.
     *
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     *
     * ```nocompile
     * Registrars::<T>::get().get(reg_index).unwrap().fee
     * ```
     *
     * Emits `JudgementRequested` if successful.
     */
    "request_judgement": Anonymize<I9l2s4klu0831o>;
    /**
     * Cancel a previous request.
     *
     * Payment: A previously reserved deposit is returned on success.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     *
     * Emits `JudgementUnrequested` if successful.
     */
    "cancel_request": Anonymize<I2ctrt5nqb8o7c>;
    /**
     * Set the fee required for a judgement to be requested from a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     */
    "set_fee": Anonymize<I711qahikocb1c>;
    /**
     * Change the account associated with a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     */
    "set_account_id": Anonymize<I1u3ac7lafvv5b>;
    /**
     * Set the field information for a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     */
    "set_fields": Anonymize<Id6gojh30v9ib2>;
    /**
     * Provide a judgement for an account's identity.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     *
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
     * provided.
     *
     * Note: Judgements do not apply to a username.
     *
     * Emits `JudgementGiven` if successful.
     */
    "provide_judgement": Anonymize<I9h4cqmadpj7l0>;
    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     *
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     *
     * Emits `IdentityKilled` if successful.
     */
    "kill_identity": Anonymize<If31vrl50nund3>;
    /**
     * Add the given account to the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    "add_sub": Anonymize<I29bkdd7n16li1>;
    /**
     * Alter the associated name of the given sub-account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    "rename_sub": Anonymize<I29bkdd7n16li1>;
    /**
     * Remove the given account from the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    "remove_sub": Anonymize<I9jb9hqm18runn>;
    /**
     * Remove the sender as a sub-account.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     *
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     */
    "quit_sub": undefined;
    /**
     * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
     *
     * The authority can grant up to `allocation` usernames. To top up the allocation or
     * change the account used to grant usernames, this call can be used with the updated
     * parameters to overwrite the existing configuration.
     */
    "add_username_authority": Anonymize<I85htvo8b885h>;
    /**
     * Remove `authority` from the username authorities.
     */
    "remove_username_authority": Anonymize<I13n219aci2a5j>;
    /**
     * Set the username for `who`. Must be called by a username authority.
     *
     * If `use_allocation` is set, the authority must have a username allocation available to
     * spend. Otherwise, the authority will need to put up a deposit for registering the
     * username.
     *
     * Users can either pre-sign their usernames or
     * accept them later.
     *
     * Usernames must:
     * - Only contain lowercase ASCII characters or digits.
     * - When combined with the suffix of the issuing authority be _less than_ the
     * `MaxUsernameLength`.
     */
    "set_username_for": Anonymize<Ialt2aiqe4ps5k>;
    /**
     * Accept a given username that an `authority` granted. The call must include the full
     * username, as in `username.suffix`.
     */
    "accept_username": Anonymize<Ie5l999tf7t2te>;
    /**
     * Remove an expired username approval. The username was approved by an authority but never
     * accepted by the user and must now be beyond its expiration. The call must include the
     * full username, as in `username.suffix`.
     */
    "remove_expired_approval": Anonymize<Ie5l999tf7t2te>;
    /**
     * Set a given username as the primary. The username should include the suffix.
     */
    "set_primary_username": Anonymize<Ie5l999tf7t2te>;
    /**
     * Start the process of removing a username by placing it in the unbinding usernames map.
     * Once the grace period has passed, the username can be deleted by calling
     * [remove_username](crate::Call::remove_username).
     */
    "unbind_username": Anonymize<Ie5l999tf7t2te>;
    /**
     * Permanently delete a username which has been unbinding for longer than the grace period.
     * Caller is refunded the fee if the username expired and the removal was successful.
     */
    "remove_username": Anonymize<Ie5l999tf7t2te>;
    /**
     * Call with [ForceOrigin](crate::Config::ForceOrigin) privileges which deletes a username
     * and slashes any deposit associated with it.
     */
    "kill_username": Anonymize<Ie5l999tf7t2te>;
}>;
export type I73kffnn32g4c7 = {
    "account": Anonymize<I4su1fqci7afjt>;
};
export type Ia9mkdf6l44shb = {
    "subs": Array<Anonymize<I910puuahutflf>>;
};
export type I9h4cqmadpj7l0 = {
    "reg_index": number;
    "target": Anonymize<I4su1fqci7afjt>;
    "judgement": IdentityJudgement;
    "identity": FixedSizeBinary<32>;
};
export type If31vrl50nund3 = {
    "target": Anonymize<I4su1fqci7afjt>;
};
export type I29bkdd7n16li1 = {
    "sub": Anonymize<I4su1fqci7afjt>;
    "data": IdentityData;
};
export type I9jb9hqm18runn = {
    "sub": Anonymize<I4su1fqci7afjt>;
};
export type I85htvo8b885h = {
    "authority": Anonymize<I4su1fqci7afjt>;
    "suffix": Binary;
    "allocation": number;
};
export type I13n219aci2a5j = {
    "suffix": Binary;
    "authority": Anonymize<I4su1fqci7afjt>;
};
export type Ialt2aiqe4ps5k = {
    "who": Anonymize<I4su1fqci7afjt>;
    "username": Binary;
    "signature"?: Anonymize<I86cdjmsf3a81s>;
    "use_allocation": boolean;
};
export type I24a2kubctpuac = AnonymousEnum<{
    /**
     * Unlock any vested funds of the sender account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "vest": undefined;
    /**
     * Unlock any vested funds of a `target` account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account whose vested funds should be unlocked. Must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "vest_other": Anonymize<If31vrl50nund3>;
    /**
     * Create a vested transfer.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account receiving the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "vested_transfer": Anonymize<I3usr0jpt8ovnk>;
    /**
     * Force a vested transfer.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `source`: The account whose funds should be transferred.
     * - `target`: The account that should be transferred the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     */
    "force_vested_transfer": Anonymize<I5a5fh6anhjgu7>;
    "init_vesting_start_at": Anonymize<I3atr9j3ums3m2>;
    "set_vesting_per_block": Anonymize<I2bvdo47pdo59f>;
    "force_set_cliff": Anonymize<I2okmh2c5ub01c>;
    /**
     * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
     * the highest possible start and end blocks. If both schedules have already started the
     * current block will be used as the schedule start; with the caveat that if one schedule
     * is finished by the current block, the other will be treated as the new merged schedule,
     * unmodified.
     *
     * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
     * NOTE: This will unlock all schedules through the current block prior to merging.
     * NOTE: If both schedules have ended by the current block, no new schedule will be created
     * and both will be removed.
     *
     * Merged schedule attributes:
     * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
     * current_block)`.
     * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
     * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `schedule1_index`: index of the first schedule to merge.
     * - `schedule2_index`: index of the second schedule to merge.
     */
    "merge_schedules": Anonymize<Ict9ivhr2c5hv0>;
}>;
export type I3usr0jpt8ovnk = {
    "target": Anonymize<I4su1fqci7afjt>;
    "schedule": Anonymize<I4aro1m78pdrtt>;
};
export type I5a5fh6anhjgu7 = {
    "source": Anonymize<I4su1fqci7afjt>;
    "target": Anonymize<I4su1fqci7afjt>;
    "schedule": Anonymize<I4aro1m78pdrtt>;
};
export type I3atr9j3ums3m2 = {
    "vesting_start_at": number;
};
export type I2bvdo47pdo59f = {
    "target": Anonymize<I4su1fqci7afjt>;
    "index": number;
    "per_block": bigint;
};
export type I2okmh2c5ub01c = {
    "target": Anonymize<I4su1fqci7afjt>;
    "cliff_block": number;
};
export type Idrsndhllhv8bk = AnonymousEnum<{
    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
     *
     * ### Details
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     *
     * ### Parameters
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     *
     * ## Events
     *
     * Emits [`Event::SpendApproved`] if successful.
     */
    "spend_local": Anonymize<I7fcl4aua07ato>;
    /**
     * Force a previously approved proposal to be removed from the approval queue.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * The original deposit will no longer be returned.
     *
     * ### Parameters
     * - `proposal_id`: The index of a proposal
     *
     * ### Complexity
     * - O(A) where `A` is the number of approvals
     *
     * ### Errors
     * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
     * approval queue, i.e., the proposal has not been approved. This could also mean the
     * proposal does not exist altogether, thus there is no way it would have been approved
     * in the first place.
     */
    "remove_approval": Anonymize<Icm9m0qeemu66d>;
    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least
     * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
     * for assertion using the [`Config::BalanceConverter`].
     *
     * ## Details
     *
     * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
     * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
     * the [`Config::PayoutPeriod`].
     *
     * ### Parameters
     * - `asset_kind`: An indicator of the specific asset class to be spent.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The beneficiary of the spend.
     * - `valid_from`: The block number from which the spend can be claimed. It can refer to
     * the past if the resulting spend has not yet expired according to the
     * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
     * approval.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendApproved`] if successful.
     */
    "spend": Anonymize<I6qq5nnbjegi8u>;
    /**
     * Claim a spend.
     *
     * ## Dispatch Origin
     *
     * Must be signed
     *
     * ## Details
     *
     * Spends must be claimed within some temporal bounds. A spend may be claimed within one
     * [`Config::PayoutPeriod`] from the `valid_from` block.
     * In case of a payout failure, the spend status must be updated with the `check_status`
     * dispatchable before retrying with the current function.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::Paid`] if successful.
     */
    "payout": Anonymize<I666bl2fqjkejo>;
    /**
     * Check the status of the spend and remove it from the storage if processed.
     *
     * ## Dispatch Origin
     *
     * Must be signed.
     *
     * ## Details
     *
     * The status check is a prerequisite for retrying a failed payout.
     * If a spend has either succeeded or expired, it is removed from the storage by this
     * function. In such instances, transaction fees are refunded.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::PaymentFailed`] if the spend payout has failed.
     * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
     */
    "check_status": Anonymize<I666bl2fqjkejo>;
    /**
     * Void previously approved spend.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * A spend void is only possible if the payout has not been attempted yet.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendVoided`] if successful.
     */
    "void_spend": Anonymize<I666bl2fqjkejo>;
}>;
export type I7fcl4aua07ato = {
    "amount": bigint;
    "beneficiary": Anonymize<I4su1fqci7afjt>;
};
export type I6qq5nnbjegi8u = {
    "amount": bigint;
    "beneficiary": SS58String;
    "valid_from"?: Anonymize<I4arjljr6dpflb>;
};
export type I3lo8is2egp8k4 = AnonymousEnum<{
    /**
     * Transact an Ethereum transaction.
     */
    "transact": Anonymize<I13qib3vtm9cs3>;
}>;
export type I13qib3vtm9cs3 = {
    "transaction": Anonymize<Ibjuap2vk03rp6>;
};
export type I78r7di33lh57i = AnonymousEnum<{
    /**
     * Withdraw balance from EVM into currency/balances pallet.
     */
    "withdraw": Anonymize<Idcabvplu05lea>;
    /**
     * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
     */
    "call": Anonymize<Id38gdpcotl637>;
    /**
     * Issue an EVM create operation. This is similar to a contract creation transaction in
     * Ethereum.
     */
    "create": Anonymize<I73q3qf5u7nnqg>;
    /**
     * Issue an EVM create2 operation.
     */
    "create2": Anonymize<Idpm1bc2cr6dgj>;
}>;
export type Id38gdpcotl637 = {
    "source": FixedSizeBinary<20>;
    "target": FixedSizeBinary<20>;
    "input": Binary;
    "value": Anonymize<I4totqt881mlti>;
    "gas_limit": bigint;
    "max_fee_per_gas": Anonymize<I4totqt881mlti>;
    "max_priority_fee_per_gas"?: Anonymize<Ic4rgfgksgmm3e>;
    "nonce"?: Anonymize<Ic4rgfgksgmm3e>;
    "access_list": Anonymize<I1bsfec060j604>;
    "authorization_list": Anonymize<Idg0qi60379vnh>;
};
export type I73q3qf5u7nnqg = {
    "source": FixedSizeBinary<20>;
    "init": Binary;
    "value": Anonymize<I4totqt881mlti>;
    "gas_limit": bigint;
    "max_fee_per_gas": Anonymize<I4totqt881mlti>;
    "max_priority_fee_per_gas"?: Anonymize<Ic4rgfgksgmm3e>;
    "nonce"?: Anonymize<Ic4rgfgksgmm3e>;
    "access_list": Anonymize<I1bsfec060j604>;
    "authorization_list": Anonymize<Idg0qi60379vnh>;
};
export type Idpm1bc2cr6dgj = {
    "source": FixedSizeBinary<20>;
    "init": Binary;
    "salt": FixedSizeBinary<32>;
    "value": Anonymize<I4totqt881mlti>;
    "gas_limit": bigint;
    "max_fee_per_gas": Anonymize<I4totqt881mlti>;
    "max_priority_fee_per_gas"?: Anonymize<Ic4rgfgksgmm3e>;
    "nonce"?: Anonymize<Ic4rgfgksgmm3e>;
    "access_list": Anonymize<I1bsfec060j604>;
    "authorization_list": Anonymize<Idg0qi60379vnh>;
};
export type Ie18f12l062q2m = AnonymousEnum<{
    "note_min_gas_price_target": Anonymize<I6v8kghkt0dksl>;
}>;
export type I6v8kghkt0dksl = {
    "target": Anonymize<I4totqt881mlti>;
};
export type I1l1phpc090qm9 = AnonymousEnum<{
    /**
     * Binds a Substrate address to EVM address.
     * After binding, the EVM is able to convert an EVM address to the original Substrate
     * address. Without binding, the EVM converts an EVM address to a truncated Substrate
     * address, which doesn't correspond to the origin address.
     *
     * Binding an address is not necessary for interacting with the EVM.
     *
     * Parameters:
     * - `origin`: Substrate account binding an address
     *
     * Emits `EvmAccountBound` event when successful.
     */
    "bind_evm_address": undefined;
    /**
     * Adds an EVM address to the list of addresses that are allowed to deploy smart contracts.
     *
     * Parameters:
     * - `origin`: Substrate account whitelisting an address. Must be `ControllerOrigin`.
     * - `address`: EVM address that is whitelisted
     *
     * Emits `DeployerAdded` event when successful.
     */
    "add_contract_deployer": Anonymize<Itmchvgqfl28g>;
    /**
     * Removes an EVM address from the list of addresses that are allowed to deploy smart
     * contracts.
     *
     * Parameters:
     * - `origin`: Substrate account removing the EVM address from the whitelist. Must be
     * `ControllerOrigin`.
     * - `address`: EVM address that is removed from the whitelist
     *
     * Emits `DeployerRemoved` event when successful.
     */
    "remove_contract_deployer": Anonymize<Itmchvgqfl28g>;
    /**
     * Removes the account's EVM address from the list of addresses that are allowed to deploy
     * smart contracts. Based on the best practices, this extrinsic can be called by any
     * whitelisted account to renounce their own permission.
     *
     * Parameters:
     * - `origin`: Substrate account removing their EVM address from the whitelist.
     *
     * Emits `DeployerRemoved` event when successful.
     */
    "renounce_contract_deployer": undefined;
}>;
export type Ice254h3kamj7h = AnonymousEnum<{
    /**
     * Transfer native currencies.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    "transfer": Anonymize<I3a0noisblbb>;
    /**
     * Transfer `Asset`.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    "transfer_multiasset": Anonymize<Ifpfll8q52l7d8>;
    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     *
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    "transfer_with_fee": Anonymize<I7d12t2s4nb6n>;
    /**
     * Transfer `Asset` specifying the fee and amount as separate.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee` is the Asset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `Location` id.
     *
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    "transfer_multiasset_with_fee": Anonymize<Imdvokfbpi0mt>;
    /**
     * Transfer several currencies specifying the item to be used as fee
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    "transfer_multicurrencies": Anonymize<I4fvf7id1oq611>;
    /**
     * Transfer several `Asset` specifying the item to be used as fee
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee_item` is index of the Assets that we want to use for
     * payment
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    "transfer_multiassets": Anonymize<Imgcatq9b2cl1>;
}>;
export type I3a0noisblbb = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "amount": bigint;
    "dest": XcmVersionedLocation;
    "dest_weight_limit": XcmV3WeightLimit;
};
export type Ifpfll8q52l7d8 = {
    "asset": XcmVersionedAsset;
    "dest": XcmVersionedLocation;
    "dest_weight_limit": XcmV3WeightLimit;
};
export type XcmVersionedAsset = Enum<{
    "V3": Anonymize<Idcm24504c8bkk>;
    "V4": Anonymize<Ia5l7mu5a6v49o>;
    "V5": Anonymize<Iffh1nc5e1mod6>;
}>;
export declare const XcmVersionedAsset: GetEnum<XcmVersionedAsset>;
export type I7d12t2s4nb6n = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "amount": bigint;
    "fee": bigint;
    "dest": XcmVersionedLocation;
    "dest_weight_limit": XcmV3WeightLimit;
};
export type Imdvokfbpi0mt = {
    "asset": XcmVersionedAsset;
    "fee": XcmVersionedAsset;
    "dest": XcmVersionedLocation;
    "dest_weight_limit": XcmV3WeightLimit;
};
export type I4fvf7id1oq611 = {
    "currencies": Anonymize<I2dbamvpq4935>;
    "fee_item": number;
    "dest": XcmVersionedLocation;
    "dest_weight_limit": XcmV3WeightLimit;
};
export type Imgcatq9b2cl1 = {
    "assets": XcmVersionedAssets;
    "fee_item": number;
    "dest": XcmVersionedLocation;
    "dest_weight_limit": XcmV3WeightLimit;
};
export type Ifg1rpnuo1vsne = AnonymousEnum<{
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     *
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to transfer.
     */
    "transfer": Anonymize<I302t0ook7k95n>;
    /**
     * Transfer all remaining balance to the given account.
     *
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     *
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     *
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     * operation should send all of the funds the account has, causing
     * the sender account to be killed (false), or transfer everything
     * except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     */
    "transfer_all": Anonymize<If84l0hb2pbh5j>;
    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     *
     * 99% of the time you want [`transfer`] instead.
     *
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     *
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to transfer.
     */
    "transfer_keep_alive": Anonymize<I302t0ook7k95n>;
    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to transfer.
     */
    "force_transfer": Anonymize<I7td476oj5kt2h>;
    /**
     * Set the balances of a given account.
     *
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     *
     * The dispatch origin for this call is `root`.
     */
    "set_balance": Anonymize<I1o4mqqd02b5sj>;
}>;
export type I302t0ook7k95n = {
    "dest": Anonymize<I4su1fqci7afjt>;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "amount": bigint;
};
export type If84l0hb2pbh5j = {
    "dest": Anonymize<I4su1fqci7afjt>;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "keep_alive": boolean;
};
export type I7td476oj5kt2h = {
    "source": Anonymize<I4su1fqci7afjt>;
    "dest": Anonymize<I4su1fqci7afjt>;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "amount": bigint;
};
export type I1o4mqqd02b5sj = {
    "who": Anonymize<I4su1fqci7afjt>;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "new_free": bigint;
    "new_reserved": bigint;
};
export type I8t7b9qn3bqn3i = AnonymousEnum<{
    /**
     * Send an XCM message as parachain sovereign.
     */
    "send_as_sovereign": Anonymize<Ia5cotcvi888ln>;
}>;
export type I55fhdusvjpt5l = AnonymousEnum<{
    /**
     * Set the new receiver of the protocol fee.
     *
     * # Arguments
     *
     * - `send_to`:
     * (1) Some(receiver): it turn on the protocol fee and the new receiver account.
     * (2) None: it turn off the protocol fee.
     */
    "set_fee_receiver": Anonymize<Id3v70nvrro0hv>;
    /**
     * Set the protocol fee point.
     *
     * # Arguments
     *
     * - `fee_point`:
     * 0 means that all exchange fees belong to the liquidity provider.
     * 30 means that all exchange fees belong to the fee receiver.
     */
    "set_fee_point": Anonymize<I6msvbss3ktmnu>;
    /**
     * Move some assets from one holder to another.
     *
     * # Arguments
     *
     * - `asset_id`: The foreign id.
     * - `target`: The receiver of the foreign.
     * - `amount`: The amount of the foreign to transfer.
     */
    "transfer": Anonymize<Ifbs87e8855hrh>;
    /**
     * Create pair by two assets.
     *
     * The order of foreign dot effect result.
     *
     * # Arguments
     *
     * - `asset_0`: Asset which make up Pair
     * - `asset_1`: Asset which make up Pair
     */
    "create_pair": Anonymize<Ibugemvm1fr87g>;
    /**
     * Provide liquidity to a pair.
     *
     * The order of foreign dot effect result.
     *
     * # Arguments
     *
     * - `asset_0`: Asset which make up pair
     * - `asset_1`: Asset which make up pair
     * - `amount_0_desired`: Maximum amount of asset_0 added to the pair
     * - `amount_1_desired`: Maximum amount of asset_1 added to the pair
     * - `amount_0_min`: Minimum amount of asset_0 added to the pair
     * - `amount_1_min`: Minimum amount of asset_1 added to the pair
     * - `deadline`: Height of the cutoff block of this transaction
     */
    "add_liquidity": Anonymize<I11kqb3hb93c3c>;
    /**
     * Extract liquidity.
     *
     * The order of foreign dot effect result.
     *
     * # Arguments
     *
     * - `asset_0`: Asset which make up pair
     * - `asset_1`: Asset which make up pair
     * - `amount_asset_0_min`: Minimum amount of asset_0 to exact
     * - `amount_asset_1_min`: Minimum amount of asset_1 to exact
     * - `recipient`: Account that accepts withdrawal of assets
     * - `deadline`: Height of the cutoff block of this transaction
     */
    "remove_liquidity": Anonymize<Ici6p55173o3kg>;
    /**
     * Sell amount of foreign by path.
     *
     * # Arguments
     *
     * - `amount_in`: Amount of the foreign will be sold
     * - `amount_out_min`: Minimum amount of target foreign
     * - `path`: path can convert to pairs.
     * - `recipient`: Account that receive the target foreign
     * - `deadline`: Height of the cutoff block of this transaction
     */
    "swap_exact_assets_for_assets": Anonymize<Ib7tkro61h34d2>;
    /**
     * Buy amount of foreign by path.
     *
     * # Arguments
     *
     * - `amount_out`: Amount of the foreign will be bought
     * - `amount_in_max`: Maximum amount of sold foreign
     * - `path`: path can convert to pairs.
     * - `recipient`: Account that receive the target foreign
     * - `deadline`: Height of the cutoff block of this transaction
     */
    "swap_assets_for_exact_assets": Anonymize<Ig5896f16psh3>;
    /**
     * Create bootstrap pair
     *
     * The order of asset don't affect result.
     *
     * # Arguments
     *
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `target_supply_0`: Target amount of asset_0 total contribute
     * - `target_supply_0`: Target amount of asset_1 total contribute
     * - `capacity_supply_0`: The max amount of asset_0 total contribute
     * - `capacity_supply_1`: The max amount of asset_1 total contribute
     * - `end`: The earliest ending block.
     */
    "bootstrap_create": Anonymize<Ibsib3ed5u1164>;
    /**
     * Contribute some asset to a bootstrap pair
     *
     * # Arguments
     *
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `amount_0_contribute`: The amount of asset_0 contribute to this bootstrap pair
     * - `amount_1_contribute`: The amount of asset_1 contribute to this bootstrap pair
     * - `deadline`: Height of the cutoff block of this transaction
     */
    "bootstrap_contribute": Anonymize<I6g1lhais855g9>;
    /**
     * Claim lp asset from a bootstrap pair
     *
     * # Arguments
     *
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `deadline`: Height of the cutoff block of this transaction
     */
    "bootstrap_claim": Anonymize<I52cpe8da8o62l>;
    /**
     * End a bootstrap pair
     *
     * # Arguments
     *
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     */
    "bootstrap_end": Anonymize<I7h9e3cbrb3kaa>;
    /**
     * update a bootstrap pair
     *
     * # Arguments
     *
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `min_contribution_0`: The new min amount of asset_0 contribute
     * - `min_contribution_0`: The new min amount of asset_1 contribute
     * - `target_supply_0`: The new target amount of asset_0 total contribute
     * - `target_supply_0`: The new target amount of asset_1 total contribute
     * - `capacity_supply_0`: The new max amount of asset_0 total contribute
     * - `capacity_supply_1`: The new max amount of asset_1 total contribute
     * - `end`: The earliest ending block.
     */
    "bootstrap_update": Anonymize<Ibsib3ed5u1164>;
    /**
     * Contributor refund from disable bootstrap pair
     *
     * # Arguments
     *
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     */
    "bootstrap_refund": Anonymize<I7h9e3cbrb3kaa>;
    "bootstrap_charge_reward": Anonymize<Ieaqa57prka9ld>;
    "bootstrap_withdraw_reward": Anonymize<Iedoc1ioirjto2>;
    "set_new_fee_receiver": Anonymize<Idqd6j83jfa92q>;
}>;
export type Id3v70nvrro0hv = {
    "send_to"?: (Anonymize<I4su1fqci7afjt>) | undefined;
};
export type I6msvbss3ktmnu = {
    "fee_point": number;
};
export type Ifbs87e8855hrh = {
    "asset_id": Anonymize<Icu3qllmbdnj89>;
    "recipient": Anonymize<I4su1fqci7afjt>;
    "amount": bigint;
};
export type Ibugemvm1fr87g = {
    "asset_0": Anonymize<Icu3qllmbdnj89>;
    "asset_1": Anonymize<Icu3qllmbdnj89>;
    "fee_recipient": Anonymize<I4su1fqci7afjt>;
};
export type I11kqb3hb93c3c = {
    "asset_0": Anonymize<Icu3qllmbdnj89>;
    "asset_1": Anonymize<Icu3qllmbdnj89>;
    "amount_0_desired": bigint;
    "amount_1_desired": bigint;
    "amount_0_min": bigint;
    "amount_1_min": bigint;
    "deadline": number;
};
export type Ici6p55173o3kg = {
    "asset_0": Anonymize<Icu3qllmbdnj89>;
    "asset_1": Anonymize<Icu3qllmbdnj89>;
    "liquidity": bigint;
    "amount_0_min": bigint;
    "amount_1_min": bigint;
    "recipient": Anonymize<I4su1fqci7afjt>;
    "deadline": number;
};
export type Ib7tkro61h34d2 = {
    "amount_in": bigint;
    "amount_out_min": bigint;
    "path": Anonymize<Idhafor8sovqeu>;
    "recipient": Anonymize<I4su1fqci7afjt>;
    "deadline": number;
};
export type Ig5896f16psh3 = {
    "amount_out": bigint;
    "amount_in_max": bigint;
    "path": Anonymize<Idhafor8sovqeu>;
    "recipient": Anonymize<I4su1fqci7afjt>;
    "deadline": number;
};
export type Ibsib3ed5u1164 = {
    "asset_0": Anonymize<Icu3qllmbdnj89>;
    "asset_1": Anonymize<Icu3qllmbdnj89>;
    "target_supply_0": bigint;
    "target_supply_1": bigint;
    "capacity_supply_0": bigint;
    "capacity_supply_1": bigint;
    "end": number;
    "rewards": Anonymize<Idhafor8sovqeu>;
    "limits": Anonymize<I6sn46nd9sjbst>;
};
export type I6g1lhais855g9 = {
    "asset_0": Anonymize<Icu3qllmbdnj89>;
    "asset_1": Anonymize<Icu3qllmbdnj89>;
    "amount_0_contribute": bigint;
    "amount_1_contribute": bigint;
    "deadline": number;
};
export type I52cpe8da8o62l = {
    "recipient": Anonymize<I4su1fqci7afjt>;
    "asset_0": Anonymize<Icu3qllmbdnj89>;
    "asset_1": Anonymize<Icu3qllmbdnj89>;
    "deadline": number;
};
export type I7h9e3cbrb3kaa = {
    "asset_0": Anonymize<Icu3qllmbdnj89>;
    "asset_1": Anonymize<Icu3qllmbdnj89>;
};
export type Ieaqa57prka9ld = {
    "asset_0": Anonymize<Icu3qllmbdnj89>;
    "asset_1": Anonymize<Icu3qllmbdnj89>;
    "charge_rewards": Anonymize<I6sn46nd9sjbst>;
};
export type Iedoc1ioirjto2 = {
    "asset_0": Anonymize<Icu3qllmbdnj89>;
    "asset_1": Anonymize<Icu3qllmbdnj89>;
    "recipient": Anonymize<I4su1fqci7afjt>;
};
export type Idqd6j83jfa92q = {
    "asset": Anonymize<Icu3qllmbdnj89>;
    "send_to": Anonymize<I4su1fqci7afjt>;
};
export type I31d7vn1hatu5q = AnonymousEnum<{
    /**
     * Execute the provided batch of ISMP messages, this will short-circuit and revert if any
     * of the provided messages are invalid. This is an unsigned extrinsic that permits anyone
     * execute ISMP messages for free, provided they have valid proofs and the messages have
     * not been previously processed.
     *
     * The dispatch origin for this call must be an unsigned one.
     *
     * - `messages`: the messages to handle or process.
     *
     * Emits different message events based on the Message received if successful.
     */
    "handle_unsigned": Anonymize<I5nmhnue5h41rg>;
    /**
     * Create a consensus client, using a subjectively chosen consensus state. This can also
     * be used to overwrite an existing consensus state. The dispatch origin for this
     * call must be `T::AdminOrigin`.
     *
     * - `message`: [`CreateConsensusState`] struct.
     *
     * Emits [`Event::ConsensusClientCreated`] if successful.
     */
    "create_consensus_client": Anonymize<I8416p6oh7m35t>;
    /**
     * Modify the unbonding period and challenge period for a consensus state.
     * The dispatch origin for this call must be `T::AdminOrigin`.
     *
     * - `message`: `UpdateConsensusState` struct.
     */
    "update_consensus_state": Anonymize<I1cj3vacp7n158>;
    /**
     * Add more funds to a message (request or response) to be used for delivery and execution.
     *
     * Should not be called on a message that has been completed (delivered or timed-out) as
     * those funds will be lost forever.
     */
    "fund_message": Anonymize<I739ltdlbnqckb>;
}>;
export type I5nmhnue5h41rg = {
    "messages": Array<Enum<{
        "Consensus": Anonymize<Ilqg87gbv0ge4>;
        "FraudProof": {
            "proof_1": Binary;
            "proof_2": Binary;
            "consensus_state_id": FixedSizeBinary<4>;
            "signer": Binary;
        };
        "Request": {
            "requests": Array<Anonymize<I7fuds5ki77feo>>;
            "proof": Anonymize<Ib5g0urqu4em42>;
            "signer": Binary;
        };
        "Response": {
            "datagram": Enum<{
                "Request": Anonymize<Icad0fteo3kki0>;
                "Response": Anonymize<Idh09c22dpqo2s>;
            }>;
            "proof": Anonymize<Ib5g0urqu4em42>;
            "signer": Binary;
        };
        "Timeout": Enum<{
            "Post": {
                "requests": Anonymize<Icad0fteo3kki0>;
                "timeout_proof": Anonymize<Ib5g0urqu4em42>;
            };
            "PostResponse": {
                "responses": Array<Anonymize<I69bjo2tm1bcq5>>;
                "timeout_proof": Anonymize<Ib5g0urqu4em42>;
            };
            "Get": {
                "requests": Anonymize<Icad0fteo3kki0>;
            };
        }>;
    }>>;
};
export type Ilqg87gbv0ge4 = {
    "consensus_proof": Binary;
    "consensus_state_id": FixedSizeBinary<4>;
    "signer": Binary;
};
export type I7fuds5ki77feo = {
    "source": Anonymize<Icctse4hug509d>;
    "dest": Anonymize<Icctse4hug509d>;
    "nonce": bigint;
    "from": Binary;
    "to": Binary;
    "timeout_timestamp": bigint;
    "body": Binary;
};
export type Ib5g0urqu4em42 = {
    "height": Anonymize<Ifm3n51g640vse>;
    "proof": Binary;
};
export type Icad0fteo3kki0 = Array<Enum<{
    "Post": Anonymize<I7fuds5ki77feo>;
    "Get": Anonymize<I96hf71evagbs4>;
}>>;
export type I96hf71evagbs4 = {
    "source": Anonymize<Icctse4hug509d>;
    "dest": Anonymize<Icctse4hug509d>;
    "nonce": bigint;
    "from": Binary;
    "keys": Anonymize<Itom7fk49o0c9>;
    "height": bigint;
    "context": Binary;
    "timeout_timestamp": bigint;
};
export type Idh09c22dpqo2s = Array<Enum<{
    "Post": Anonymize<I69bjo2tm1bcq5>;
    "Get": Anonymize<Irujvnm69ijog>;
}>>;
export type I69bjo2tm1bcq5 = {
    "post": Anonymize<I7fuds5ki77feo>;
    "response": Binary;
    "timeout_timestamp": bigint;
};
export type Irujvnm69ijog = {
    "get": Anonymize<I96hf71evagbs4>;
    "values": Array<{
        "key": Binary;
        "value"?: Anonymize<Iabpgqcjikia83>;
    }>;
};
export type I8416p6oh7m35t = {
    "message": {
        "consensus_state": Binary;
        "consensus_client_id": FixedSizeBinary<4>;
        "consensus_state_id": FixedSizeBinary<4>;
        "unbonding_period": bigint;
        "challenge_periods": Anonymize<I4eijtuhk9st5q>;
        "state_machine_commitments": Array<[Anonymize<Ieitt970a26jef>, {
            "commitment": Anonymize<Idqnu98dduluv8>;
            "height": bigint;
        }]>;
    };
};
export type I1cj3vacp7n158 = {
    "message": {
        "consensus_state_id": FixedSizeBinary<4>;
        "unbonding_period"?: Anonymize<I35p85j063s0il>;
        "challenge_periods": Anonymize<I4eijtuhk9st5q>;
    };
};
export type I739ltdlbnqckb = {
    "message": {
        "commitment": Enum<{
            "Request": FixedSizeBinary<32>;
            "Response": FixedSizeBinary<32>;
        }>;
        "amount": bigint;
    };
};
export type I41rj1hc4lfv1r = AnonymousEnum<{
    /**
     * This allows block builders submit parachain consensus proofs as inherents. If the
     * provided [`ConsensusMessage`] is not for a parachain, this call will fail.
     */
    "update_parachain_consensus": Anonymize<I5nk49fqq83rft>;
    /**
     * Add some new parachains to the parachains whitelist
     */
    "add_parachain": Anonymize<Ivalbtb85o2h0>;
    /**
     * Removes some parachains from the parachains whitelist
     */
    "remove_parachain": Anonymize<Ic8hk838gccoml>;
}>;
export type I5nk49fqq83rft = {
    "data": Anonymize<Ilqg87gbv0ge4>;
};
export type I9jm8tfci89hlj = AnonymousEnum<{
    /**
     * Teleports a registered asset
     * locks the asset and dispatches a request to token gateway on the destination
     */
    "teleport": Anonymize<I987mg4ok5pkoi>;
    /**
     * Set the token gateway address for specified chains
     */
    "set_token_gateway_addresses": Anonymize<Ifbem5vkius10c>;
    /**
     * Registers a multi-chain ERC6160 asset. The asset should not already exist.
     *
     * This works by dispatching a request to the TokenGateway module on each requested chain
     * to create the asset.
     * `native` should be true if this asset originates from this chain
     */
    "create_erc6160_asset": Anonymize<If3mej48mrh5qf>;
    /**
     * Registers a multi-chain ERC6160 asset. The asset should not already exist.
     *
     * This works by dispatching a request to the TokenGateway module on each requested chain
     * to create the asset.
     */
    "update_erc6160_asset": Anonymize<Ibn1504vropo5n>;
    "set_whitelist_addresses": Anonymize<Icjrp0nj828ep4>;
}>;
export type I987mg4ok5pkoi = {
    "params": {
        "asset_id": Anonymize<Iebirugq1dbhv6>;
        "destination": Anonymize<Icctse4hug509d>;
        "recepient": FixedSizeBinary<32>;
        "amount": bigint;
        "timeout": bigint;
        "token_gateway": Binary;
        "relayer_fee": bigint;
        "redeem": boolean;
        "call_data"?: Anonymize<Iabpgqcjikia83>;
    };
};
export type Ifbem5vkius10c = {
    "addresses": Array<[Anonymize<Icctse4hug509d>, Binary]>;
};
export type If3mej48mrh5qf = {
    "asset": {
        "local_id": Anonymize<Iebirugq1dbhv6>;
        "reg": {
            "name": Binary;
            "symbol": Binary;
            "chains": Anonymize<I9u6ntaauvq2d5>;
            "minimum_balance"?: Anonymize<I35p85j063s0il>;
        };
    };
    "native": boolean;
};
export type I9u6ntaauvq2d5 = Array<Anonymize<Icctse4hug509d>>;
export type Ibn1504vropo5n = {
    "asset": {
        "asset_id": FixedSizeBinary<32>;
        "add_chains": Anonymize<I9u6ntaauvq2d5>;
        "remove_chains": Anonymize<I9u6ntaauvq2d5>;
        "new_admins": Array<[Anonymize<Icctse4hug509d>, FixedSizeBinary<20>]>;
    };
};
export type Icjrp0nj828ep4 = {
    "addresses": Array<[Anonymize<Icctse4hug509d>, Anonymize<Itom7fk49o0c9>]>;
};
export type Ib150uqa18un23 = AnonymousEnum<{
    /**
     * Set user default fee currency
     * Parameters:
     * - `maybe_fee_currency`: The currency id to be set as the default fee currency.
     * If `None`, the user default fee currency will be removed.
     */
    "set_user_default_fee_currency": Anonymize<I9e33amtaq58km>;
    /**
     * Set universal fee currency order list
     * Parameters:
     * - `default_list`: The currency id list to be set as the universal fee currency order
     * list.
     */
    "set_default_fee_currency_list": Anonymize<Ia85jfgnieg7o0>;
    /**
     * Set universal fee currency order list
     * Parameters:
     * - `raw_call_name`: The raw call name to be set as the extra fee call.
     * - `fee_info`: The currency id, fee amount and receiver to be set as the extra fee.
     */
    "set_extra_fee": Anonymize<I4j50qh0n84qes>;
    /**
     * Dispatch EVM permit.
     * The main purpose of this function is to allow EVM accounts to pay for the transaction
     * fee in non-native currency by allowing them to self-dispatch pre-signed permit.
     * The EVM fee is paid in the currency set for the account.
     */
    "dispatch_permit": Anonymize<I92pum5p0t4pat>;
}>;
export type I9e33amtaq58km = {
    "currency_id"?: Anonymize<I1c99t35ku3g7a>;
};
export type I92pum5p0t4pat = {
    "from": FixedSizeBinary<20>;
    "to": FixedSizeBinary<20>;
    "value": Anonymize<I4totqt881mlti>;
    "data": Binary;
    "gas_limit": bigint;
    "deadline": Anonymize<I4totqt881mlti>;
    "v": number;
    "r": FixedSizeBinary<32>;
    "s": FixedSizeBinary<32>;
};
export type If7l7olca960be = AnonymousEnum<{
    "fund_retire": Anonymize<I666bl2fqjkejo>;
    "fund_end": Anonymize<I666bl2fqjkejo>;
    /**
     * Edit the configuration for an in-progress crowdloan.
     *
     * Can only be called by Root origin.
     */
    "edit": Anonymize<I50dt84l38nc68>;
    /**
     * Withdraw full balance of the parachain.
     * - `index`: The parachain to whose crowdloan the contribution was made.
     */
    "withdraw": Anonymize<I666bl2fqjkejo>;
    "refund": Anonymize<I87diq5b0qic4c>;
    "redeem": Anonymize<I1j6hllalj2epr>;
    /**
     * Remove a fund after the retirement period has ended and all funds have been returned.
     */
    "dissolve_refunded": Anonymize<I1d28k4v5qap3a>;
    /**
     * Remove a fund after the retirement period has ended and all funds have been returned.
     */
    "dissolve": Anonymize<I666bl2fqjkejo>;
    "buyback_vstoken_by_stable_pool": Anonymize<Iv901693moogd>;
}>;
export type I50dt84l38nc68 = {
    "index": number;
    "cap": bigint;
    "raised": bigint;
    "first_slot": number;
    "last_slot": number;
    "fund_status"?: (Anonymize<I3dj8kkj3l70n5>) | undefined;
};
export type I87diq5b0qic4c = {
    "index": number;
    "first_slot": number;
    "last_slot": number;
    "value": bigint;
};
export type I1j6hllalj2epr = {
    "index": number;
    "value": bigint;
};
export type I1d28k4v5qap3a = {
    "index": number;
    "first_slot": number;
    "last_slot": number;
};
export type Ia0qvep43jq2bs = AnonymousEnum<{
    "register_token_metadata": Anonymize<I1n28f4ceil09b>;
    "register_vtoken_metadata": Anonymize<Ieq8j5nmk3i7o0>;
    "register_location": Anonymize<Idocritbkcpmn3>;
    "force_set_location": Anonymize<Idocritbkcpmn3>;
    "update_currency_metadata": Anonymize<I110m02ast38uc>;
}>;
export type I1n28f4ceil09b = {
    "metadata": Anonymize<Ievgjq5dn6rae7>;
};
export type Ieq8j5nmk3i7o0 = {
    "token_id": number;
};
export type Idocritbkcpmn3 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "location": XcmVersionedLocation;
    "weight": Anonymize<I4q39t5hn830vp>;
};
export type I110m02ast38uc = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "asset_name"?: Anonymize<Iabpgqcjikia83>;
    "asset_symbol"?: Anonymize<Iabpgqcjikia83>;
    "asset_decimals"?: Anonymize<I4arjljr6dpflb>;
    "asset_minimal_balance"?: Anonymize<I35p85j063s0il>;
};
export type I9bg8u5ft729i0 = AnonymousEnum<{
    /**
     * Mint v_currency by transferring currency to entrance_account.
     * The minted v_currency will be deposited to the minter's account.
     * Parameters:
     * - `currency_id`: The currency to mint.
     * - `currency_amount`: The amount of currency to mint.
     * - `remark`: The remark of minting.
     * - `channel_id`: The channel id of minting.
     */
    "mint": Anonymize<I6l1cgblde3oca>;
    /**
     * Redeem currency by burning v_currency. But need to wait for the unlock period.
     * The redeemed currency will be transferred to the redeemer's account.
     * Parameters:
     * - `v_currency_id`: The v_currency to redeem.
     * - `v_currency_amount`: The amount of v_currency to redeem.
     */
    "redeem": Anonymize<Ib36ct6b1t9nk>;
    /**
     * Already redeemed currency by burning v_currency. But need to wait for the unlock period.
     * In unlock period, you call rebond to cancel the redeem.
     * Parameters:
     * - `currency_id`: The currency to rebond.
     * - `currency_amount`: The amount of currency to rebond. The amount should be less than or
     * equal to the redeem amount.
     */
    "rebond": Anonymize<Icmnhhde8qv456>;
    /**
     * Same function as Rebond. But need to provide unlock_id.
     * Parameters:
     * - `currency_id`: The currency to rebond.
     * - `unlock_id`: The unlock_id to rebond.
     */
    "rebond_by_unlock_id": Anonymize<Ibsdha57fv3ssk>;
    /**
     * Set the unlock duration for a currency.
     * Parameters:
     * - `currency_id`: The currency to set unlock duration.
     * - `unlock_duration`: The unlock duration to set.
     */
    "set_unlock_duration": Anonymize<I95h8ge6oaumen>;
    /**
     * Set the minimum mint amount for a currency.
     * Parameters:
     * - `currency_id`: The currency to set minimum mint amount.
     * - `minimum_amount`: The minimum mint amount to set.
     */
    "set_minimum_mint": Anonymize<I9gla6h44u54mh>;
    /**
     * Set the minimum redeem amount for a currency.
     * Parameters:
     * - `currency_id`: The currency to set minimum redeem amount.
     * - `minimum_amount`: The minimum redeem amount to set.
     */
    "set_minimum_redeem": Anonymize<I9gla6h44u54mh>;
    /**
     * Support a token to rebond.
     * Parameters:
     * - `currency_id`: The currency to support rebond.
     */
    "add_support_rebond_token": Anonymize<I6dlum3cbrie3d>;
    /**
     * Remove the support of a token to rebond.
     * Parameters:
     * - `currency_id`: The currency to remove support rebond.
     */
    "remove_support_rebond_token": Anonymize<I6dlum3cbrie3d>;
    /**
     * Set the fees for mint and redeem.
     * Parameters:
     * - `mint_fee`: The fee for mint.
     * - `redeem_fee`: The fee for redeem.
     */
    "set_fees": Anonymize<Idkdd97l7v4t7o>;
    /**
     * Set the hook iteration limit.
     * Parameters:
     * - `limit`: The hook iteration limit.
     */
    "set_hook_iteration_limit": Anonymize<Iamlqp3gs21baf>;
    /**
     * Set the total amount of tokens that are currently locked for unlocking.
     * Parameters:
     * - `currency_id`: The currency to set unlocking total.
     * - `currency_amount`: The total amount of tokens that are currently locked for unlocking.
     */
    "set_unlocking_total": Anonymize<Icmnhhde8qv456>;
    /**
     * Set the minimum time unit for a currency.
     * Parameters:
     * - `currency_id`: The currency to set minimum time unit.
     * - `time_unit`: The minimum time unit to set.
     */
    "set_min_time_unit": Anonymize<I4qh6vjmbpl1a6>;
    /**
     * Set the ongoing time unit for a currency.
     * Parameters:
     * - `currency_id`: The currency to set ongoing time unit.
     * - `time_unit`: The ongoing time unit to set.
     */
    "set_ongoing_time_unit": Anonymize<I4qh6vjmbpl1a6>;
    "mint_with_lock": Anonymize<I6l1cgblde3oca>;
    /**
     * Unlock the vtoken minted in an incentive mode
     * Parameters:
     * - `v_currency_id`: The v_currency to unlock.
     */
    "unlock_incentive_minted_vtoken": Anonymize<Ibanc56kjmq87v>;
    /**
     * Set the incentive coefficient for a vtoken when minted in an incentive mode
     * Parameters:
     * - `v_currency_id`: The v_currency to set incentive coefficient.
     * - `new_coef_op`: The new incentive coefficient to set.
     */
    "set_incentive_coef": Anonymize<I8c1fkgvmb93fs>;
    /**
     * Set the locked blocks for a vtoken when minted in an incentive mode
     * Parameters:
     * - `v_currency_id`: The v_currency to set locked blocks.
     * - `new_blockes_op`: The new locked blocks to set.
     */
    "set_vtoken_incentive_lock_blocks": Anonymize<I30ffpa0bknqur>;
    /**
     * Set Supported eths.
     * Parameters:
     * - `eths`: The supported eths.
     */
    "set_supported_eth": Anonymize<Ifsksfqf7mb05t>;
    /**
     * Set VToken issuance for exchange rate calculation.
     * This allows adjustment of the tracked vtoken issuance to handle cases where
     * vtokens might be burned on the Bifrost chain.
     * Parameters:
     * - `v_currency_id`: The v_currency to set issuance for.
     * - `adjustment`: The amount to adjust (positive to increase, negative to decrease).
     */
    "set_v_currency_issuance": Anonymize<I33nmjabk01dfi>;
}>;
export type I6l1cgblde3oca = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "currency_amount": bigint;
    "remark": Binary;
    "channel_id"?: Anonymize<I4arjljr6dpflb>;
};
export type Ib36ct6b1t9nk = {
    "currency_id"?: Anonymize<I1c99t35ku3g7a>;
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
    "v_currency_amount": bigint;
};
export type Ibsdha57fv3ssk = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "unlock_id": number;
};
export type Ibanc56kjmq87v = {
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
};
export type I8c1fkgvmb93fs = {
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
    "new_coef_op"?: Anonymize<I35p85j063s0il>;
};
export type I30ffpa0bknqur = {
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
    "new_blockes_op"?: Anonymize<I4arjljr6dpflb>;
};
export type I33nmjabk01dfi = {
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
    "adjustment": bigint;
};
export type I1e3qd0qm1op03 = AnonymousEnum<{
    /**
     * *****************************
     * ****** Outer Calls ******
     * *****************************
     *
     * Delegator initialization work. Generate a new delegator and return its ID.
     */
    "initialize_delegator": Anonymize<I8sqvh22141fr8>;
    /**
     * First time bonding some amount to a delegator.
     */
    "bond": Anonymize<I8vcp3s3t1r7ti>;
    /**
     * Bond extra amount to a delegator.
     */
    "bond_extra": Anonymize<I8vcp3s3t1r7ti>;
    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    "unbond": Anonymize<I8vcp3s3t1r7ti>;
    /**
     * Unbond all the active amount of a delegator.
     */
    "unbond_all": Anonymize<I94c4ugqtmf885>;
    /**
     * Rebond some unlocking amount to a delegator.
     */
    "rebond": Anonymize<I5g2ic5lk6jvap>;
    /**
     * Delegate to some validator set.
     */
    "delegate": Anonymize<I6aqijved7jgk9>;
    /**
     * Re-delegate existing delegation to a new validator set.
     */
    "undelegate": Anonymize<I6aqijved7jgk9>;
    /**
     * Re-delegate existing delegation to a new validator set.
     */
    "redelegate": Anonymize<I962vs596sggoi>;
    /**
     * Initiate payout for a certain delegator.
     */
    "payout": Anonymize<I8ln2e9k7mblim>;
    /**
     * Withdraw the due payout into free balance.
     */
    "liquidize": Anonymize<I1pqjsjhm82q1i>;
    /**
     * Initiate payout for a certain delegator.
     */
    "chill": Anonymize<I94c4ugqtmf885>;
    "transfer_back": Anonymize<I8rn283dnm6h0f>;
    "transfer_to": Anonymize<Ibu6i8jb58o30n>;
    "convert_asset": Anonymize<I8jm0ov76tih8s>;
    "increase_token_pool": Anonymize<Ic7aob2k1l1jfu>;
    "decrease_token_pool": Anonymize<Ic7aob2k1l1jfu>;
    "update_ongoing_time_unit": Anonymize<I4qh6vjmbpl1a6>;
    "refund_currency_due_unbond": Anonymize<I6dlum3cbrie3d>;
    "supplement_fee_reserve": Anonymize<Iecuv9eudhio5i>;
    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    "charge_host_fee_and_tune_vtoken_exchange_rate": Anonymize<Ieh9ab34fgqfvc>;
    /**
     * *****************************
     * ****** Storage Setters ******
     * *****************************
     * Update storage OperateOrigins<T>.
     */
    "set_operate_origin": Anonymize<I2i20t4file901>;
    /**
     * Update storage FeeSources<T>.
     */
    "set_fee_source": Anonymize<Inp8hn3mu8c5j>;
    /**
     * Update storage DelegatorsIndex2Multilocation<T>  DelegatorsMultilocation2Index<T>.
     */
    "add_delegator": Anonymize<I68o6mdp1r65np>;
    /**
     * Update storage DelegatorsIndex2Multilocation<T>  DelegatorsMultilocation2Index<T>.
     */
    "remove_delegator": Anonymize<Iaba972j3va7k>;
    /**
     * Update storage Validators<T>.
     */
    "add_validator": Anonymize<Iaba972j3va7k>;
    /**
     * Update storage Validators<T>.
     */
    "remove_validator": Anonymize<Iaba972j3va7k>;
    /**
     * Update storage ValidatorsByDelegator<T>.
     */
    "set_validators_by_delegator": Anonymize<Iffj0b5herq802>;
    /**
     * Update storage DelegatorLedgers<T>.
     */
    "set_delegator_ledger": Anonymize<I8ja7ceebpen3k>;
    /**
     * Update storage MinimumsAndMaximums<T>.
     */
    "set_minimums_and_maximums": Anonymize<Icikcphjk1igug>;
    /**
     * Update storage Delays<T>.
     */
    "set_currency_delays": Anonymize<Ibnl8raecejsmo>;
    /**
     * Set HostingFees storage.
     */
    "set_hosting_fees": Anonymize<I1ufkvgdurghbk>;
    /**
     * Set  CurrencyTuneExchangeRateLimit<T> storage.
     */
    "set_currency_tune_exchange_rate_limit": Anonymize<I1q1g69il2fc15>;
    /**
     * Set  OngoingTimeUnitUpdateInterval<T> storage.
     */
    "set_ongoing_time_unit_update_interval": Anonymize<I9ltv8jlv2map8>;
    "add_supplement_fee_account_to_whitelist": Anonymize<Iaba972j3va7k>;
    "remove_supplement_fee_account_from_whitelist": Anonymize<Iaba972j3va7k>;
    /**
     * ********************************************************************
     * *************Outer Confirming Xcm queries functions ****************
     * ********************************************************************
     */
    "confirm_delegator_ledger_query_response": Anonymize<Idlhavidu7pq4f>;
    "fail_delegator_ledger_query_response": Anonymize<Idlhavidu7pq4f>;
    "confirm_validators_by_delegator_query_response": Anonymize<Idlhavidu7pq4f>;
    "fail_validators_by_delegator_query_response": Anonymize<Idlhavidu7pq4f>;
    "confirm_delegator_ledger": Anonymize<I203ivdv9ll218>;
    "confirm_validators_by_delegator": Anonymize<I203ivdv9ll218>;
    /**
     * Reset the whole storage Validators<T>.
     */
    "reset_validators": Anonymize<Id37b9l6bk2ii9>;
    /**
     * Reset the whole storage Validator_boost_list<T>.
     */
    "set_validator_boost_list": Anonymize<Id37b9l6bk2ii9>;
    "add_to_validator_boost_list": Anonymize<Iaba972j3va7k>;
    /**
     * Update storage Validator_boost_list<T>.
     */
    "remove_from_validator_boot_list": Anonymize<Iaba972j3va7k>;
    "convert_treasury_vtoken": Anonymize<I58caqa2hcp37r>;
    "clean_outdated_validator_boost_list": Anonymize<I9thv3jvjv8nr9>;
}>;
export type I8sqvh22141fr8 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "delegator_location"?: Anonymize<Ia9cgf4r40b26h>;
};
export type I8vcp3s3t1r7ti = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
    "amount": bigint;
    "validator"?: Anonymize<Ia9cgf4r40b26h>;
    "weight_and_fee"?: Anonymize<I84n0ktbscl3e5>;
};
export type I84n0ktbscl3e5 = (Anonymize<I1js2aelrc7fbg>) | undefined;
export type I94c4ugqtmf885 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
    "weight_and_fee"?: Anonymize<I84n0ktbscl3e5>;
};
export type I5g2ic5lk6jvap = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
    "validator"?: Anonymize<Ia9cgf4r40b26h>;
    "amount"?: Anonymize<I35p85j063s0il>;
    "weight_and_fee"?: Anonymize<I84n0ktbscl3e5>;
};
export type I6aqijved7jgk9 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
    "targets": Anonymize<Ia88a8r9e89e2p>;
    "weight_and_fee"?: Anonymize<I84n0ktbscl3e5>;
};
export type I962vs596sggoi = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
    "targets"?: Anonymize<Ia866hqrh833qa>;
    "weight_and_fee"?: Anonymize<I84n0ktbscl3e5>;
};
export type I8ln2e9k7mblim = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
    "validator": Anonymize<I4c0s5cioidn76>;
    "when"?: Anonymize<I6o0vlee7cr3h2>;
    "weight_and_fee"?: Anonymize<I84n0ktbscl3e5>;
};
export type I1pqjsjhm82q1i = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
    "when"?: Anonymize<I6o0vlee7cr3h2>;
    "validator"?: Anonymize<Ia9cgf4r40b26h>;
    "amount"?: Anonymize<I35p85j063s0il>;
    "weight_and_fee"?: Anonymize<I84n0ktbscl3e5>;
};
export type I8rn283dnm6h0f = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "from": Anonymize<I4c0s5cioidn76>;
    "to": Anonymize<I4c0s5cioidn76>;
    "amount": bigint;
    "weight_and_fee"?: Anonymize<I84n0ktbscl3e5>;
};
export type I8jm0ov76tih8s = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
    "amount": bigint;
    "if_from_currency": boolean;
    "weight_and_fee"?: Anonymize<I84n0ktbscl3e5>;
};
export type Iecuv9eudhio5i = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "dest": Anonymize<I4c0s5cioidn76>;
};
export type Ieh9ab34fgqfvc = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "pool_value": bigint;
    "delegator_value": bigint;
    "who"?: Anonymize<Ia9cgf4r40b26h>;
};
export type I2i20t4file901 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who"?: Anonymize<Ihfphjolmsqq1>;
};
export type I68o6mdp1r65np = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "index": number;
    "who": Anonymize<I4c0s5cioidn76>;
};
export type Iffj0b5herq802 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
    "validators": Anonymize<Ia88a8r9e89e2p>;
};
export type I8ja7ceebpen3k = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "who": Anonymize<I4c0s5cioidn76>;
    "ledger"?: Anonymize<I9plp53g8mj92d>;
};
export type Icikcphjk1igug = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "constraints"?: Anonymize<Iavcon0kdmah9g>;
};
export type Ibnl8raecejsmo = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "maybe_delays"?: Anonymize<I2fl7rg40jnqc3>;
};
export type I1ufkvgdurghbk = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "maybe_fee_set"?: Anonymize<Ibpetveugk1l63>;
};
export type I1q1g69il2fc15 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "maybe_tune_exchange_rate_limit"?: Anonymize<Iep7au1720bm0e>;
};
export type I9ltv8jlv2map8 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "maybe_interval"?: Anonymize<I4arjljr6dpflb>;
};
export type Idlhavidu7pq4f = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "query_id": bigint;
};
export type I203ivdv9ll218 = {
    "query_id": bigint;
    "response": XcmV3Response;
};
export type I58caqa2hcp37r = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "amount": bigint;
};
export type I9thv3jvjv8nr9 = {
    "token": Anonymize<Iebirugq1dbhv6>;
    "page": number;
};
export type Idttp484aaigqv = AnonymousEnum<{
    /**
     * Sets the xcm_dest_weight and fee for XCM operation of XcmInterface.
     *
     * Parameters:
     * - `updates`: vec of tuple: (XcmOperationType, WeightChange, FeeChange).
     */
    "update_xcm_dest_weight_and_fee": Anonymize<I5lkkn2erim0mo>;
    "transfer_ethereum_assets": Anonymize<Id57q643bc33er>;
}>;
export type I5lkkn2erim0mo = {
    "updates": Array<[Anonymize<Iebirugq1dbhv6>, Anonymize<I8vi5hrpkv8lci>, Anonymize<I4q39t5hn830vp>, bigint]>;
};
export type Id57q643bc33er = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "amount": bigint;
    "to": FixedSizeBinary<20>;
};
export type If0v6q8a012l7o = AnonymousEnum<{
    "vsbond_convert_to_vstoken": Anonymize<I3tgr4mij0dq9t>;
    "vstoken_convert_to_vsbond": Anonymize<Ic6tc8uub7lssk>;
    "set_exchange_fee": Anonymize<I7dim4s22d4cc>;
    "set_exchange_rate": Anonymize<I9adoavqh7j1qm>;
    "set_relaychain_lease": Anonymize<I2cnb8psb4ovvm>;
}>;
export type I3tgr4mij0dq9t = {
    "vs_bond_currency_id": Anonymize<Iebirugq1dbhv6>;
    "vsbond_amount": bigint;
    "minimum_vstoken": bigint;
};
export type Ic6tc8uub7lssk = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "vstoken_amount": bigint;
    "minimum_vsbond": bigint;
};
export type I57rd76ok8gbu6 = AnonymousEnum<{
    /**
     * Create a farming pool.
     *
     * The state of the pool will be set to `Ongoing` if the current block number is greater
     * than or equal to the field `after_block_to_start` or the total shares of the pool is
     * greater than or equal to the field `min_deposit_to_start`.
     *
     * - `tokens_proportion`: The proportion of each token in the pool.
     * - `basic_rewards`: The basic reward of each token in the pool.
     * - `gauge_init`: The initial gauge pool info.
     * - `min_deposit_to_start`: The minimum deposit to start the pool.
     * - `after_block_to_start`: The block number to start the pool.
     * - `withdraw_limit_time`: The block number to limit the withdraw.
     * - `claim_limit_time`: The block number to limit the claim.
     * - `withdraw_limit_count`: The count to limit the withdraw.
     */
    "create_farming_pool": Anonymize<I3frfca3bu3qda>;
    /**
     * Charge the pool.
     *
     * Transfer the rewards from the exchanger to the pool. It will charge the rewards to the
     * gauge pool if the `if_gauge` is true, otherwise it will charge the rewards to the
     * farming pool.
     *
     * - `pid`: The pool id.
     * - `rewards`: The rewards to charge.
     * - `if_gauge`: If the rewards are for the gauge pool.
     */
    "charge": Anonymize<I6bbnnm10sc5a6>;
    /**
     * Deposit the pool.
     *
     * Mint the share to the exchanger and transfer the tokens to the pool. The state of the
     * pool should be `Ongoing` or `Charged`. The current block number should be greater than
     * or equal to the field `after_block_to_start` if the state of the pool is `Charged`.
     *
     * - `pid`: The pool id.
     * - `add_value`: The value to deposit.
     */
    "deposit": Anonymize<I1ecpbq2c6b4si>;
    /**
     * Withdraw from the pool.
     *
     * The state of the pool should be `Ongoing`, `Charged` or `Dead`.
     * User's withdraw limit count should be less than the field `withdraw_limit_count`.
     * It will remove the share from the user, but not transfer the tokens to the user
     * immediately.
     *
     * - `pid`: The pool id.
     * - `remove_value`: The value to withdraw.
     */
    "withdraw": Anonymize<Ii1jr958aef3t>;
    /**
     * Claim the rewards from the pool.
     *
     * The state of the pool should be `Ongoing` or `Dead`.
     * The user should not claim the rewards within the field `claim_limit_time`.
     * It will claim the rewards to the user, and transfer the tokens to the user immediately.
     *
     * - `pid`: The pool id.
     */
    "claim": Anonymize<Ier970hnn9pgrj>;
    /**
     * Withdraw the claim from the pool.
     *
     * It will immediately transfer the withdrawable tokens to the user.
     *
     * - `pid`: The pool id.
     */
    "withdraw_claim": Anonymize<Ier970hnn9pgrj>;
    /**
     * Force retire the pool.
     *
     * The state of the pool should be `Dead`.
     * It will retire the pool and transfer the withdrawable tokens to the users.
     *
     * - `pid`: The pool id.
     */
    "force_retire_pool": Anonymize<Ier970hnn9pgrj>;
    /**
     * Set the retire limit.
     *
     * - `limit`: The retire limit.
     */
    "set_retire_limit": Anonymize<Iamlqp3gs21baf>;
    /**
     * Close the pool.
     *
     * Change the state of the pool to `Dead` before retiring the pool.
     *
     * - `pid`: The pool id.
     */
    "close_pool": Anonymize<Ier970hnn9pgrj>;
    /**
     * Reuse retired pools
     *
     * - `pid`: The pool id.
     * - `basic_rewards`: The basic reward of each token in the pool.
     * - `min_deposit_to_start`: The minimum deposit to start the pool.
     * - `after_block_to_start`: The block number to start the pool.
     * - `withdraw_limit_time`: The block number to limit the withdraw.
     * - `claim_limit_time`: The block number to limit the claim.
     * - `withdraw_limit_count`: The count to limit the withdraw.
     * - `gauge_init`: The initial gauge pool info.
     */
    "reset_pool": Anonymize<I7ee2c04njh4lr>;
    /**
     * Kill the pool after retired.
     *
     * - `pid`: The pool id.
     */
    "kill_pool": Anonymize<Ier970hnn9pgrj>;
    /**
     * Edit the pool at the state of `Retired`, `Ongoing`, `Charged` or `UnCharged`.
     */
    "edit_pool": Anonymize<Ido82tngjj5jid>;
    /**
     * Force claim the rewards from the gauge pool.
     *
     * Control origin can force claim the rewards from the gauge pool to the users.
     *
     * - `gid`: The gauge pool id.
     */
    "force_gauge_claim": Anonymize<Ial5va0b0vs25o>;
    /**
     * Add whitelist and take effect immediately
     *
     * - `whitelist`: The whitelist to add
     */
    "add_boost_pool_whitelist": Anonymize<Icm2mv7tlmp1c3>;
    /**
     * Whitelist for next round in effect
     *
     * - `whitelist`: The whitelist for the next round
     */
    "set_next_round_whitelist": Anonymize<Icm2mv7tlmp1c3>;
    /**
     * Vote for the pool
     *
     * - `vote_list`: The vote list for the pool
     */
    "vote": Anonymize<I821qafgn89idd>;
    /**
     * Start the boost round
     *
     * - `round_length`: The length of the round
     */
    "start_boost_round": Anonymize<Icn7fuqv1aq0de>;
    /**
     * Force end of boost round
     */
    "end_boost_round": undefined;
    /**
     * Charge the boost rewards to the FarmingBoost account
     *
     * - `rewards`: The rewards to charge
     */
    "charge_boost": Anonymize<Ifift2upjktcjs>;
    "refresh": undefined;
}>;
export type I3frfca3bu3qda = {
    "tokens_proportion": Anonymize<I7p4is2lmk8vmo>;
    "basic_rewards": Anonymize<I2dbamvpq4935>;
    "gauge_init"?: Anonymize<Icbc2a9dedbcmj>;
    "min_deposit_to_start": bigint;
    "after_block_to_start": number;
    "withdraw_limit_time": number;
    "claim_limit_time": number;
    "withdraw_limit_count": number;
};
export type Icbc2a9dedbcmj = (Anonymize<I2dbamvpq4935>) | undefined;
export type I6bbnnm10sc5a6 = {
    "pid": number;
    "rewards": Anonymize<I2dbamvpq4935>;
};
export type I1ecpbq2c6b4si = {
    "pid": number;
    "add_value": bigint;
};
export type Ii1jr958aef3t = {
    "pid": number;
    "remove_value"?: Anonymize<I35p85j063s0il>;
};
export type I7ee2c04njh4lr = {
    "pid": number;
    "basic_rewards"?: Anonymize<Icbc2a9dedbcmj>;
    "min_deposit_to_start"?: Anonymize<I35p85j063s0il>;
    "after_block_to_start"?: Anonymize<I4arjljr6dpflb>;
    "withdraw_limit_time"?: Anonymize<I4arjljr6dpflb>;
    "claim_limit_time"?: Anonymize<I4arjljr6dpflb>;
    "withdraw_limit_count"?: Anonymize<I4arjljr6dpflb>;
    "gauge_init"?: Anonymize<Icbc2a9dedbcmj>;
};
export type Ido82tngjj5jid = {
    "pid": number;
    "basic_rewards"?: Anonymize<Icbc2a9dedbcmj>;
    "withdraw_limit_time"?: Anonymize<I4arjljr6dpflb>;
    "claim_limit_time"?: Anonymize<I4arjljr6dpflb>;
    "gauge_basic_rewards"?: Anonymize<Icbc2a9dedbcmj>;
    "withdraw_limit_count"?: Anonymize<I4arjljr6dpflb>;
};
export type Icm2mv7tlmp1c3 = {
    "whitelist": Anonymize<Icgljjb6j82uhn>;
};
export type I821qafgn89idd = {
    "vote_list": Anonymize<Iep4uo61810hfs>;
};
export type Ifift2upjktcjs = {
    "rewards": Anonymize<I2dbamvpq4935>;
};
export type I6oggfr891dpc2 = AnonymousEnum<{
    /**
     * Update token configtake effect when next round begins
     */
    "token_config": Anonymize<I4n73j5spt03js>;
    /**
     * Update token configtake effect when next round begins
     */
    "delete_token": Anonymize<Ibmoqhjadutned>;
    /**
     * refresh token infoquery farming pallet, and update TokenInfo, change to new
     * configignore exec_delay, execute immediately
     */
    "refresh_token_info": Anonymize<Ibmoqhjadutned>;
    /**
     * payout to receiving account
     */
    "payout": Anonymize<Ibmoqhjadutned>;
}>;
export type I4n73j5spt03js = {
    "token": Anonymize<Iebirugq1dbhv6>;
    "exec_delay"?: Anonymize<I4arjljr6dpflb>;
    "system_stakable_base"?: Anonymize<I35p85j063s0il>;
};
export type I1pd23tvu4hvk8 = AnonymousEnum<{
    /**
     * Create a distribution
     *
     * - `token_type`: The token types involved in this distribution
     * - `tokens_proportion`: The proportion of the token distribution
     * - `if_auto`: Whether the distribution is automatic
     */
    "create_distribution": Anonymize<Ieob0gouehce57>;
    /**
     * Edit the distribution
     *
     * - `distribution_id`: Distribution ID
     * - `token_type`: The token types involved in this distribution
     * - `tokens_proportion`: The proportion of the token distribution
     * - `if_auto`: Whether the distribution is automatic
     */
    "edit_distribution": Anonymize<I8eo9r9va149i7>;
    /**
     * Set the era length
     *
     * - `era_length`: The interval between distribution executions
     */
    "set_era_length": Anonymize<Iaeor8vejoqk4d>;
    /**
     * Execute the distribution
     *
     * - `distribution_id`: Distribution ID
     */
    "execute_distribute": Anonymize<I6d2fsv919ackd>;
    /**
     * Delete the distribution
     *
     * - `distribution_id`: Distribution ID
     */
    "delete_distribution": Anonymize<I6d2fsv919ackd>;
    /**
     * USD Standard Accumulation Logic Configuration, can be overridden by the governance
     *
     * - `distribution_id`: Distribution ID
     * - `target_value`: Target's USD based value
     * - `interval`: The interval of the cumulative clearing operation
     * - `target_account_id`: When the cumulative dollar value falls below the target_value,
     * the funds will be transferred to the target_account_id
     */
    "set_usd_config": Anonymize<I65sao41nc2u5n>;
}>;
export type Ieob0gouehce57 = {
    "token_type": Anonymize<I6ae21pstqk9et>;
    "tokens_proportion": Anonymize<I205qrookusi3d>;
    "if_auto": boolean;
};
export type I8eo9r9va149i7 = {
    "distribution_id": number;
    "token_type"?: (Anonymize<I6ae21pstqk9et>) | undefined;
    "tokens_proportion"?: (Anonymize<I205qrookusi3d>) | undefined;
    "if_auto"?: Anonymize<I8ie0dco0kcuq5>;
};
export type Iaeor8vejoqk4d = {
    "era_length": number;
};
export type I65sao41nc2u5n = {
    "distribution_id": number;
    "target_value": bigint;
    "interval": number;
    "target_account_id": SS58String;
};
export type If5cqas1ocd5ig = AnonymousEnum<{
    /**
     * Destroy some balance from an account and issue cross-out event.
     */
    "cross_out": Anonymize<Ic7aob2k1l1jfu>;
    "register_linked_account": Anonymize<Idraqa5k2q8rna>;
    "change_outer_linked_account": Anonymize<Iclh6ip7gld2up>;
    "deregister_currency_for_cross_in_out": Anonymize<I6dlum3cbrie3d>;
    "add_to_register_whitelist": Anonymize<Iapol5cojcq8jr>;
    "remove_from_register_whitelist": Anonymize<Iapol5cojcq8jr>;
    "set_crossing_minimum_amount": Anonymize<Iarqih3rei93nj>;
}>;
export type Iclh6ip7gld2up = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "foreign_location": Anonymize<I4c0s5cioidn76>;
    "account": SS58String;
};
export type Ib5206vm911emu = AnonymousEnum<{
    /**
     * Set configuration.
     *
     * Set the minimum number of tokens and minimum time that users can lock.
     *
     * - `min_mint`: The minimum mint balance
     * - `min_block`: The minimum lockup time
     */
    "set_config": Anonymize<Iadml5h1l6pdhd>;
    /**
     * Create a lock.
     *
     * If the signer already has a position, the position will not be extended. it will be
     * created a new position until the maximum number of positions is reached.
     *
     * - `value`: The amount of tokens to lock
     * - `unlock_time`: The lockup time
     */
    "create_lock": Anonymize<I4q8h00pii12o3>;
    /**
     * Increase the lock amount.
     *
     * If the signer does not have the position, it doesn't work and the position will not be
     * created. Only the position existed and owned by the signer, the locking amount will be
     * increased.
     *
     * - `position`: The lock position
     * - `value`: The amount of tokens to increase
     */
    "increase_amount": Anonymize<I5odhhedphq5gh>;
    /**
     * Increase the unlock time.
     *
     * If the signer does not have the position, it doesn't work and the position will not be
     * created. Only the position existed and owned by the signer, the locking time will be
     * increased.
     *
     * - `position`: The lock position
     * - `time`: Additional lock time
     */
    "increase_unlock_time": Anonymize<Iej62b4o01n76s>;
    /**
     * Withdraw the locked tokens after unlock time.
     *
     * - `position`: The lock position
     */
    "withdraw": Anonymize<Icni4v52b04265>;
    /**
     * Notify rewards.
     *
     * Set the incentive controller and rewards token type for future round. Reward duration
     * should be one round interval. It will notify the rewards from incentive controller to
     * the system account and start a new round immediately, and the next round will auto start
     * at now + rewards_duration.
     *
     * - `incentive_from`: The incentive controller
     * - `rewards_duration`: The rewards duration
     * - `rewards`: The rewards
     */
    "notify_rewards": Anonymize<I30l5icl49p3tp>;
    /**
     * Get rewards for the signer.
     */
    "get_rewards": undefined;
    /**
     * Fast unlocking, handling fee applies
     *
     * When users want to redeem early regardless of cost, they can use this call.
     *
     * - `position`: The lock position
     */
    "redeem_unlock": Anonymize<Icni4v52b04265>;
    /**
     * Set markup configurations.
     *
     * - `currency_id`: The token type
     * - `markup`: The markup coefficient
     * - `hardcap`: The markup hardcap
     */
    "set_markup_coefficient": Anonymize<I53fuja41j7ro>;
    /**
     * Deposit markup.
     *
     * Deposit the token to the system account for the markup.
     *
     * - `currency_id`: The token type
     * - `value`: The amount of tokens to deposit
     */
    "deposit_markup": Anonymize<I6e7p4l5e6t7n6>;
    /**
     * Withdraw markup.
     *
     * Withdraw the token from the system account for the markup.
     *
     * - `currency_id`: The token type
     */
    "withdraw_markup": Anonymize<I6dlum3cbrie3d>;
    /**
     * Refresh the markup.
     *
     * Any user can call this function to refresh the markup coefficient. The maximum number of
     * accounts that can be refreshed in one execution is MarkupRefreshLimit.
     *
     * - `currency_id`: The token type
     */
    "refresh": Anonymize<I6dlum3cbrie3d>;
}>;
export type Iadml5h1l6pdhd = {
    "min_mint"?: Anonymize<I35p85j063s0il>;
    "min_block"?: Anonymize<I4arjljr6dpflb>;
    "max_positions_per_block"?: Anonymize<I4arjljr6dpflb>;
};
export type I4q8h00pii12o3 = {
    "value": bigint;
    "unlock_time": number;
};
export type I5odhhedphq5gh = {
    "position": bigint;
    "value": bigint;
};
export type Iej62b4o01n76s = {
    "position": bigint;
    "time": number;
};
export type Icni4v52b04265 = {
    "position": bigint;
};
export type I30l5icl49p3tp = {
    "incentive_from": SS58String;
    "rewards_duration"?: Anonymize<I4arjljr6dpflb>;
    "rewards": Anonymize<I6ae21pstqk9et>;
};
export type I53fuja41j7ro = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "markup": bigint;
    "hardcap": bigint;
    "rwi": bigint;
};
export type I6e7p4l5e6t7n6 = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "value": bigint;
};
export type I5jedbss0q227o = AnonymousEnum<{
    /**
     * vtoken mint and transfer to target chain
     * Parameters:
     * - `currency_id`: The currency id of the token to be minted
     * - `currency_amount`: The amount of the token to be minted
     * - `target_chain`: The target chain to transfer the token to
     * - `remark`: The remark of the order
     * - `channel_id`: The channel id of the order
     */
    "mint": Anonymize<Ib400dopju2fto>;
    /**
     * vtoken redeem and transfer to target chain
     * Parameters:
     * - `v_currency_id`: The currency id of the vtoken to be redeemed
     * - `v_currency_amount`: The amount of the vtoken to be redeemed
     * - `target_chain`: The target chain to transfer the token to
     */
    "redeem": Anonymize<I1v5t6dj5g22i2>;
    /**
     * Add the contract account to the whitelist
     * Parameters:
     * - `support_chain`: The support chain of Slpx
     * - `contract_address`: The contract address of the contract
     */
    "add_whitelist": Anonymize<I7idb2fg10ips5>;
    /**
     * Remove the contract account from the whitelist
     * Parameters:
     * - `support_chain`: The support chain of Slpx
     * - `contract_address`: The contract address of the contract
     */
    "remove_whitelist": Anonymize<I7idb2fg10ips5>;
    /**
     * Set the execution fee for the currency
     * Parameters:
     * - `currency_id`: The currency id of the token
     * - `execution_fee`: The execution fee of the token
     */
    "set_execution_fee": Anonymize<I7u9oegj4csj51>;
    /**
     * Set the transfer fee for the currency
     * Parameters:
     * - `support_chain`: The support chain of Slpx
     * - `transfer_to_fee`: The transfer fee of the token
     */
    "set_transfer_to_fee": Anonymize<I6s65kicknm51n>;
    /**
     * Set the currency to support the Ethereum call switch
     * Parameters:
     * - `currency_id`: The currency id of the token
     * - `is_support`: Whether to support the Ethereum call switch
     */
    "support_xcm_oracle": Anonymize<Ifuaakr3i6qaje>;
    /**
     * Set the Ethereum call configuration
     * Parameters:
     * - `xcm_fee`: The XCM fee of Sending Xcm
     * - `xcm_weight`: The XCM weight of Sending Xcm
     * - `period`: The period of Sending Xcm
     * - `contract`: The address of XcmOracle
     */
    "set_xcm_oracle_configuration": Anonymize<I792urf76hgnm9>;
    /**
     * Set the currency to support the XCM fee
     * Parameters:
     * - `currency_id`: The currency id of the token
     * - `is_support`: Whether to support the XCM fee
     */
    "set_currency_support_xcm_fee": Anonymize<Ifuaakr3i6qaje>;
    /**
     * Set the delay block, Order will be executed after the delay block.
     * Parameters:
     * - `delay_block`: The delay block
     */
    "set_delay_block": Anonymize<I7j4i782lpafvm>;
    /**
     * Force add order
     * Parameters:
     * - `source_chain_caller`: The caller of the source chain
     * - `bifrost_chain_caller`: The caller of the bifrost chain
     * - `currency_id`: The currency id of the token
     * - `target_chain`: The target chain to transfer the token to
     * - `remark`: The remark of the order
     * - `channel_id`: The channel id of the order
     */
    "force_add_order": Anonymize<If6ndkvmfijbvo>;
    /**
     * vtoken mint and transfer to target chain
     * Parameters:
     * - `evm_caller`: The caller of the EVM contract
     * - `currency_id`: The currency id of the token to be minted
     * - `target_chain`: The target chain to transfer the token to
     * - `remark`: The remark of the order
     * - `channel_id`: The channel id of the order
     */
    "mint_with_channel_id": Anonymize<I3tnke0lsl8p00>;
    /**
     * EVM create order
     * Parameters:
     * - `source_chain_caller`: The caller of the source chain
     * - `source_chain_id`: The source chain id
     * - `source_chain_block_number`: The source chain block number
     * - `currency_id`: The currency id of the token
     * - `currency_amount`: The currency amount of the token
     * - `send_to`: The target chain to transfer the token to
     * - `remark`: The remark of the order
     * - `channel_id`: The channel id of the order
     */
    "evm_create_order": Anonymize<I9guvk97s8codm>;
    /**
     * Parameters:
     * - `chain_id`: The chain id of destination chain
     * - `to`: The address of destination contract
     * - `timeout`: The timeout of the oracle
     * - `payer`: The payer of the oracle
     * - `fee`: The fee of the oracle
     * - `tokens`: The tokens of the oracle
     */
    "set_hyperbridge_oracle": Anonymize<In9igsl3fgg3q>;
    /**
     * Set Hydration Oracle Config
     * Parameters:
     * - `period`: The period of Sending Xcm
     * - `tokens`: The tokens of the oracle
     */
    "set_hydration_oracle": Anonymize<I8lpggdq99dmfc>;
    /**
     * Execute Async Mint
     */
    "async_mint": Anonymize<I5q1a9s86bsjba>;
    /**
     * Update Async Mint configuration
     */
    "update_async_mint_config": Anonymize<If9ob1e8r14nrm>;
    /**
     * Correct vToken reserves for Hyperbridge
     *
     * Parameters:
     * - `chain_id`: The target chain ID for correction
     * - `currency_id`: The currency ID of the vToken
     * - `amount`: The amount of vToken to mint and transfer
     */
    "force_increase_hyperbridge_reserve": Anonymize<I8jbqjsr1ivn77>;
    /**
     * Set Hyperbridge fee exempt accounts
     *
     * Parameters:
     * - `accounts`: The accounts to exempt from Hyperbridge fee
     */
    "set_hyperbridge_fee_exempt_accounts": Anonymize<I9gel4bv68gacj>;
}>;
export type Ib400dopju2fto = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "currency_amount": bigint;
    "target_chain": Anonymize<Ibi4k1clc8t3vv>;
    "remark": Binary;
    "channel_id": number;
};
export type I1v5t6dj5g22i2 = {
    "maybe_currency_id"?: Anonymize<I1c99t35ku3g7a>;
    "v_currency_id": Anonymize<Iebirugq1dbhv6>;
    "v_currency_amount": bigint;
    "target_chain": Anonymize<Ibi4k1clc8t3vv>;
};
export type I7idb2fg10ips5 = {
    "support_chain": Anonymize<I3em9l2q88o7if>;
    "contract_address": FixedSizeBinary<20>;
};
export type If6ndkvmfijbvo = {
    "source_chain_caller": Anonymize<Ibbodv9tjmq4ua>;
    "bifrost_chain_caller": SS58String;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "target_chain": Anonymize<Ibi4k1clc8t3vv>;
    "remark": Binary;
    "channel_id": number;
};
export type I3tnke0lsl8p00 = {
    "evm_caller": FixedSizeBinary<20>;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "target_chain": Anonymize<Ibi4k1clc8t3vv>;
    "remark": Binary;
    "channel_id": number;
};
export type I9guvk97s8codm = {
    "source_chain_caller": FixedSizeBinary<20>;
    "source_chain_id": bigint;
    "source_chain_block_number": bigint;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "currency_amount": bigint;
    "send_to": Anonymize<Ibi4k1clc8t3vv>;
    "remark": Binary;
    "channel_id": number;
};
export type In9igsl3fgg3q = {
    "chain_id": number;
    "to": FixedSizeBinary<20>;
    "timeout": bigint;
    "period": number;
    "tokens": Anonymize<Ifbg8drm29v6va>;
    "payer": SS58String;
    "fee": bigint;
};
export type I8lpggdq99dmfc = {
    "period": number;
    "weight": Anonymize<I4q39t5hn830vp>;
    "fee": bigint;
    "tokens": Anonymize<Ic4m824gh8aavk>;
};
export type I5q1a9s86bsjba = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "currency_amount": bigint;
    "from_chain_id": number;
    "slpx_input_v_currency_amount": bigint;
};
export type I8jbqjsr1ivn77 = {
    "from_chain_id": number;
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "additional_v_currency_amount": bigint;
};
export type I9gel4bv68gacj = {
    "accounts": Anonymize<Ia2lhg7l2hilo3>;
};
export type Ieblk40f65bn0b = AnonymousEnum<{
    /**
     * Introduce a new member.
     *
     * - `origin`: Must be the `AddOrigin`.
     * - `who`: Account of non-member which will become a member.
     *
     * Weight: `O(1)`
     */
    "add_member": Anonymize<Icu8seopr711dn>;
    /**
     * Increment the rank of an existing member by one.
     *
     * - `origin`: Must be the `PromoteOrigin`.
     * - `who`: Account of existing member.
     *
     * Weight: `O(1)`
     */
    "promote_member": Anonymize<Icu8seopr711dn>;
    /**
     * Decrement the rank of an existing member by one. If the member is already at rank zero,
     * then they are removed entirely.
     *
     * - `origin`: Must be the `DemoteOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     *
     * Weight: `O(1)`, less if the member's index is highest in its rank.
     */
    "demote_member": Anonymize<Icu8seopr711dn>;
    /**
     * Remove the member entirely.
     *
     * - `origin`: Must be the `RemoveOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     * - `min_rank`: The rank of the member or greater.
     *
     * Weight: `O(min_rank)`.
     */
    "remove_member": Anonymize<Iddd2a11b8876r>;
    /**
     * Add an aye or nay vote for the sender to the given proposal.
     *
     * - `origin`: Must be `Signed` by a member account.
     * - `poll`: Index of a poll which is ongoing.
     * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
     *
     * Transaction fees are be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     *
     * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
     */
    "vote": Anonymize<I8bvk21lpmah75>;
    /**
     * Remove votes from the given poll. It must have ended.
     *
     * - `origin`: Must be `Signed` by any account.
     * - `poll_index`: Index of a poll which is completed and for which votes continue to
     * exist.
     * - `max`: Maximum number of vote items from remove in this call.
     *
     * Transaction fees are waived if the operation is successful.
     *
     * Weight `O(max)` (less if there are fewer items to remove than `max`).
     */
    "cleanup_poll": Anonymize<I449n3riv6jbum>;
    /**
     * Exchanges a member with a new account and the same existing rank.
     *
     * - `origin`: Must be the `ExchangeOrigin`.
     * - `who`: Account of existing member of rank greater than zero to be exchanged.
     * - `new_who`: New Account of existing member of rank greater than zero to exchanged to.
     */
    "exchange_member": Anonymize<I72edo3nnc5ukn>;
}>;
export type Icu8seopr711dn = {
    "who": Anonymize<I4su1fqci7afjt>;
};
export type Iddd2a11b8876r = {
    "who": Anonymize<I4su1fqci7afjt>;
    "min_rank": number;
};
export type I8bvk21lpmah75 = {
    "poll": number;
    "aye": boolean;
};
export type I449n3riv6jbum = {
    "poll_index": number;
    "max": number;
};
export type I72edo3nnc5ukn = {
    "who": Anonymize<I4su1fqci7afjt>;
    "new_who": Anonymize<I4su1fqci7afjt>;
};
export type Ifopmrlcm8l7p8 = AnonymousEnum<{
    /**
     * Creates a new liquidity pool with the specified parameters.
     */
    "create_pool": Anonymize<I7m1ou0telopf8>;
    /**
     * Adds liquidity to an existing pool.
     */
    "add_liquidity": Anonymize<I4r3lr1hp3q5vu>;
    /**
     * Swaps one asset for another in a specified pool.
     */
    "swap": Anonymize<Ibqd4ibtu385pg>;
    /**
     * Redeems a proportion of assets from a liquidity pool.
     */
    "redeem_proportion": Anonymize<Id846uvbhv0ups>;
    /**
     * Redeems a single asset from a liquidity pool.
     */
    "redeem_single": Anonymize<Iel8d6vl7kun8s>;
    /**
     * Redeems multiple assets from a liquidity pool.
     */
    "redeem_multi": Anonymize<Ia5vm4875s01on>;
    /**
     * Modifies the parameter 'a' of a pool at a future block.
     */
    "modify_a": Anonymize<I1io386vc3pmlf>;
    /**
     * Modifies the fees of a specified liquidity pool.
     */
    "modify_fees": Anonymize<Idnoja8d5k0dtr>;
    /**
     * Modifies the fee and yield recipients of a liquidity pool.
     */
    "modify_recipients": Anonymize<I95j99jsac0h95>;
    /**
     * Edits the token rates for the specified pool.
     */
    "edit_token_rate": Anonymize<Idti8pnde3jga2>;
    /**
     * Configures the auto-refresh settings for a given vToken.
     *
     * This method sets the hard cap for the specified vToken's token rate.
     * Only an authorized origin can call this function.
     */
    "config_vtoken_auto_refresh": Anonymize<Icu74rtf3kd9gd>;
    /**
     * Removes the auto-refresh configuration for a given vToken.
     *
     * This method deletes the hard cap setting for the specified vToken.
     * Only an authorized origin can call this function.
     */
    "remove_vtoken_auto_refresh": Anonymize<I8v7akpi7cdcp5>;
}>;
export type I7m1ou0telopf8 = {
    "assets": Anonymize<I6ae21pstqk9et>;
    "precisions": Anonymize<Iafqnechp3omqg>;
    "mint_fee": bigint;
    "swap_fee": bigint;
    "redeem_fee": bigint;
    "initial_a": bigint;
    "fee_recipient": SS58String;
    "yield_recipient": SS58String;
    "precision": bigint;
};
export type I4r3lr1hp3q5vu = {
    "pool_id": number;
    "amounts": Anonymize<Iafqnechp3omqg>;
    "min_mint_amount": bigint;
};
export type Ibqd4ibtu385pg = {
    "pool_id": number;
    "i": number;
    "j": number;
    "dx": bigint;
    "min_dy": bigint;
};
export type Id846uvbhv0ups = {
    "pool_id": number;
    "amount": bigint;
    "min_redeem_amounts": Anonymize<Iafqnechp3omqg>;
};
export type Iel8d6vl7kun8s = {
    "pool_id": number;
    "amount": bigint;
    "i": number;
    "min_redeem_amount": bigint;
    "asset_length": number;
};
export type Ia5vm4875s01on = {
    "pool_id": number;
    "amounts": Anonymize<Iafqnechp3omqg>;
    "max_redeem_amount": bigint;
};
export type I1io386vc3pmlf = {
    "pool_id": number;
    "a": bigint;
    "future_a_block": number;
};
export type Idnoja8d5k0dtr = {
    "pool_id": number;
    "mint_fee"?: Anonymize<I35p85j063s0il>;
    "swap_fee"?: Anonymize<I35p85j063s0il>;
    "redeem_fee"?: Anonymize<I35p85j063s0il>;
};
export type I95j99jsac0h95 = {
    "pool_id": number;
    "fee_recipient"?: Anonymize<Ihfphjolmsqq1>;
    "yield_recipient"?: Anonymize<Ihfphjolmsqq1>;
};
export type Idti8pnde3jga2 = {
    "pool_id": number;
    "token_rate_info": Anonymize<Idtci0ovsdvku6>;
};
export type I7gidegq1bq0m1 = AnonymousEnum<{
    "vote": Anonymize<I7826235520epg>;
    /**
     * If poll_index exists, it indicates a normal voting user; if it is None,
     * it indicates a proxy voting user.
     */
    "unlock": Anonymize<I495l5qf52l5ch>;
    "remove_delegator_vote": Anonymize<Ibtoub2npklubb>;
    "kill_referendum": Anonymize<Iaj42ghmtrj594>;
    "add_delegator": Anonymize<Iefli0cgm44m3b>;
    "set_referendum_status": Anonymize<Iaij9kantm3v0b>;
    "set_vote_locking_period": Anonymize<I8l8g9smisvqei>;
    "set_undeciding_timeout": Anonymize<I2ce5d3bnbbfhi>;
    "notify_vote": Anonymize<Iasr6pj6shs0fl>;
    "notify_remove_delegator_vote": Anonymize<Iasr6pj6shs0fl>;
    "set_vote_cap_ratio": Anonymize<Ifuh1k8nfv6s7l>;
    /**
     * Updates the status of a referendum vote.
     *
     * Emits an `ReferendumStatusUpdated` event if successful.
     */
    "update_referendum_vote_status": Anonymize<Ict2ktlupdmfrm>;
    "delegate": Anonymize<Idghtot34d3hq8>;
    "undelegate": Anonymize<I8v7akpi7cdcp5>;
    "delegate_vote": Anonymize<I7826235520epg>;
}>;
export type I7826235520epg = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "poll_index": number;
    "vtoken_vote": ConvictionVotingVoteAccountVote;
};
export type I495l5qf52l5ch = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "maybe_poll_index"?: Anonymize<I4arjljr6dpflb>;
};
export type Ibtoub2npklubb = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "class": number;
    "poll_index": number;
    "derivative_index": number;
};
export type Ict2ktlupdmfrm = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "poll_index": number;
    "new_status": Anonymize<I6kqftg4r08qah>;
};
export type Idghtot34d3hq8 = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "to": SS58String;
    "conviction": VotingConviction;
    "vtoken_balance": bigint;
};
export type I8rc525hb3eu89 = AnonymousEnum<{
    /**
     * Stores a new market and its related currency. Returns `Err` if a currency
     * is not attached to an existent market.
     *
     * All provided market states must be `Pending`, otherwise an error will be returned.
     *
     * If a currency is already attached to a market, then the market will be replaced
     * by the new provided value.
     *
     * The lend token id and asset id are bound, the lend token id of new provided market
     * cannot be duplicated with the existing one, otherwise it will return
     * `InvalidLendTokenId`.
     *
     * - `asset_id`: Market related currency
     * - `market`: The market that is going to be stored
     */
    "add_market": Anonymize<I5uf09856s8hsn>;
    /**
     * Activates a market. Returns `Err` if the market currency does not exist.
     *
     * If the market is already activated, does nothing.
     *
     * - `asset_id`: Market related currency
     */
    "activate_market": Anonymize<If0uionjq98ocd>;
    /**
     * Updates the rate model of a stored market. Returns `Err` if the market
     * currency does not exist or the rate model is invalid.
     *
     * - `asset_id`: Market related currency
     * - `rate_model`: The new rate model to be updated
     */
    "update_rate_model": Anonymize<I2lb07lr6m4m1b>;
    /**
     * Updates a stored market. Returns `Err` if the market currency does not exist.
     *
     * - `asset_id`: market related currency
     * - `collateral_factor`: the collateral utilization ratio
     * - `reserve_factor`: fraction of interest currently set aside for reserves
     * - `close_factor`: maximum liquidation ratio at one time
     * - `liquidate_incentive`: liquidation incentive ratio
     * - `cap`: market capacity
     */
    "update_market": Anonymize<Ienmtmhvu9c5gc>;
    /**
     * Force updates a stored market. Returns `Err` if the market currency
     * does not exist.
     *
     * - `asset_id`: market related currency
     * - `market`: the new market parameters
     */
    "force_update_market": Anonymize<I5uf09856s8hsn>;
    /**
     * Add reward for the pallet account.
     *
     * - `amount`: Reward amount added
     */
    "add_reward": Anonymize<I3qt1hgg4djhgb>;
    /**
     * Withdraw reward token from pallet account.
     *
     * The origin must conform to `UpdateOrigin`.
     *
     * - `target_account`: account receive reward token.
     * - `amount`: Withdraw amount
     */
    "withdraw_missing_reward": Anonymize<I153e8dbo2i3pv>;
    /**
     * Updates reward speed for the specified market
     *
     * The origin must conform to `UpdateOrigin`.
     *
     * - `asset_id`: Market related currency
     * - `reward_per_block`: reward amount per block.
     */
    "update_market_reward_speed": Anonymize<Ilat0prj8bnun>;
    /**
     * Claim reward from all market.
     */
    "claim_reward": undefined;
    /**
     * Claim reward from the specified market.
     *
     * - `asset_id`: Market related currency
     */
    "claim_reward_for_market": Anonymize<If0uionjq98ocd>;
    /**
     * Sender supplies assets into the market and receives internal supplies in exchange.
     *
     * - `asset_id`: the asset to be deposited.
     * - `mint_amount`: the amount to be deposited.
     */
    "mint": Anonymize<Ic9p67gsdqt1ro>;
    /**
     * Sender redeems some of internal supplies in exchange for the underlying asset.
     *
     * - `asset_id`: the asset to be redeemed.
     * - `redeem_amount`: the amount to be redeemed.
     */
    "redeem": Anonymize<I158shpkf1icfg>;
    /**
     * Sender redeems all of internal supplies in exchange for the underlying asset.
     *
     * - `asset_id`: the asset to be redeemed.
     */
    "redeem_all": Anonymize<If0uionjq98ocd>;
    /**
     * Sender borrows assets from the protocol to their own address.
     *
     * - `asset_id`: the asset to be borrowed.
     * - `borrow_amount`: the amount to be borrowed.
     */
    "borrow": Anonymize<I2kudr318ju7fu>;
    /**
     * Sender repays some of their debts.
     *
     * - `asset_id`: the asset to be repaid.
     * - `repay_amount`: the amount to be repaid.
     */
    "repay_borrow": Anonymize<I3chmoe7ts2vks>;
    /**
     * Sender repays all of their debts.
     *
     * - `asset_id`: the asset to be repaid.
     */
    "repay_borrow_all": Anonymize<If0uionjq98ocd>;
    /**
     * Set the collateral asset.
     *
     * - `asset_id`: the asset to be set.
     * - `enable`: turn on/off the collateral option.
     */
    "collateral_asset": Anonymize<I533e8jlem55p4>;
    /**
     * The sender liquidates the borrower's collateral.
     *
     * - `borrower`: the borrower to be liquidated.
     * - `liquidation_asset_id`: the assert to be liquidated.
     * - `repay_amount`: the amount to be repaid borrow.
     * - `collateral_asset_id`: The collateral to seize from the borrower.
     */
    "liquidate_borrow": Anonymize<Iene1sabvs33in>;
    /**
     * Add reserves by transferring from payer.
     *
     * May only be called from `T::ReserveOrigin`.
     *
     * - `payer`: the payer account.
     * - `asset_id`: the assets to be added.
     * - `add_amount`: the amount to be added.
     */
    "add_reserves": Anonymize<I1j0vp2lik6fqa>;
    /**
     * Reduces reserves by transferring to receiver.
     *
     * May only be called from `T::ReserveOrigin`.
     *
     * - `receiver`: the receiver account.
     * - `asset_id`: the assets to be reduced.
     * - `reduce_amount`: the amount to be reduced.
     */
    "reduce_reserves": Anonymize<Ifgt33ij9dem7c>;
    /**
     * Sender redeems some of internal supplies in exchange for the underlying asset.
     *
     * - `asset_id`: the asset to be redeemed.
     * - `redeem_amount`: the amount to be redeemed.
     */
    "reduce_incentive_reserves": Anonymize<Ibt8nqfprp1t99>;
    /**
     * Update liquidation free collateral.
     *
     * The `assets` won't be counted when do general
     */
    "update_liquidation_free_collateral": Anonymize<Iap9nfjdhnmblj>;
    "add_market_bond": Anonymize<Ie5efe5gkg0kqs>;
}>;
export type I5uf09856s8hsn = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "market": Anonymize<I1i2kfunpgo63g>;
};
export type If0uionjq98ocd = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
};
export type I2lb07lr6m4m1b = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "rate_model": Anonymize<Ibfnd42bovd7un>;
};
export type Ienmtmhvu9c5gc = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "collateral_factor"?: Anonymize<I4arjljr6dpflb>;
    "liquidation_threshold"?: Anonymize<I4arjljr6dpflb>;
    "reserve_factor"?: Anonymize<I4arjljr6dpflb>;
    "close_factor"?: Anonymize<I4arjljr6dpflb>;
    "liquidate_incentive_reserved_factor"?: Anonymize<I4arjljr6dpflb>;
    "liquidate_incentive"?: Anonymize<I35p85j063s0il>;
    "supply_cap"?: Anonymize<I35p85j063s0il>;
    "borrow_cap"?: Anonymize<I35p85j063s0il>;
};
export type I153e8dbo2i3pv = {
    "target_account": Anonymize<I4su1fqci7afjt>;
    "amount": bigint;
};
export type Ilat0prj8bnun = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "supply_reward_per_block"?: Anonymize<I35p85j063s0il>;
    "borrow_reward_per_block"?: Anonymize<I35p85j063s0il>;
};
export type Ic9p67gsdqt1ro = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "mint_amount": bigint;
};
export type I158shpkf1icfg = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "redeem_amount": bigint;
};
export type I2kudr318ju7fu = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "borrow_amount": bigint;
};
export type I3chmoe7ts2vks = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "repay_amount": bigint;
};
export type I533e8jlem55p4 = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "enable": boolean;
};
export type Iene1sabvs33in = {
    "borrower": SS58String;
    "liquidation_asset_id": Anonymize<Iebirugq1dbhv6>;
    "repay_amount": bigint;
    "collateral_asset_id": Anonymize<Iebirugq1dbhv6>;
};
export type I1j0vp2lik6fqa = {
    "payer": Anonymize<I4su1fqci7afjt>;
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "add_amount": bigint;
};
export type Ifgt33ij9dem7c = {
    "receiver": Anonymize<I4su1fqci7afjt>;
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "reduce_amount": bigint;
};
export type Ibt8nqfprp1t99 = {
    "receiver": Anonymize<I4su1fqci7afjt>;
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "redeem_amount": bigint;
};
export type Iap9nfjdhnmblj = {
    "collaterals": Anonymize<I6ae21pstqk9et>;
};
export type Idj9puo2so8q7j = AnonymousEnum<{
    /**
     * Set emergency price
     */
    "set_price": Anonymize<I5hb3jd6s8k4qo>;
    /**
     * Reset emergency price
     */
    "reset_price": Anonymize<If0uionjq98ocd>;
    /**
     * Set foreign vault token mapping
     */
    "set_foreign_asset": Anonymize<I3jqe98jp6jqj5>;
}>;
export type I5hb3jd6s8k4qo = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "price": bigint;
};
export type I3jqe98jp6jqj5 = {
    "foreign_asset_id": Anonymize<Iebirugq1dbhv6>;
    "asset_id": Anonymize<Iebirugq1dbhv6>;
};
export type Ieb0p9i79epj3p = AnonymousEnum<{
    /**
     * Feed the external value.
     *
     * Require authorized operator.
     */
    "feed_values": Anonymize<Idea758kkrtvus>;
}>;
export type Idea758kkrtvus = {
    "values": Anonymize<I2dbamvpq4935>;
};
export type I3ndh4r2ep15q9 = AnonymousEnum<{
    /**
     * Add a member `who` to the set.
     *
     * May only be called from `T::AddOrigin`.
     */
    "add_member": Anonymize<Icu8seopr711dn>;
    /**
     * Remove a member `who` from the set.
     *
     * May only be called from `T::RemoveOrigin`.
     */
    "remove_member": Anonymize<Icu8seopr711dn>;
    /**
     * Swap out one member `remove` for another `add`.
     *
     * May only be called from `T::SwapOrigin`.
     *
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    "swap_member": Anonymize<Id09aqt1ca773l>;
    /**
     * Change the membership to a new set, disregarding the existing membership. Be nice and
     * pass `members` pre-sorted.
     *
     * May only be called from `T::ResetOrigin`.
     */
    "reset_members": Anonymize<I3c63j6sh3evqn>;
    /**
     * Swap out the sending member for some other key `new`.
     *
     * May only be called from `Signed` origin of a current member.
     *
     * Prime membership is passed from the origin account to `new`, if extant.
     */
    "change_key": Anonymize<I79cmnv5q6b3p>;
    /**
     * Set the prime member. Must be a current member.
     *
     * May only be called from `T::PrimeOrigin`.
     */
    "set_prime": Anonymize<Icu8seopr711dn>;
    /**
     * Remove the prime member if it exists.
     *
     * May only be called from `T::PrimeOrigin`.
     */
    "clear_prime": undefined;
}>;
export type Id09aqt1ca773l = {
    "remove": Anonymize<I4su1fqci7afjt>;
    "add": Anonymize<I4su1fqci7afjt>;
};
export type I3c63j6sh3evqn = {
    "members": Anonymize<Ia2lhg7l2hilo3>;
};
export type I79cmnv5q6b3p = {
    "new": Anonymize<I4su1fqci7afjt>;
};
export type If5i9fp7qj3ecj = AnonymousEnum<{
    /**
     * Deposit flash loan
     *
     * Using borrowed funds to increase the amount of liquid staking (yield-bearing) assets.
     *
     * - `asset_id`: The asset id of the token
     * - `rate`: Leverage rate
     */
    "flash_loan_deposit": Anonymize<I7am60vl6fh2ak>;
}>;
export type I7am60vl6fh2ak = {
    "asset_id": Anonymize<Iebirugq1dbhv6>;
    "rate": bigint;
};
export type Iapd5ovj0gnprh = AnonymousEnum<{
    "register_channel": Anonymize<Id4du8qeonl5uo>;
    "remove_channel": Anonymize<Ib73p6n69t2jsn>;
    "update_channel_receive_account": Anonymize<I69nisu7k9olcl>;
    "set_channel_commission_token": Anonymize<Ievk931u2c7sqn>;
    "set_commission_tokens": Anonymize<Ie2jvm478jd2jv>;
    "claim_commissions": Anonymize<Ib73p6n69t2jsn>;
    "set_channel_vtoken_shares": Anonymize<Ibfeiifn3uif9a>;
}>;
export type Id4du8qeonl5uo = {
    "channel_name": Binary;
    "receive_account": SS58String;
};
export type I69nisu7k9olcl = {
    "channel_id": number;
    "receive_account": SS58String;
};
export type Ie2jvm478jd2jv = {
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "commission_token_op"?: Anonymize<I1c99t35ku3g7a>;
};
export type Ibfeiifn3uif9a = {
    "channel_id": number;
    "vtoken": Anonymize<Iebirugq1dbhv6>;
    "shares": number;
};
export type I52i4uvra2sokt = AnonymousEnum<{
    "clouds_to_vebnc": Anonymize<I59ijflfqmnqm2>;
    "charge_vbnc": Anonymize<I3qt1hgg4djhgb>;
}>;
export type I59ijflfqmnqm2 = {
    "value": bigint;
    "expected_min_vebnc": bigint;
};
export type Ibrclbjbls6qoo = AnonymousEnum<{
    /**
     * Configuration for setting up buybacks and adding liquidity.
     */
    "set_vtoken": Anonymize<Ifor98fsce0gmh>;
    /**
     * Charge the buyback account.
     */
    "charge": Anonymize<I6e7p4l5e6t7n6>;
    /**
     * Remove the configuration of the buyback.
     */
    "remove_vtoken": Anonymize<I6dlum3cbrie3d>;
}>;
export type Ifor98fsce0gmh = {
    "currency_id": Anonymize<Iebirugq1dbhv6>;
    "min_swap_value": bigint;
    "proportion": number;
    "buyback_duration": number;
    "add_liquidity_duration": number;
    "if_auto": boolean;
    "destruction_ratio"?: Anonymize<I4arjljr6dpflb>;
    "bias": number;
};
export type Ifp1epfja1b011 = AnonymousEnum<{
    /**
     * Set the XCM fee for a specific XCM task.
     *
     * Can only be called by governance
     *
     * Parameters
     * - `staking_protocol`: Slp supports staking protocols.
     * - `configuration`: The staking protocol configuration.
     */
    "set_protocol_configuration": Anonymize<Iok3ke9gllunv>;
    /**
     * Add a delegator to the staking protocol.
     *
     * Can only be called by governance
     *
     * Parameters
     * - `staking_protocol`: Slp supports staking protocols.
     * - `delegator`: If delegator is None, the delegator will be derived from sovereign
     * account.
     */
    "add_delegator": Anonymize<I1dpf04lbh0g77>;
    /**
     * Remove a delegator from the staking protocol.
     *
     * Can only be called by governance
     *
     * Parameters
     * - `staking_protocol`: Slp supports staking protocols.
     * - `delegator`: Delegator that need to be removed.
     */
    "remove_delegator": Anonymize<Iduuc186lvhgmv>;
    /**
     * Add a validator to the staking protocol.
     *
     * Can only be called by governance
     *
     * Parameters
     * - `staking_protocol`: Slp supports staking protocols.
     * - `delegator`: Select the delegator which is existed.
     * - `validator`: Validator that need to be added.
     */
    "add_validator": Anonymize<Ieprlpg14vh08o>;
    /**
     * Remove a validator from the staking protocol.
     *
     * Can only be called by governance
     *
     * Parameters
     * - `staking_protocol`: Slp supports staking protocols.
     * - `delegator`: Select the delegator which is existed.
     * - `validator`: Validator that need to be removed.
     */
    "remove_validator": Anonymize<Ieprlpg14vh08o>;
    /**
     * Set the update token exchange rate limit for a specific staking protocol.
     *
     * Can only be called by governance.
     *
     * Parameters
     * - `staking_protocol`: Slp supports staking protocols.
     * - `delegator`: Select the delegator which is existed.
     * - `ledger`: Ledger that need to be set.
     */
    "set_ledger": Anonymize<Ifvladst7gf7jp>;
    /**
     * Transfer the staking token to remote chain.
     * Transfer the free balance of the Entrance Account to the selected delegator.
     *
     * Can be called by governance or staking protocol operator.
     *
     * Parameters
     * - `staking_protocol`: Slp supports staking protocols.
     * - `delegator`: Select the delegator which is existed.
     */
    "transfer_to": Anonymize<I2vujg8u335g7a>;
    /**
     * Transfer the staking token back from remote chain.
     * Transfer the amount of tokens from the selected delegator back to the entrance account.
     *
     * Can be called by governance or staking protocol operator.
     *
     * Parameters
     * - `staking_protocol`: Slp supports staking protocols.
     * - `delegator`: Select the delegator which is existed.
     * - `amount`: The amount of tokens to transfer back.
     */
    "transfer_back": Anonymize<Idle45vlbjmfo0>;
    /**
     * Update the ongoing time unit for a specific staking protocol.
     * Update frequency controlled by update_time_unit_interval.
     * Less than update_time_unit_interval will report an error.
     *
     * Can be called by governance or staking protocol operator.
     *
     * Parameters
     * - `staking_protocol`: Slp supports staking protocols.
     * - `time_uint_option`: If time_uint is None, the ongoing time unit will be increased by
     * one. Otherwise, the ongoing time unit will be updated to the specified time unit.
     */
    "update_ongoing_time_unit": Anonymize<I38ao3jdscg8o5>;
    /**
     * Update the token exchange rate for a specific staking protocol.
     * Update frequency controlled by update_exchange_rate_interval.
     * Amount max update for token pool * max_update_token_exchange_rate.
     *
     * Can be called by governance or staking protocol operator.
     *
     * Parameters
     * - `staking_protocol`: Slp supports staking protocols.
     * - `delegator`: Select the delegator which is existed.
     * - `amount`: The amount of tokens to update the token exchange rate.
     */
    "update_token_exchange_rate": Anonymize<I5kj7kli9hm86u>;
    /**
     * Manipulate a delegator to perform Dapp staking related operations.
     *
     * Can be called by governance or staking protocol operator.
     *
     * Parameters
     * - `staking_protocol`: Slp supports staking protocols.
     * - `delegator`: Select the delegator which is existed.
     * - `task`: The Dapp staking task.
     */
    "astar_dapp_staking": Anonymize<I8kr5s6u6ue9e7>;
    /**
     * Processing Xcm message execution results.
     *
     * Can be called by governance or xcm origin.
     */
    "notify_astar_dapp_staking": Anonymize<Iasr6pj6shs0fl>;
    /**
     * Manipulate a delegator to perform Dapp staking related operations.
     *
     * Can be called by governance or staking protocol operator.
     *
     * Parameters
     * - `staking_protocol`: Slp supports staking protocols.
     * - `delegator`: Select the delegator which is existed.
     * - `task`: The Dapp staking task.
     */
    "ethereum_staking": Anonymize<I4c9kt1ip8g4lh>;
}>;
export type I1dpf04lbh0g77 = {
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    "delegator"?: (Anonymize<Ickhdoqhl8bqbi>) | undefined;
};
export type Iduuc186lvhgmv = {
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    "delegator": Anonymize<Ickhdoqhl8bqbi>;
};
export type I2vujg8u335g7a = {
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    "delegator": Anonymize<Ickhdoqhl8bqbi>;
    "currency_id"?: Anonymize<I1c99t35ku3g7a>;
    "amount"?: Anonymize<I35p85j063s0il>;
    "dest"?: Anonymize<I4arjljr6dpflb>;
    "fee"?: Anonymize<I35p85j063s0il>;
};
export type Idle45vlbjmfo0 = {
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    "delegator": Anonymize<Ickhdoqhl8bqbi>;
    "amount": bigint;
};
export type I38ao3jdscg8o5 = {
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    "currency_id"?: Anonymize<I1c99t35ku3g7a>;
    "time_uint_option"?: Anonymize<I6o0vlee7cr3h2>;
};
export type I5kj7kli9hm86u = {
    "staking_protocol": Anonymize<Icj6nnp3j96bc6>;
    "currency_id"?: Anonymize<I1c99t35ku3g7a>;
    "delegator": Anonymize<Ickhdoqhl8bqbi>;
    "pool_value": bigint;
    "delegator_value": bigint;
};
export type I8kr5s6u6ue9e7 = {
    "delegator": Anonymize<Ickhdoqhl8bqbi>;
    "task": Anonymize<I5iigfm374t7es>;
};
export type Ifvjmhsdtkl8pc = ResultPayload<Anonymize<I5sjue8i9nndg4>, Anonymize<I5nrjkj9qumobs>>;
export type Ic5egmm215ml6k = (Anonymize<Idg0qi60379vnh>) | undefined;
export type Iaouq7pgukugju = ResultPayload<Anonymize<I7ag5k7bmmgq3j>, Anonymize<I46mg5gru1rk0a>>;
export type I4u44goi3tb79g = ResultPayload<Anonymize<Ie3rl25flint9v>, Anonymize<I46mg5gru1rk0a>>;
export type I5fvdd841odbi3 = (Anonymize<Ib0hfhkohlekcj>) | undefined;
export type I35vouom6s9r2 = (Anonymize<I32lgu058i52q9>) | undefined;
export type Ifgqf2rskq94om = [Anonymize<I5fvdd841odbi3>, Anonymize<I35vouom6s9r2>, Anonymize<Ie6kgk6f04rsvk>];
export type I7aold6s47n103 = [Anonymize<I5fvdd841odbi3>, Anonymize<Ie6kgk6f04rsvk>];
export type Idh5kbd0b4k677 = Array<Anonymize<Iaphpg3dpbv2ui>>;
export type Iaphpg3dpbv2ui = AnonymousEnum<{
    "StateMachineUpdated": Anonymize<Ial9kpmfj9nsqr>;
    "StateCommitmentVetoed": Anonymize<I2ra3uepvk35si>;
    "PostRequest": Anonymize<I7fuds5ki77feo>;
    "PostResponse": Anonymize<I69bjo2tm1bcq5>;
    "GetResponse": Anonymize<Irujvnm69ijog>;
    "GetRequest": Anonymize<I96hf71evagbs4>;
    "PostRequestHandled": Anonymize<I7qo7cp2e3aerl>;
    "PostResponseHandled": Anonymize<I7qo7cp2e3aerl>;
    "PostRequestTimeoutHandled": Anonymize<I53bm5fak9v07m>;
    "PostResponseTimeoutHandled": Anonymize<I53bm5fak9v07m>;
    "GetRequestHandled": Anonymize<I7qo7cp2e3aerl>;
    "GetRequestTimeoutHandled": Anonymize<I53bm5fak9v07m>;
}>;
export type I8aqlkvv092ag5 = Array<[Anonymize<Iaphpg3dpbv2ui>, Anonymize<I4arjljr6dpflb>]>;
export type I92ov8h8197b4h = AnonymousEnum<{
    "System": Anonymize<Iekve0i6djpd9f>;
    "Timestamp": Anonymize<I7d75gqfg6jh9c>;
    "Indices": Anonymize<Ibjoagskivshoc>;
    "ParachainSystem": Anonymize<I5kev21p7u6ajb>;
    "ParachainInfo": undefined;
    "TxPause": Anonymize<Ieci88jft3cpv9>;
    "MultiBlockMigrations": Anonymize<I4oqb168b2d4er>;
    "Balances": Anonymize<I9fktnrlinnre4>;
    "Session": Anonymize<I77dda7hps0u37>;
    "ParachainStaking": Anonymize<Ievfetjbuchs5m>;
    "ConvictionVoting": Anonymize<I99hrhstt9euff>;
    "Referenda": Anonymize<Iem8t94ck8brd9>;
    "Whitelist": Anonymize<I33skh82kfvj1c>;
    "XcmpQueue": Anonymize<Ib7tahn20bvsep>;
    "PolkadotXcm": Anonymize<I6k1inef986368>;
    "CumulusXcm": undefined;
    "MessageQueue": Anonymize<Ic2uoe7jdksosp>;
    "Utility": Anonymize<I6p7dfe157nddg>;
    "Scheduler": Anonymize<Idmq3gcajulc6r>;
    "Proxy": Anonymize<Idhal6edn5k25n>;
    "Multisig": Anonymize<I1nlok85f3lnbu>;
    "Identity": Anonymize<Ias6m7696errt5>;
    "Vesting": Anonymize<I24a2kubctpuac>;
    "Treasury": Anonymize<Idrsndhllhv8bk>;
    "Preimage": Anonymize<If81ks88t5mpk5>;
    "Ethereum": Anonymize<I3lo8is2egp8k4>;
    "EVM": Anonymize<I78r7di33lh57i>;
    "DynamicFee": Anonymize<Ie18f12l062q2m>;
    "EVMAccounts": Anonymize<I1l1phpc090qm9>;
    "XTokens": Anonymize<Ice254h3kamj7h>;
    "Tokens": Anonymize<Ifg1rpnuo1vsne>;
    "OrmlXcm": Anonymize<I8t7b9qn3bqn3i>;
    "ZenlinkProtocol": Anonymize<I55fhdusvjpt5l>;
    "Ismp": Anonymize<I31d7vn1hatu5q>;
    "IsmpParachain": Anonymize<I41rj1hc4lfv1r>;
    "TokenGateway": Anonymize<I9jm8tfci89hlj>;
    "FlexibleFee": Anonymize<Ib150uqa18un23>;
    "Salp": Anonymize<If7l7olca960be>;
    "AssetRegistry": Anonymize<Ia0qvep43jq2bs>;
    "VtokenMinting": Anonymize<I9bg8u5ft729i0>;
    "Slp": Anonymize<I1e3qd0qm1op03>;
    "XcmInterface": Anonymize<Idttp484aaigqv>;
    "TokenConversion": Anonymize<If0v6q8a012l7o>;
    "Farming": Anonymize<I57rd76ok8gbu6>;
    "SystemStaking": Anonymize<I6oggfr891dpc2>;
    "FeeShare": Anonymize<I1pd23tvu4hvk8>;
    "CrossInOut": Anonymize<If5cqas1ocd5ig>;
    "BbBNC": Anonymize<Ib5206vm911emu>;
    "Slpx": Anonymize<I5jedbss0q227o>;
    "FellowshipCollective": Anonymize<Ieblk40f65bn0b>;
    "FellowshipReferenda": Anonymize<Iem8t94ck8brd9>;
    "StablePool": Anonymize<Ifopmrlcm8l7p8>;
    "VtokenVoting": Anonymize<I7gidegq1bq0m1>;
    "LendMarket": Anonymize<I8rc525hb3eu89>;
    "Prices": Anonymize<Idj9puo2so8q7j>;
    "Oracle": Anonymize<Ieb0p9i79epj3p>;
    "OracleMembership": Anonymize<I3ndh4r2ep15q9>;
    "LeverageStaking": Anonymize<If5i9fp7qj3ecj>;
    "ChannelCommission": Anonymize<Iapd5ovj0gnprh>;
    "CloudsConvert": Anonymize<I52i4uvra2sokt>;
    "BuyBack": Anonymize<Ibrclbjbls6qoo>;
    "SlpV2": Anonymize<Ifp1epfja1b011>;
}>;
export type I5tl4ceupnessr = ResultPayload<{
    "execution_result": Anonymize<Idk1gjo1nphf83>;
    "emitted_events": Anonymize<Id5uta531dsl30>;
    "local_xcm"?: Anonymize<Ieqgqma27vbupd>;
    "forwarded_xcms": Anonymize<Ialhmrpub9sefe>;
}, Anonymize<I55ku9c5gk50hb>>;
export type Id5uta531dsl30 = Array<Anonymize<I2dkkh5p968qs3>>;
export type Ib2lgkapsudh06 = ResultPayload<{
    "execution_result": Anonymize<I6uq5gb4s805s7>;
    "emitted_events": Anonymize<Id5uta531dsl30>;
    "forwarded_xcms": Anonymize<Ialhmrpub9sefe>;
}, Anonymize<I55ku9c5gk50hb>>;
export type I42esqb0jrl6ka = ({
    "asset_0": Anonymize<Icu3qllmbdnj89>;
    "asset_1": Anonymize<Icu3qllmbdnj89>;
    "account": SS58String;
    "total_liquidity": bigint;
    "holding_liquidity": bigint;
    "reserve_0": bigint;
    "reserve_1": bigint;
    "lp_asset_id": Anonymize<Icu3qllmbdnj89>;
    "status": number;
}) | undefined;
export type I5vv5n03oo8gas = (Anonymize<I200n1ov5tbcvr>) | undefined;
export type I1lb0fd61s4rqa = [bigint, Enum<{
    "Idle": undefined;
    "Contributing": undefined;
    "Refunded": undefined;
    "Unlocked": undefined;
    "Redeemed": undefined;
    "MigratedIdle": undefined;
}>];
export type I4jpedvba08hch = ResultPayload<Anonymize<I4totqt881mlti>, Anonymize<I46mg5gru1rk0a>>;
export type I52umdgcif5b75 = ResultPayload<[bigint, bigint, bigint, number, bigint, bigint, bigint], Anonymize<I46mg5gru1rk0a>>;
export type Ic6m8qjo445mpd = Array<{
    "phase": Phase;
    "event": Anonymize<I654d265vs2sj5>;
    "topics": Anonymize<Ic5m5lp1oioo8r>;
}>;
export type I654d265vs2sj5 = AnonymousEnum<{
    "System": Anonymize<I8nbpfq1kl5cqq>;
    "Utility": Anonymize<Icrm0cf35mlr9k>;
    "Identity": Anonymize<I2au2or9cskfoi>;
    "Multisig": Anonymize<I3ps2vslam2luv>;
    "Proxy": Anonymize<I2ekff0aig8a7h>;
    "Scheduler": Anonymize<Ia3midjucpk2sk>;
    "ParachainSystem": Anonymize<Icbsekf57miplo>;
    "TransactionPayment": TransactionPaymentEvent;
    "Balances": Anonymize<Iao8h4hv7atnq3>;
    "Vesting": VestingEvent;
    "Inflation": Anonymize<Idvllq5t232qg8>;
    "DappStaking": Anonymize<I10squ25alp3rn>;
    "Assets": Anonymize<Id7glfm578e80n>;
    "PriceAggregator": Anonymize<Ibog1e8sl4g79>;
    "Oracle": Anonymize<I359oq8v5tnssq>;
    "OracleMembership": Anonymize<Ibraem55mlft17>;
    "CollatorSelection": Anonymize<If3h5osf022s6>;
    "Session": SessionEvent;
    "XcmpQueue": Anonymize<Idsqc7mhp6nnle>;
    "PolkadotXcm": Anonymize<Iel5f66clbekc3>;
    "CumulusXcm": Anonymize<Ihpdgvt7vs2cb>;
    "XcAssetConfig": Anonymize<Ia9f6jedu25ub4>;
    "XTokens": Anonymize<I1kj6lnq7rdnrl>;
    "MessageQueue": Anonymize<I2kosejppk3jon>;
    "EVM": Anonymize<I9k071kk4cn1u8>;
    "Ethereum": Anonymize<I510u4q1qqh897>;
    "DynamicEvmBaseFee": Anonymize<I6ujohdkm9pipu>;
    "Contracts": Anonymize<I211sbjvh5hjqu>;
    "Preimage": PreimageEvent;
    "Sudo": Anonymize<Id8acp2lhb61h0>;
    "CouncilMembership": Anonymize<Ibraem55mlft17>;
    "TechnicalCommitteeMembership": Anonymize<Ibraem55mlft17>;
    "CommunityCouncilMembership": Anonymize<Ibraem55mlft17>;
    "Council": Anonymize<I2aeps14qcfip9>;
    "TechnicalCommittee": Anonymize<I2aeps14qcfip9>;
    "CommunityCouncil": Anonymize<I2aeps14qcfip9>;
    "Democracy": Anonymize<Icfq8ap3e5p73t>;
    "Treasury": Anonymize<Ifubvi2o2hjbjq>;
    "CommunityTreasury": Anonymize<Ifubvi2o2hjbjq>;
    "CollectiveProxy": Anonymize<If9sehpg8fbpl1>;
    "SafeMode": Anonymize<I3q8c83f5dvokp>;
    "TxPause": Anonymize<I9ulgod11dfvq5>;
    "MultiBlockMigrations": Anonymize<I94co7vj7h6bo>;
}>;
export type I8nbpfq1kl5cqq = AnonymousEnum<{
    /**
     * An extrinsic completed successfully.
     */
    "ExtrinsicSuccess": Anonymize<Ia82mnkmeo2rhc>;
    /**
     * An extrinsic failed.
     */
    "ExtrinsicFailed": Anonymize<I7m2vppkutb3qv>;
    /**
     * `:code` was updated.
     */
    "CodeUpdated": undefined;
    /**
     * A new account was created.
     */
    "NewAccount": Anonymize<Icbccs0ug47ilf>;
    /**
     * An account was reaped.
     */
    "KilledAccount": Anonymize<Icbccs0ug47ilf>;
    /**
     * On on-chain remark happened.
     */
    "Remarked": Anonymize<I855j4i3kr8ko1>;
    /**
     * An upgrade was authorized.
     */
    "UpgradeAuthorized": Anonymize<Ibgl04rn6nbfm6>;
}>;
export type I7m2vppkutb3qv = {
    "dispatch_error": Anonymize<Ia0b5t2n4b7jh8>;
    "dispatch_info": Anonymize<Ic9s8f85vjtncc>;
};
export type Ia0b5t2n4b7jh8 = AnonymousEnum<{
    "Other": undefined;
    "CannotLookup": undefined;
    "BadOrigin": undefined;
    "Module": Enum<{
        "System": Anonymize<I5o0s7c8q1cc9b>;
        "Utility": Anonymize<I8dt2g2hcrgh36>;
        "Identity": Anonymize<Ib8gja1crqq8kd>;
        "Timestamp": undefined;
        "Multisig": Anonymize<Ia76qmhhg4jvb9>;
        "Proxy": Anonymize<Iuvt54ei4cehc>;
        "Scheduler": Anonymize<If7oa8fprnilo5>;
        "ParachainSystem": Anonymize<I9p95gln24a0rn>;
        "ParachainInfo": undefined;
        "TransactionPayment": undefined;
        "Balances": Anonymize<Idj13i7adlomht>;
        "Vesting": Anonymize<Icof2acl69lq3c>;
        "Inflation": Anonymize<Ie4hqffuufful0>;
        "DappStaking": Anonymize<I24rlnj5ptqj4a>;
        "Assets": Anonymize<Iapedqb0veh71>;
        "PriceAggregator": undefined;
        "Oracle": Anonymize<Ibbhs1otrrm5i1>;
        "OracleMembership": Anonymize<Ie3flrv31mi7gh>;
        "Authorship": undefined;
        "CollatorSelection": Anonymize<I9uh9vfii8m28i>;
        "Session": Anonymize<I1e07dgbaqd1sq>;
        "Aura": undefined;
        "AuraExt": undefined;
        "XcmpQueue": Anonymize<Idnnbndsjjeqqs>;
        "PolkadotXcm": Anonymize<I87j95aq93d7dq>;
        "CumulusXcm": undefined;
        "XcAssetConfig": Anonymize<I61ki8ec8unpuh>;
        "XTokens": Anonymize<I8g8tbk0anjali>;
        "MessageQueue": Anonymize<I5iupade5ag2dp>;
        "EVM": Anonymize<I4pkfap0t7vk0t>;
        "Ethereum": Anonymize<I1mp6vnoh32l4q>;
        "DynamicEvmBaseFee": Anonymize<If5ned02f394a8>;
        "Contracts": Anonymize<I2489g9rnboo1t>;
        "Preimage": Anonymize<I4cfhml1prt4lu>;
        "Sudo": Anonymize<Iaug04qjhbli00>;
        "CouncilMembership": Anonymize<Ie3flrv31mi7gh>;
        "TechnicalCommitteeMembership": Anonymize<Ie3flrv31mi7gh>;
        "CommunityCouncilMembership": Anonymize<Ie3flrv31mi7gh>;
        "Council": Anonymize<I7n7mcmnnfjfl2>;
        "TechnicalCommittee": Anonymize<I7n7mcmnnfjfl2>;
        "CommunityCouncil": Anonymize<I7n7mcmnnfjfl2>;
        "Democracy": Anonymize<I67neb7i10udig>;
        "Treasury": Anonymize<I4emjcpgu2307d>;
        "CommunityTreasury": Anonymize<I4emjcpgu2307d>;
        "CollectiveProxy": undefined;
        "SafeMode": Anonymize<I65gapcjsc3grr>;
        "TxPause": Anonymize<Ifku1elmu8hk3i>;
        "MultiBlockMigrations": Anonymize<Iaaqq5jevtahm8>;
    }>;
    "ConsumerRemaining": undefined;
    "NoProviders": undefined;
    "TooManyConsumers": undefined;
    "Token": TokenError;
    "Arithmetic": ArithmeticError;
    "Transactional": TransactionalError;
    "Exhausted": undefined;
    "Corruption": undefined;
    "Unavailable": undefined;
    "RootNotAllowed": undefined;
    "Trie": Anonymize<Idh4cj79bvroj8>;
}>;
export type Ie4hqffuufful0 = AnonymousEnum<{
    /**
     * Sum of all parts must be one whole (100%).
     */
    "InvalidInflationParameters": undefined;
}>;
export type I24rlnj5ptqj4a = AnonymousEnum<{
    /**
     * Pallet is disabled/in maintenance mode.
     */
    "Disabled": undefined;
    /**
     * Smart contract already exists within dApp staking protocol.
     */
    "ContractAlreadyExists": undefined;
    /**
     * Maximum number of smart contracts has been reached.
     */
    "ExceededMaxNumberOfContracts": undefined;
    /**
     * Not possible to assign a new dApp Id.
     * This should never happen since current type can support up to 65536 - 1 unique dApps.
     */
    "NewDAppIdUnavailable": undefined;
    /**
     * Specified smart contract does not exist in dApp staking.
     */
    "ContractNotFound": undefined;
    /**
     * Call origin is not dApp owner.
     */
    "OriginNotOwner": undefined;
    /**
     * Performing locking or staking with 0 amount.
     */
    "ZeroAmount": undefined;
    /**
     * Total locked amount for staker is below minimum threshold.
     */
    "LockedAmountBelowThreshold": undefined;
    /**
     * Account is not allowed to participate in dApp staking due to some external reason (e.g. account is already a collator).
     */
    "AccountNotAvailableForDappStaking": undefined;
    /**
     * Cannot add additional unlocking chunks due to capacity limit.
     */
    "TooManyUnlockingChunks": undefined;
    /**
     * Remaining stake prevents entire balance of starting the unlocking process.
     */
    "RemainingStakePreventsFullUnlock": undefined;
    /**
     * There are no eligible unlocked chunks to claim. This can happen either if no eligible chunks exist, or if user has no chunks at all.
     */
    "NoUnlockedChunksToClaim": undefined;
    /**
     * There are no unlocking chunks available to relock.
     */
    "NoUnlockingChunks": undefined;
    /**
     * The amount being staked is too large compared to what's available for staking.
     */
    "UnavailableStakeFunds": undefined;
    /**
     * There are unclaimed rewards remaining from past eras or periods. They should be claimed before attempting any stake modification again.
     */
    "UnclaimedRewards": undefined;
    /**
     * An unexpected error occurred while trying to stake.
     */
    "InternalStakeError": undefined;
    /**
     * Total staked amount on contract is below the minimum required value.
     */
    "InsufficientStakeAmount": undefined;
    /**
     * Stake operation is rejected since period ends in the next era.
     */
    "PeriodEndsInNextEra": undefined;
    /**
     * Unstaking is rejected since the period in which past stake was active has passed.
     */
    "UnstakeFromPastPeriod": undefined;
    /**
     * Unstake amount is greater than the staked amount.
     */
    "UnstakeAmountTooLarge": undefined;
    /**
     * Account has no staking information for the contract.
     */
    "NoStakingInfo": undefined;
    /**
     * An unexpected error occurred while trying to unstake.
     */
    "InternalUnstakeError": undefined;
    /**
     * Rewards are no longer claimable since they are too old.
     */
    "RewardExpired": undefined;
    /**
     * Reward payout has failed due to an unexpected reason.
     */
    "RewardPayoutFailed": undefined;
    /**
     * There are no claimable rewards.
     */
    "NoClaimableRewards": undefined;
    /**
     * An unexpected error occurred while trying to claim staker rewards.
     */
    "InternalClaimStakerError": undefined;
    /**
     * Account is has no eligible stake amount for bonus reward.
     */
    "NotEligibleForBonusReward": undefined;
    /**
     * An unexpected error occurred while trying to claim bonus reward.
     */
    "InternalClaimBonusError": undefined;
    /**
     * Claim era is invalid - it must be in history, and rewards must exist for it.
     */
    "InvalidClaimEra": undefined;
    /**
     * No dApp tier info exists for the specified era. This can be because era has expired
     * or because during the specified era there were no eligible rewards or protocol wasn't active.
     */
    "NoDAppTierInfo": undefined;
    /**
     * An unexpected error occurred while trying to claim dApp reward.
     */
    "InternalClaimDAppError": undefined;
    /**
     * Contract is still active, not unregistered.
     */
    "ContractStillActive": undefined;
    /**
     * There are too many contract stake entries for the account. This can be cleaned up by either unstaking or cleaning expired entries.
     */
    "TooManyStakedContracts": undefined;
    /**
     * There are no expired entries to cleanup for the account.
     */
    "NoExpiredEntries": undefined;
    /**
     * Force call is not allowed in production.
     */
    "ForceNotAllowed": undefined;
    /**
     * Invalid tier parameters were provided. This can happen if any number exceeds 100% or if number of elements does not match the number of tiers.
     */
    "InvalidTierParams": undefined;
    /**
     * Same contract specified as source and destination.
     */
    "SameContracts": undefined;
}>;
export type I9uh9vfii8m28i = AnonymousEnum<{
    /**
     * Too many candidates
     */
    "TooManyCandidates": undefined;
    /**
     * Too few candidates
     */
    "TooFewCandidates": undefined;
    /**
     * Unknown error
     */
    "Unknown": undefined;
    /**
     * Permission issue
     */
    "Permission": undefined;
    /**
     * User is already a candidate
     */
    "AlreadyCandidate": undefined;
    /**
     * User is not a candidate
     */
    "NotCandidate": undefined;
    /**
     * User is already an Invulnerable
     */
    "AlreadyInvulnerable": undefined;
    /**
     * User is not an Invulnerable
     */
    "NotInvulnerable": undefined;
    /**
     * Account has no associated validator ID
     */
    "NoAssociatedValidatorId": undefined;
    /**
     * Validator ID is not yet registered
     */
    "ValidatorNotRegistered": undefined;
    /**
     * Account is now allowed to be a candidate due to an external reason (e.g. it might be participating in dApp staking)
     */
    "NotAllowedCandidate": undefined;
    /**
     * The candidacy bond is currently in the un-bonding period.
     */
    "BondStillLocked": undefined;
    /**
     * No candidacy bond available for withdrawal.
     */
    "NoCandidacyBond": undefined;
}>;
export type I61ki8ec8unpuh = AnonymousEnum<{
    /**
     * Asset is already registered.
     */
    "AssetAlreadyRegistered": undefined;
    /**
     * Asset does not exist (hasn't been registered).
     */
    "AssetDoesNotExist": undefined;
    /**
     * Failed to convert to latest versioned Location
     */
    "MultiLocationNotSupported": undefined;
}>;
export type If5ned02f394a8 = AnonymousEnum<{
    /**
     * Specified value is outside of the allowed range.
     */
    "ValueOutOfBounds": undefined;
}>;
export type I2489g9rnboo1t = AnonymousEnum<{
    /**
     * Invalid schedule supplied, e.g. with zero weight of a basic operation.
     */
    "InvalidSchedule": undefined;
    /**
     * Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
     */
    "InvalidCallFlags": undefined;
    /**
     * The executed contract exhausted its gas limit.
     */
    "OutOfGas": undefined;
    /**
     * The output buffer supplied to a contract API call was too small.
     */
    "OutputBufferTooSmall": undefined;
    /**
     * Performing the requested transfer failed. Probably because there isn't enough
     * free balance in the sender's account.
     */
    "TransferFailed": undefined;
    /**
     * Performing a call was denied because the calling depth reached the limit
     * of what is specified in the schedule.
     */
    "MaxCallDepthReached": undefined;
    /**
     * No contract was found at the specified address.
     */
    "ContractNotFound": undefined;
    /**
     * The code supplied to `instantiate_with_code` exceeds the limit specified in the
     * current schedule.
     */
    "CodeTooLarge": undefined;
    /**
     * No code could be found at the supplied code hash.
     */
    "CodeNotFound": undefined;
    /**
     * No code info could be found at the supplied code hash.
     */
    "CodeInfoNotFound": undefined;
    /**
     * A buffer outside of sandbox memory was passed to a contract API function.
     */
    "OutOfBounds": undefined;
    /**
     * Input passed to a contract API function failed to decode as expected type.
     */
    "DecodingFailed": undefined;
    /**
     * Contract trapped during execution.
     */
    "ContractTrapped": undefined;
    /**
     * The size defined in `T::MaxValueSize` was exceeded.
     */
    "ValueTooLarge": undefined;
    /**
     * Termination of a contract is not allowed while the contract is already
     * on the call stack. Can be triggered by `seal_terminate`.
     */
    "TerminatedWhileReentrant": undefined;
    /**
     * `seal_call` forwarded this contracts input. It therefore is no longer available.
     */
    "InputForwarded": undefined;
    /**
     * The subject passed to `seal_random` exceeds the limit.
     */
    "RandomSubjectTooLong": undefined;
    /**
     * The amount of topics passed to `seal_deposit_events` exceeds the limit.
     */
    "TooManyTopics": undefined;
    /**
     * The chain does not provide a chain extension. Calling the chain extension results
     * in this error. Note that this usually  shouldn't happen as deploying such contracts
     * is rejected.
     */
    "NoChainExtension": undefined;
    /**
     * Failed to decode the XCM program.
     */
    "XCMDecodeFailed": undefined;
    /**
     * A contract with the same AccountId already exists.
     */
    "DuplicateContract": undefined;
    /**
     * A contract self destructed in its constructor.
     *
     * This can be triggered by a call to `seal_terminate`.
     */
    "TerminatedInConstructor": undefined;
    /**
     * A call tried to invoke a contract that is flagged as non-reentrant.
     * The only other cause is that a call from a contract into the runtime tried to call back
     * into `pallet-contracts`. This would make the whole pallet reentrant with regard to
     * contract code execution which is not supported.
     */
    "ReentranceDenied": undefined;
    /**
     * A contract attempted to invoke a state modifying API while being in read-only mode.
     */
    "StateChangeDenied": undefined;
    /**
     * Origin doesn't have enough balance to pay the required storage deposits.
     */
    "StorageDepositNotEnoughFunds": undefined;
    /**
     * More storage was created than allowed by the storage deposit limit.
     */
    "StorageDepositLimitExhausted": undefined;
    /**
     * Code removal was denied because the code is still in use by at least one contract.
     */
    "CodeInUse": undefined;
    /**
     * The contract ran to completion but decided to revert its storage changes.
     * Please note that this error is only returned from extrinsics. When called directly
     * or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
     * to determine whether a reversion has taken place.
     */
    "ContractReverted": undefined;
    /**
     * The contract's code was found to be invalid during validation.
     *
     * The most likely cause of this is that an API was used which is not supported by the
     * node. This happens if an older node is used with a new version of ink!. Try updating
     * your node to the newest available version.
     *
     * A more detailed error can be found on the node console if debug messages are enabled
     * by supplying `-lruntime::contracts=debug`.
     */
    "CodeRejected": undefined;
    /**
     * An indeterministic code was used in a context where this is not permitted.
     */
    "Indeterministic": undefined;
    /**
     * A pending migration needs to complete before the extrinsic can be called.
     */
    "MigrationInProgress": undefined;
    /**
     * Migrate dispatch call was attempted but no migration was performed.
     */
    "NoMigrationPerformed": undefined;
    /**
     * The contract has reached its maximum number of delegate dependencies.
     */
    "MaxDelegateDependenciesReached": undefined;
    /**
     * The dependency was not found in the contract's delegate dependencies.
     */
    "DelegateDependencyNotFound": undefined;
    /**
     * The contract already depends on the given delegate dependency.
     */
    "DelegateDependencyAlreadyExists": undefined;
    /**
     * Can not add a delegate dependency to the code hash of the contract itself.
     */
    "CannotAddSelfAsDelegateDependency": undefined;
    /**
     * Can not add more data to transient storage.
     */
    "OutOfTransientStorage": undefined;
}>;
export type Iaug04qjhbli00 = AnonymousEnum<{
    /**
     * Sender must be the Sudo account.
     */
    "RequireSudo": undefined;
}>;
export type I67neb7i10udig = AnonymousEnum<{
    /**
     * Value too low
     */
    "ValueLow": undefined;
    /**
     * Proposal does not exist
     */
    "ProposalMissing": undefined;
    /**
     * Cannot cancel the same proposal twice
     */
    "AlreadyCanceled": undefined;
    /**
     * Proposal already made
     */
    "DuplicateProposal": undefined;
    /**
     * Proposal still blacklisted
     */
    "ProposalBlacklisted": undefined;
    /**
     * Next external proposal not simple majority
     */
    "NotSimpleMajority": undefined;
    /**
     * Invalid hash
     */
    "InvalidHash": undefined;
    /**
     * No external proposal
     */
    "NoProposal": undefined;
    /**
     * Identity may not veto a proposal twice
     */
    "AlreadyVetoed": undefined;
    /**
     * Vote given for invalid referendum
     */
    "ReferendumInvalid": undefined;
    /**
     * No proposals waiting
     */
    "NoneWaiting": undefined;
    /**
     * The given account did not vote on the referendum.
     */
    "NotVoter": undefined;
    /**
     * The actor has no permission to conduct the action.
     */
    "NoPermission": undefined;
    /**
     * The account is already delegating.
     */
    "AlreadyDelegating": undefined;
    /**
     * Too high a balance was provided that the account cannot afford.
     */
    "InsufficientFunds": undefined;
    /**
     * The account is not currently delegating.
     */
    "NotDelegating": undefined;
    /**
     * The account currently has votes attached to it and the operation cannot succeed until
     * these are removed, either through `unvote` or `reap_vote`.
     */
    "VotesExist": undefined;
    /**
     * The instant referendum origin is currently disallowed.
     */
    "InstantNotAllowed": undefined;
    /**
     * Delegation to oneself makes no sense.
     */
    "Nonsense": undefined;
    /**
     * Invalid upper bound.
     */
    "WrongUpperBound": undefined;
    /**
     * Maximum number of votes reached.
     */
    "MaxVotesReached": undefined;
    /**
     * Maximum number of items reached.
     */
    "TooMany": undefined;
    /**
     * Voting period too low
     */
    "VotingPeriodLow": undefined;
    /**
     * The preimage does not exist.
     */
    "PreimageNotExist": undefined;
}>;
export type I4emjcpgu2307d = AnonymousEnum<{
    /**
     * Proposer's balance is too low.
     */
    "InsufficientProposersBalance": undefined;
    /**
     * No proposal, bounty or spend at that index.
     */
    "InvalidIndex": undefined;
    /**
     * Too many approvals in the queue.
     */
    "TooManyApprovals": undefined;
    /**
     * The spend origin is valid but the amount it is allowed to spend is lower than the
     * amount to be spent.
     */
    "InsufficientPermission": undefined;
    /**
     * Proposal has not been approved.
     */
    "ProposalNotApproved": undefined;
}>;
export type I65gapcjsc3grr = AnonymousEnum<{
    /**
     * The safe-mode is (already or still) entered.
     */
    "Entered": undefined;
    /**
     * The safe-mode is (already or still) exited.
     */
    "Exited": undefined;
    /**
     * This functionality of the pallet is disabled by the configuration.
     */
    "NotConfigured": undefined;
    /**
     * There is no balance reserved.
     */
    "NoDeposit": undefined;
    /**
     * The account already has a deposit reserved and can therefore not enter or extend again.
     */
    "AlreadyDeposited": undefined;
    /**
     * This deposit cannot be released yet.
     */
    "CannotReleaseYet": undefined;
    /**
     * An error from the underlying `Currency`.
     */
    "CurrencyError": undefined;
}>;
export type Icrm0cf35mlr9k = AnonymousEnum<{
    /**
     * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
     * well as the error.
     */
    "BatchInterrupted": Anonymize<Iahk6du72h73nk>;
    /**
     * Batch of dispatches completed fully with no error.
     */
    "BatchCompleted": undefined;
    /**
     * Batch of dispatches completed but has errors.
     */
    "BatchCompletedWithErrors": undefined;
    /**
     * A single item within a Batch of dispatches has completed with no error.
     */
    "ItemCompleted": undefined;
    /**
     * A single item within a Batch of dispatches has completed with error.
     */
    "ItemFailed": Anonymize<I2pimctgscuvih>;
    /**
     * A call was dispatched.
     */
    "DispatchedAs": Anonymize<Ib3728pnlm2cie>;
}>;
export type Iahk6du72h73nk = {
    "index": number;
    "error": Anonymize<Ia0b5t2n4b7jh8>;
};
export type I2pimctgscuvih = {
    "error": Anonymize<Ia0b5t2n4b7jh8>;
};
export type Ib3728pnlm2cie = {
    "result": Anonymize<Ibliqel4v19lul>;
};
export type Ibliqel4v19lul = ResultPayload<undefined, Anonymize<Ia0b5t2n4b7jh8>>;
export type I3ps2vslam2luv = AnonymousEnum<{
    /**
     * A new multisig operation has begun.
     */
    "NewMultisig": Anonymize<Iep27ialq4a7o7>;
    /**
     * A multisig operation has been approved by someone.
     */
    "MultisigApproval": Anonymize<Iasu5jvoqr43mv>;
    /**
     * A multisig operation has been executed.
     */
    "MultisigExecuted": Anonymize<I4mhgno6m7svl3>;
    /**
     * A multisig operation has been cancelled.
     */
    "MultisigCancelled": Anonymize<I5qolde99acmd1>;
}>;
export type I4mhgno6m7svl3 = {
    "approving": SS58String;
    "timepoint": Anonymize<Itvprrpb0nm3o>;
    "multisig": SS58String;
    "call_hash": FixedSizeBinary<32>;
    "result": Anonymize<Ibliqel4v19lul>;
};
export type I2ekff0aig8a7h = AnonymousEnum<{
    /**
     * A proxy was executed correctly, with the given.
     */
    "ProxyExecuted": Anonymize<Ib3728pnlm2cie>;
    /**
     * A pure account has been created by new proxy with given
     * disambiguation index and proxy type.
     */
    "PureCreated": Anonymize<Ie4bpt9qlkevto>;
    /**
     * An announcement was placed to make a call in the future.
     */
    "Announced": Anonymize<I2ur0oeqg495j8>;
    /**
     * A proxy was added.
     */
    "ProxyAdded": Anonymize<I2r3jv7qp8f8vn>;
    /**
     * A proxy was removed.
     */
    "ProxyRemoved": Anonymize<I2r3jv7qp8f8vn>;
}>;
export type Ie4bpt9qlkevto = {
    "pure": SS58String;
    "who": SS58String;
    "proxy_type": Anonymize<I1cil00f0vjusj>;
    "disambiguation_index": number;
};
export type I1cil00f0vjusj = AnonymousEnum<{
    "Any": undefined;
    "NonTransfer": undefined;
    "Balances": undefined;
    "Assets": undefined;
    "IdentityJudgement": undefined;
    "CancelProxy": undefined;
    "DappStaking": undefined;
    "StakerRewardClaim": undefined;
    "Governance": undefined;
}>;
export type I2r3jv7qp8f8vn = {
    "delegator": SS58String;
    "delegatee": SS58String;
    "proxy_type": Anonymize<I1cil00f0vjusj>;
    "delay": number;
};
export type Ia3midjucpk2sk = AnonymousEnum<{
    /**
     * Scheduled some task.
     */
    "Scheduled": Anonymize<I5n4sebgkfr760>;
    /**
     * Canceled some task.
     */
    "Canceled": Anonymize<I5n4sebgkfr760>;
    /**
     * Dispatched some task.
     */
    "Dispatched": Anonymize<I8rvhukgc40f50>;
    /**
     * Set a retry configuration for some task.
     */
    "RetrySet": Anonymize<Ia3c82eadg79bj>;
    /**
     * Cancel a retry configuration for some task.
     */
    "RetryCancelled": Anonymize<Ienusoeb625ftq>;
    /**
     * The call for the provided hash was not found so the task has been aborted.
     */
    "CallUnavailable": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task was unable to be renewed since the agenda is full at that block.
     */
    "PeriodicFailed": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task was unable to be retried since the agenda is full at that block or there
     * was not enough weight to reschedule it.
     */
    "RetryFailed": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task can never be executed since it is overweight.
     */
    "PermanentlyOverweight": Anonymize<Ienusoeb625ftq>;
}>;
export type I8rvhukgc40f50 = {
    "task": Anonymize<I9jd27rnpm8ttv>;
    "id"?: Anonymize<I4s6vifaf8k998>;
    "result": Anonymize<Ibliqel4v19lul>;
};
export type Idvllq5t232qg8 = AnonymousEnum<{
    /**
     * Inflation parameters have been force changed. This will have effect on the next inflation recalculation.
     */
    "InflationParametersForceChanged": undefined;
    /**
     * Inflation recalculation has been forced.
     */
    "ForcedInflationRecalculation": Anonymize<Ibghevfhkqejki>;
    /**
     * New inflation configuration has been set.
     */
    "NewInflationConfiguration": Anonymize<Ibghevfhkqejki>;
}>;
export type Ibghevfhkqejki = {
    "config": Anonymize<I7srid9ei8c9u4>;
};
export type I7srid9ei8c9u4 = {
    "recalculation_era": number;
    "issuance_safety_cap": bigint;
    "collator_reward_per_block": bigint;
    "treasury_reward_per_block": bigint;
    "dapp_reward_pool_per_era": bigint;
    "base_staker_reward_pool_per_era": bigint;
    "adjustable_staker_reward_pool_per_era": bigint;
    "bonus_reward_pool_per_period": bigint;
    "ideal_staking_rate": bigint;
};
export type I10squ25alp3rn = AnonymousEnum<{
    /**
     * Maintenance mode has been either enabled or disabled.
     */
    "MaintenanceMode": Anonymize<I94dejtmu6d72i>;
    /**
     * New era has started.
     */
    "NewEra": Anonymize<I9bur6p3ovq9mo>;
    /**
     * New subperiod has started.
     */
    "NewSubperiod": Anonymize<Id5145c5vjp178>;
    /**
     * A smart contract has been registered for dApp staking
     */
    "DAppRegistered": Anonymize<If1i3n61v0fj26>;
    /**
     * dApp reward destination has been updated.
     */
    "DAppRewardDestinationUpdated": Anonymize<I9ed9v9gosmuvf>;
    /**
     * dApp owner has been changed.
     */
    "DAppOwnerChanged": Anonymize<Ibeb69neo60gk0>;
    /**
     * dApp has been unregistered
     */
    "DAppUnregistered": Anonymize<Ibo4omgp8fpt5t>;
    /**
     * Account has locked some amount into dApp staking.
     */
    "Locked": Anonymize<Ic262ibdoec56a>;
    /**
     * Account has started the unlocking process for some amount.
     */
    "Unlocking": Anonymize<Ic262ibdoec56a>;
    /**
     * Account has claimed unlocked amount, removing the lock from it.
     */
    "ClaimedUnlocked": Anonymize<Ic262ibdoec56a>;
    /**
     * Account has relocked all of the unlocking chunks.
     */
    "Relock": Anonymize<Ic262ibdoec56a>;
    /**
     * Account has staked some amount on a smart contract.
     */
    "Stake": Anonymize<Ie1781ek52afdj>;
    /**
     * Account has unstaked some amount from a smart contract.
     */
    "Unstake": Anonymize<Ie1781ek52afdj>;
    /**
     * Account has claimed some stake rewards.
     */
    "Reward": Anonymize<Ibt2bn2cqg689o>;
    /**
     * Bonus reward has been paid out to a staker with an eligible bonus status.
     */
    "BonusReward": Anonymize<Ia1s76fd38iqae>;
    /**
     * dApp reward has been paid out to a beneficiary.
     */
    "DAppReward": Anonymize<I3lcbm4tpd3c2m>;
    /**
     * Account has unstaked funds from an unregistered smart contract
     */
    "UnstakeFromUnregistered": Anonymize<Ie1781ek52afdj>;
    /**
     * Some expired stake entries have been removed from storage.
     */
    "ExpiredEntriesRemoved": Anonymize<Ibl1gaa0rn2c67>;
    /**
     * Privileged origin has forced a new era and possibly a subperiod to start from next block.
     */
    "Force": Anonymize<Id0smhn7t7eh6l>;
    /**
     * Account has moved some stake from a source smart contract to a destination smart contract.
     */
    "StakeMoved": Anonymize<I1jtn43phq0dpb>;
    /**
     * Tier parameters, used to calculate tier configuration, have been updated, and will be applicable from next era.
     */
    "NewTierParameters": Anonymize<Iceqdqbv3mc6o0>;
}>;
export type I94dejtmu6d72i = {
    "enabled": boolean;
};
export type I9bur6p3ovq9mo = {
    "era": number;
};
export type Id5145c5vjp178 = {
    "subperiod": Anonymize<I3vks5eusshcrb>;
    "number": number;
};
export type I3vks5eusshcrb = AnonymousEnum<{
    "Voting": undefined;
    "BuildAndEarn": undefined;
}>;
export type If1i3n61v0fj26 = {
    "owner": SS58String;
    "smart_contract": Anonymize<Iav11gpk2hk471>;
    "dapp_id": number;
};
export type I9ed9v9gosmuvf = {
    "smart_contract": Anonymize<Iav11gpk2hk471>;
    "beneficiary"?: Anonymize<Ihfphjolmsqq1>;
};
export type Ibeb69neo60gk0 = {
    "smart_contract": Anonymize<Iav11gpk2hk471>;
    "new_owner": SS58String;
};
export type Ibo4omgp8fpt5t = {
    "smart_contract": Anonymize<Iav11gpk2hk471>;
    "era": number;
};
export type Ie1781ek52afdj = {
    "account": SS58String;
    "smart_contract": Anonymize<Iav11gpk2hk471>;
    "amount": bigint;
};
export type Ibt2bn2cqg689o = {
    "account": SS58String;
    "era": number;
    "amount": bigint;
};
export type Ia1s76fd38iqae = {
    "account": SS58String;
    "smart_contract": Anonymize<Iav11gpk2hk471>;
    "period": number;
    "amount": bigint;
};
export type I3lcbm4tpd3c2m = {
    "beneficiary": SS58String;
    "smart_contract": Anonymize<Iav11gpk2hk471>;
    "tier_id": number;
    "rank": number;
    "era": number;
    "amount": bigint;
};
export type Ibl1gaa0rn2c67 = {
    "account": SS58String;
    "count": number;
};
export type Id0smhn7t7eh6l = {
    "forcing_type": Enum<{
        "Era": undefined;
        "Subperiod": undefined;
    }>;
};
export type I1jtn43phq0dpb = {
    "account": SS58String;
    "source_contract": Anonymize<Iav11gpk2hk471>;
    "destination_contract": Anonymize<Iav11gpk2hk471>;
    "amount": bigint;
};
export type Iceqdqbv3mc6o0 = {
    "params": Anonymize<I9cb9bfe7mgkah>;
};
export type I9cb9bfe7mgkah = {
    "reward_portion": Anonymize<Icgljjb6j82uhn>;
    "slot_distribution": Anonymize<Icgljjb6j82uhn>;
    "tier_thresholds": Array<Enum<{
        "FixedPercentage": {
            "required_percentage": number;
        };
        "DynamicPercentage": {
            "percentage": number;
            "minimum_required_percentage": number;
            "maximum_possible_percentage": number;
        };
    }>>;
    "slot_number_args": Anonymize<I200n1ov5tbcvr>;
};
export type Id7glfm578e80n = AnonymousEnum<{
    /**
     * Some asset class was created.
     */
    "Created": Anonymize<I2f09r4lf5jjh9>;
    /**
     * Some assets were issued.
     */
    "Issued": Anonymize<If6m0o1bjubses>;
    /**
     * Some assets were transferred.
     */
    "Transferred": Anonymize<Ica4tsd7r045b4>;
    /**
     * Some assets were destroyed.
     */
    "Burned": Anonymize<I8lqcc9n1bpf10>;
    /**
     * The management team changed.
     */
    "TeamChanged": Anonymize<Ic756ll6rev3et>;
    /**
     * The owner changed.
     */
    "OwnerChanged": Anonymize<Iabgjddlh1k1hp>;
    /**
     * Some account `who` was frozen.
     */
    "Frozen": Anonymize<Ie04jjjrr8q02l>;
    /**
     * Some account `who` was thawed.
     */
    "Thawed": Anonymize<Ie04jjjrr8q02l>;
    /**
     * Some asset `asset_id` was frozen.
     */
    "AssetFrozen": Anonymize<Ib9karr24cpmca>;
    /**
     * Some asset `asset_id` was thawed.
     */
    "AssetThawed": Anonymize<Ib9karr24cpmca>;
    /**
     * Accounts were destroyed for given asset.
     */
    "AccountsDestroyed": Anonymize<Ifstva0urnm27g>;
    /**
     * Approvals were destroyed for given asset.
     */
    "ApprovalsDestroyed": Anonymize<I4lpo3encq7fn8>;
    /**
     * An asset class is in the process of being destroyed.
     */
    "DestructionStarted": Anonymize<Ib9karr24cpmca>;
    /**
     * An asset class was destroyed.
     */
    "Destroyed": Anonymize<Ib9karr24cpmca>;
    /**
     * Some asset class was force-created.
     */
    "ForceCreated": Anonymize<Iabgjddlh1k1hp>;
    /**
     * New metadata has been set for an asset.
     */
    "MetadataSet": Anonymize<Icd1cghie6s8nr>;
    /**
     * Metadata has been cleared for an asset.
     */
    "MetadataCleared": Anonymize<Ib9karr24cpmca>;
    /**
     * (Additional) funds have been approved for transfer to a destination account.
     */
    "ApprovedTransfer": Anonymize<I7vvm3he225ppt>;
    /**
     * An approval for account `delegate` was cancelled by `owner`.
     */
    "ApprovalCancelled": Anonymize<Iaui349lsh3clk>;
    /**
     * An `amount` was transferred in its entirety from `owner` to `destination` by
     * the approved `delegate`.
     */
    "TransferredApproved": Anonymize<Ifbddfv84nkppg>;
    /**
     * An asset has had its attributes changed by the `Force` origin.
     */
    "AssetStatusChanged": Anonymize<Ib9karr24cpmca>;
    /**
     * The min_balance of an asset has been updated by the asset owner.
     */
    "AssetMinBalanceChanged": Anonymize<Iil3sdsh8fk7l>;
    /**
     * Some account `who` was created with a deposit from `depositor`.
     */
    "Touched": Anonymize<I85i3hdo5nsfi5>;
    /**
     * Some account `who` was blocked.
     */
    "Blocked": Anonymize<Ie04jjjrr8q02l>;
    /**
     * Some assets were deposited (e.g. for transaction fees).
     */
    "Deposited": Anonymize<Ic65advfoqjhk7>;
    /**
     * Some assets were withdrawn from the account (e.g. for transaction fees).
     */
    "Withdrawn": Anonymize<Ic65advfoqjhk7>;
}>;
export type I2f09r4lf5jjh9 = {
    "asset_id": bigint;
    "creator": SS58String;
    "owner": SS58String;
};
export type If6m0o1bjubses = {
    "asset_id": bigint;
    "owner": SS58String;
    "amount": bigint;
};
export type Ica4tsd7r045b4 = {
    "asset_id": bigint;
    "from": SS58String;
    "to": SS58String;
    "amount": bigint;
};
export type I8lqcc9n1bpf10 = {
    "asset_id": bigint;
    "owner": SS58String;
    "balance": bigint;
};
export type Ic756ll6rev3et = {
    "asset_id": bigint;
    "issuer": SS58String;
    "admin": SS58String;
    "freezer": SS58String;
};
export type Iabgjddlh1k1hp = {
    "asset_id": bigint;
    "owner": SS58String;
};
export type Ie04jjjrr8q02l = {
    "asset_id": bigint;
    "who": SS58String;
};
export type I7vvm3he225ppt = {
    "asset_id": bigint;
    "source": SS58String;
    "delegate": SS58String;
    "amount": bigint;
};
export type Iaui349lsh3clk = {
    "asset_id": bigint;
    "owner": SS58String;
    "delegate": SS58String;
};
export type Ifbddfv84nkppg = {
    "asset_id": bigint;
    "owner": SS58String;
    "delegate": SS58String;
    "destination": SS58String;
    "amount": bigint;
};
export type I85i3hdo5nsfi5 = {
    "asset_id": bigint;
    "who": SS58String;
    "depositor": SS58String;
};
export type Ic65advfoqjhk7 = {
    "asset_id": bigint;
    "who": SS58String;
    "amount": bigint;
};
export type Ibog1e8sl4g79 = AnonymousEnum<{
    /**
     * New average native currency value has been calculated and pushed into the moving average buffer.
     */
    "AverageAggregatedValue": Anonymize<Ie5v6njpckr05b>;
}>;
export type I359oq8v5tnssq = AnonymousEnum<{
    /**
     * New feed data is submitted.
     */
    "NewFeedData": Anonymize<I8sde2gqm7dqqh>;
}>;
export type I8sde2gqm7dqqh = {
    "sender": SS58String;
    "values": Anonymize<I5ifetlpidfu5d>;
};
export type I5ifetlpidfu5d = Array<[Anonymize<I4rgf5d3abfav5>, bigint]>;
export type I4rgf5d3abfav5 = AnonymousEnum<{
    "ASTR": undefined;
    "SDN": undefined;
}>;
export type If3h5osf022s6 = AnonymousEnum<{
    /**
     * New invulnerables candidates were set.
     */
    "NewInvulnerables": Anonymize<Ia2lhg7l2hilo3>;
    /**
     * The number of desired candidates was set.
     */
    "NewDesiredCandidates": number;
    /**
     * The candidacy bond was set.
     */
    "NewCandidacyBond": bigint;
    /**
     * A new candidate joined.
     */
    "CandidateAdded": Anonymize<I95l2k9b1re95f>;
    /**
     * A candidate was removed.
     */
    "CandidateRemoved": SS58String;
    /**
     * A candidate was slashed.
     */
    "CandidateSlashed": SS58String;
}>;
export type SessionEvent = Enum<{
    /**
     * New session has happened. Note that the argument is the session index, not the
     * block number as the type might suggest.
     */
    "NewSession": Anonymize<I2hq50pu2kdjpo>;
}>;
export declare const SessionEvent: GetEnum<SessionEvent>;
export type Ia9f6jedu25ub4 = AnonymousEnum<{
    /**
     * Registed mapping between asset type and asset Id.
     */
    "AssetRegistered": Anonymize<I6j92ua76m1ueo>;
    /**
     * Changed the amount of units we are charging per execution second for an asset
     */
    "UnitsPerSecondChanged": Anonymize<Ifrvl64m5kq433>;
    /**
     * Changed the asset type mapping for a given asset id
     */
    "AssetLocationChanged": Anonymize<I1k922b8al78rb>;
    /**
     * Supported asset type for fee payment removed.
     */
    "SupportedAssetRemoved": Anonymize<Ibmjtl75ptu606>;
    /**
     * Removed all information related to an asset Id
     */
    "AssetRemoved": Anonymize<I6j92ua76m1ueo>;
}>;
export type I6j92ua76m1ueo = {
    "asset_location": XcmVersionedLocation;
    "asset_id": bigint;
};
export type Ifrvl64m5kq433 = {
    "asset_location": XcmVersionedLocation;
    "units_per_second": bigint;
};
export type I1k922b8al78rb = {
    "previous_asset_location": XcmVersionedLocation;
    "asset_id": bigint;
    "new_asset_location": XcmVersionedLocation;
};
export type I6ujohdkm9pipu = AnonymousEnum<{
    /**
     * New `base fee per gas` value has been force-set.
     */
    "NewBaseFeePerGas": Anonymize<I7vi74gbubc8u5>;
}>;
export type I7vi74gbubc8u5 = {
    "fee": Anonymize<I4totqt881mlti>;
};
export type I211sbjvh5hjqu = AnonymousEnum<{
    /**
     * Contract deployed by address at the specified address.
     */
    "Instantiated": Anonymize<Ie5222qfrr24ek>;
    /**
     * Contract has been removed.
     *
     * # Note
     *
     * The only way for a contract to be removed and emitting this event is by calling
     * `seal_terminate`.
     */
    "Terminated": Anonymize<I28g8sphdu312k>;
    /**
     * Code with the specified hash has been stored.
     */
    "CodeStored": Anonymize<Idqbjt2c6r46t6>;
    /**
     * A custom event emitted by the contract.
     */
    "ContractEmitted": Anonymize<I853aigjva3f0t>;
    /**
     * A code with the specified hash was removed.
     */
    "CodeRemoved": Anonymize<I9uehhems5hkqm>;
    /**
     * A contract's code was updated.
     */
    "ContractCodeUpdated": Anonymize<I7q5qk4uoanhof>;
    /**
     * A contract was called either by a plain account or another contract.
     *
     * # Note
     *
     * Please keep in mind that like all events this is only emitted for successful
     * calls. This is because on failure all storage changes including events are
     * rolled back.
     */
    "Called": Anonymize<Iehpbs40l3jkit>;
    /**
     * A contract delegate called a code hash.
     *
     * # Note
     *
     * Please keep in mind that like all events this is only emitted for successful
     * calls. This is because on failure all storage changes including events are
     * rolled back.
     */
    "DelegateCalled": Anonymize<Idht9upmipvd4j>;
    /**
     * Some funds have been transferred and held as storage deposit.
     */
    "StorageDepositTransferredAndHeld": Anonymize<Iflcfm9b6nlmdd>;
    /**
     * Some storage deposit funds have been transferred and released.
     */
    "StorageDepositTransferredAndReleased": Anonymize<Iflcfm9b6nlmdd>;
}>;
export type Ie5222qfrr24ek = {
    "deployer": SS58String;
    "contract": SS58String;
};
export type I28g8sphdu312k = {
    /**
     * The contract that was terminated.
     */
    "contract": SS58String;
    /**
     * The account that received the contracts remaining balance
     */
    "beneficiary": SS58String;
};
export type Idqbjt2c6r46t6 = {
    "code_hash": FixedSizeBinary<32>;
    "deposit_held": bigint;
    "uploader": SS58String;
};
export type I853aigjva3f0t = {
    /**
     * The contract that emitted the event.
     */
    "contract": SS58String;
    /**
     * Data supplied by the contract. Metadata generated during contract compilation
     * is needed to decode it.
     */
    "data": Binary;
};
export type I9uehhems5hkqm = {
    "code_hash": FixedSizeBinary<32>;
    "deposit_released": bigint;
    "remover": SS58String;
};
export type I7q5qk4uoanhof = {
    /**
     * The contract that has been updated.
     */
    "contract": SS58String;
    /**
     * New code hash that was set for the contract.
     */
    "new_code_hash": FixedSizeBinary<32>;
    /**
     * Previous code hash of the contract.
     */
    "old_code_hash": FixedSizeBinary<32>;
};
export type Iehpbs40l3jkit = {
    /**
     * The caller of the `contract`.
     */
    "caller": Enum<{
        "Root": undefined;
        "Signed": SS58String;
    }>;
    /**
     * The contract that was called.
     */
    "contract": SS58String;
};
export type Idht9upmipvd4j = {
    /**
     * The contract that performed the delegate call and hence in whose context
     * the `code_hash` is executed.
     */
    "contract": SS58String;
    /**
     * The code hash that was delegate called.
     */
    "code_hash": FixedSizeBinary<32>;
};
export type Id8acp2lhb61h0 = AnonymousEnum<{
    /**
     * A sudo call just took place.
     */
    "Sudid": Anonymize<I77pq1trv3c4k2>;
    /**
     * The sudo key has been updated.
     */
    "KeyChanged": Anonymize<I5rtkmhm2dng4u>;
    /**
     * The key was permanently removed.
     */
    "KeyRemoved": undefined;
    /**
     * A [sudo_as](Pallet::sudo_as) call just took place.
     */
    "SudoAsDone": Anonymize<I77pq1trv3c4k2>;
}>;
export type I77pq1trv3c4k2 = {
    /**
     * The result of the call made by the sudo user.
     */
    "sudo_result": Anonymize<Ibliqel4v19lul>;
};
export type I5rtkmhm2dng4u = {
    /**
     * The old sudo key (if one was previously set).
     */
    "old"?: Anonymize<Ihfphjolmsqq1>;
    /**
     * The new sudo key (if one was set).
     */
    "new": SS58String;
};
export type I2aeps14qcfip9 = AnonymousEnum<{
    /**
     * A motion (given hash) has been proposed (by given account) with a threshold (given
     * `MemberCount`).
     */
    "Proposed": Anonymize<Ift6f10887nk72>;
    /**
     * A motion (given hash) has been voted on by given account, leaving
     * a tally (yes votes and no votes given respectively as `MemberCount`).
     */
    "Voted": Anonymize<I7qc53b1tvqjg2>;
    /**
     * A motion was approved by the required threshold.
     */
    "Approved": Anonymize<I2ev73t79f46tb>;
    /**
     * A motion was not approved by the required threshold.
     */
    "Disapproved": Anonymize<I2ev73t79f46tb>;
    /**
     * A motion was executed; result will be `Ok` if it returned without error.
     */
    "Executed": Anonymize<Ib6om1rg7gaum1>;
    /**
     * A single member did some action; result will be `Ok` if it returned without error.
     */
    "MemberExecuted": Anonymize<Ib6om1rg7gaum1>;
    /**
     * A proposal was closed because its threshold was reached or after its duration was up.
     */
    "Closed": Anonymize<Iak7fhrgb9jnnq>;
    /**
     * A proposal was killed.
     */
    "Killed": Anonymize<I2ev73t79f46tb>;
    /**
     * Some cost for storing a proposal was burned.
     */
    "ProposalCostBurned": Anonymize<I9ad1o9mv4cm3>;
    /**
     * Some cost for storing a proposal was released.
     */
    "ProposalCostReleased": Anonymize<I9ad1o9mv4cm3>;
}>;
export type Ift6f10887nk72 = {
    "account": SS58String;
    "proposal_index": number;
    "proposal_hash": FixedSizeBinary<32>;
    "threshold": number;
};
export type I7qc53b1tvqjg2 = {
    "account": SS58String;
    "proposal_hash": FixedSizeBinary<32>;
    "voted": boolean;
    "yes": number;
    "no": number;
};
export type Ib6om1rg7gaum1 = {
    "proposal_hash": FixedSizeBinary<32>;
    "result": Anonymize<Ibliqel4v19lul>;
};
export type I9ad1o9mv4cm3 = {
    "proposal_hash": FixedSizeBinary<32>;
    "who": SS58String;
};
export type Icfq8ap3e5p73t = AnonymousEnum<{
    /**
     * A motion has been proposed by a public account.
     */
    "Proposed": Anonymize<I3peh714diura8>;
    /**
     * A public proposal has been tabled for referendum vote.
     */
    "Tabled": Anonymize<I3peh714diura8>;
    /**
     * An external proposal has been tabled.
     */
    "ExternalTabled": undefined;
    /**
     * A referendum has begun.
     */
    "Started": Anonymize<I62ffgu6q2478o>;
    /**
     * A proposal has been approved by referendum.
     */
    "Passed": Anonymize<Ied9mja4bq7va8>;
    /**
     * A proposal has been rejected by referendum.
     */
    "NotPassed": Anonymize<Ied9mja4bq7va8>;
    /**
     * A referendum has been cancelled.
     */
    "Cancelled": Anonymize<Ied9mja4bq7va8>;
    /**
     * An account has delegated their vote to another account.
     */
    "Delegated": Anonymize<I10r7il4gvbcae>;
    /**
     * An account has cancelled a previous delegation operation.
     */
    "Undelegated": Anonymize<Icbccs0ug47ilf>;
    /**
     * An external proposal has been vetoed.
     */
    "Vetoed": Anonymize<I2c00i2bngegk9>;
    /**
     * A proposal_hash has been blacklisted permanently.
     */
    "Blacklisted": Anonymize<I2ev73t79f46tb>;
    /**
     * An account has voted in a referendum
     */
    "Voted": Anonymize<Iet7kfijhihjik>;
    /**
     * An account has seconded a proposal
     */
    "Seconded": Anonymize<I2vrbos7ogo6ps>;
    /**
     * A proposal got canceled.
     */
    "ProposalCanceled": Anonymize<I9mnj4k4u8ls2c>;
    /**
     * Metadata for a proposal or a referendum has been set.
     */
    "MetadataSet": Anonymize<Iffeo46j957abe>;
    /**
     * Metadata for a proposal or a referendum has been cleared.
     */
    "MetadataCleared": Anonymize<Iffeo46j957abe>;
    /**
     * Metadata has been transferred to new owner.
     */
    "MetadataTransferred": Anonymize<I4ljshcevmm3p2>;
}>;
export type I3peh714diura8 = {
    "proposal_index": number;
    "deposit": bigint;
};
export type I62ffgu6q2478o = {
    "ref_index": number;
    "threshold": Anonymize<Ivbp9821csvot>;
};
export type Ivbp9821csvot = AnonymousEnum<{
    "SuperMajorityApprove": undefined;
    "SuperMajorityAgainst": undefined;
    "SimpleMajority": undefined;
}>;
export type Ied9mja4bq7va8 = {
    "ref_index": number;
};
export type I2c00i2bngegk9 = {
    "who": SS58String;
    "proposal_hash": FixedSizeBinary<32>;
    "until": number;
};
export type Iet7kfijhihjik = {
    "voter": SS58String;
    "ref_index": number;
    "vote": Anonymize<Ia9hdots6g53fs>;
};
export type Ia9hdots6g53fs = AnonymousEnum<{
    "Standard": Anonymize<Ib024p97ls1cla>;
    "Split": Anonymize<I5pi71t9bosoiv>;
}>;
export type I2vrbos7ogo6ps = {
    "seconder": SS58String;
    "prop_index": number;
};
export type I9mnj4k4u8ls2c = {
    "prop_index": number;
};
export type Iffeo46j957abe = {
    /**
     * Metadata owner.
     */
    "owner": Anonymize<I2itl2k1j2q8nf>;
    /**
     * Preimage hash.
     */
    "hash": FixedSizeBinary<32>;
};
export type I2itl2k1j2q8nf = AnonymousEnum<{
    "External": undefined;
    "Proposal": number;
    "Referendum": number;
}>;
export type I4ljshcevmm3p2 = {
    /**
     * Previous metadata owner.
     */
    "prev_owner": Anonymize<I2itl2k1j2q8nf>;
    /**
     * New metadata owner.
     */
    "owner": Anonymize<I2itl2k1j2q8nf>;
    /**
     * Preimage hash.
     */
    "hash": FixedSizeBinary<32>;
};
export type Ifubvi2o2hjbjq = AnonymousEnum<{
    /**
     * New proposal.
     */
    "Proposed": Anonymize<I44hc4lgsn4o1j>;
    /**
     * We have ended a spend period and will now allocate funds.
     */
    "Spending": Anonymize<I8iksqi3eani0a>;
    /**
     * Some funds have been allocated.
     */
    "Awarded": Anonymize<I16enopmju1p0q>;
    /**
     * A proposal was rejected; funds were slashed.
     */
    "Rejected": Anonymize<Ifgqhle2413de7>;
    /**
     * Some of our funds have been burnt.
     */
    "Burnt": Anonymize<I43kq8qudg7pq9>;
    /**
     * Spending has finished; this is the amount that rolls over until next spend.
     */
    "Rollover": Anonymize<I76riseemre533>;
    /**
     * Some funds have been deposited.
     */
    "Deposit": Anonymize<Ie5v6njpckr05b>;
    /**
     * A new spend proposal has been approved.
     * The inactive funds of the pallet have been updated.
     */
    "UpdatedInactive": Anonymize<I4hcillge8de5f>;
}>;
export type I44hc4lgsn4o1j = {
    "proposal_index": number;
};
export type Ifgqhle2413de7 = {
    "proposal_index": number;
    "slashed": bigint;
};
export type If9sehpg8fbpl1 = AnonymousEnum<{
    /**
     * Community proxy call executed successfully.
     */
    "CollectiveProxyExecuted": Anonymize<Ib3728pnlm2cie>;
}>;
export type I3q8c83f5dvokp = AnonymousEnum<{
    /**
     * The safe-mode was entered until inclusively this block.
     */
    "Entered": Anonymize<I20e9ph536u7ti>;
    /**
     * The safe-mode was extended until inclusively this block.
     */
    "Extended": Anonymize<I20e9ph536u7ti>;
    /**
     * Exited the safe-mode for a specific reason.
     */
    "Exited": Anonymize<I8kcpmsh450rp>;
    /**
     * An account reserved funds for either entering or extending the safe-mode.
     */
    "DepositPlaced": Anonymize<Ic262ibdoec56a>;
    /**
     * An account had a reserve released that was reserved.
     */
    "DepositReleased": Anonymize<Ic262ibdoec56a>;
    /**
     * An account had reserve slashed that was reserved.
     */
    "DepositSlashed": Anonymize<Ic262ibdoec56a>;
    /**
     * Could not hold funds for entering or extending the safe-mode.
     *
     * This error comes from the underlying `Currency`.
     */
    "CannotDeposit": undefined;
    /**
     * Could not release funds for entering or extending the safe-mode.
     *
     * This error comes from the underlying `Currency`.
     */
    "CannotRelease": undefined;
}>;
export type I20e9ph536u7ti = {
    "until": number;
};
export type I8kcpmsh450rp = {
    "reason": Enum<{
        "Timeout": undefined;
        "Force": undefined;
    }>;
};
export type If9ch4n1qv5pmd = [Array<{
    "delegate": SS58String;
    "proxy_type": Anonymize<I1cil00f0vjusj>;
    "delay": number;
}>, bigint];
export type I8s1m5n387k6ho = Array<({
    "maybe_id"?: Anonymize<I4s6vifaf8k998>;
    "priority": number;
    "call": PreimagesBounded;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "origin": Anonymize<Iekimmnjq021gh>;
}) | undefined>;
export type Iekimmnjq021gh = AnonymousEnum<{
    "system": DispatchRawOrigin;
    "PolkadotXcm": Anonymize<Icvilmd7qu30i4>;
    "CumulusXcm": Anonymize<I3in0d0lb61qi8>;
    "Ethereum": Anonymize<I9hp9au9bfqil7>;
    "Council": Enum<{
        "Members": Anonymize<I9jd27rnpm8ttv>;
        "Member": SS58String;
        "_Phantom": undefined;
    }>;
    "TechnicalCommittee": Enum<{
        "Members": Anonymize<I9jd27rnpm8ttv>;
        "Member": SS58String;
        "_Phantom": undefined;
    }>;
    "CommunityCouncil": Enum<{
        "Members": Anonymize<I9jd27rnpm8ttv>;
        "Member": SS58String;
        "_Phantom": undefined;
    }>;
}>;
export type Ieunmr2qhp2i5r = Array<{
    "id": Enum<{
        "Contracts": Enum<{
            "CodeUploadDepositReserve": undefined;
            "StorageDepositReserve": undefined;
        }>;
        "Preimage": PreimagePalletHoldReason;
        "Council": Enum<{
            "ProposalSubmission": undefined;
        }>;
        "TechnicalCommittee": Enum<{
            "ProposalSubmission": undefined;
        }>;
        "CommunityCouncil": Enum<{
            "ProposalSubmission": undefined;
        }>;
        "SafeMode": Enum<{
            "EnterOrExtend": undefined;
        }>;
    }>;
    "amount": bigint;
}>;
export type I2q9fuah4a3jol = Array<{
    "id": Enum<{
        "DappStaking": Enum<{
            "DAppStaking": undefined;
        }>;
    }>;
    "amount": bigint;
}>;
export type I7tcevi26u67t9 = {
    "max_inflation_rate": bigint;
    "treasury_part": bigint;
    "collators_part": bigint;
    "dapps_part": bigint;
    "base_stakers_part": bigint;
    "adjustable_stakers_part": bigint;
    "bonus_part": bigint;
    "ideal_staking_rate": bigint;
};
export type I8phdsiu944qnt = {
    "era": number;
    "next_era_start": number;
    "period_info": {
        "number": number;
        "subperiod": Anonymize<I3vks5eusshcrb>;
        "next_subperiod_start_era": number;
    };
    "maintenance": boolean;
};
export type Ifd5a3glv206mk = {
    "owner": SS58String;
    "id": number;
    "reward_beneficiary"?: Anonymize<Ihfphjolmsqq1>;
};
export type Iaj10rr82j0c8f = {
    "locked": bigint;
    "unlocking": Array<{
        "amount": bigint;
        "unlock_block": number;
    }>;
    "staked": Anonymize<I8mljocu4hh45t>;
    "staked_future"?: Anonymize<I6c2gmi5ft9f22>;
    "contract_stake_count": number;
};
export type I8mljocu4hh45t = {
    "voting": bigint;
    "build_and_earn": bigint;
    "era": number;
    "period": number;
};
export type I6c2gmi5ft9f22 = (Anonymize<I8mljocu4hh45t>) | undefined;
export type I9fikrhe4v1ucd = {
    "previous_staked": Anonymize<I8mljocu4hh45t>;
    "staked": Anonymize<I8mljocu4hh45t>;
    "bonus_status": number;
};
export type Ial7b1ao1svgpg = [SS58String, Anonymize<Iav11gpk2hk471>];
export type I48d4i9nskqi1t = {
    "staked": Anonymize<I8mljocu4hh45t>;
    "staked_future"?: Anonymize<I6c2gmi5ft9f22>;
};
export type Ie0insqitg6p08 = {
    "total_locked": bigint;
    "unlocking": bigint;
    "current_stake_amount": Anonymize<I8mljocu4hh45t>;
    "next_stake_amount": Anonymize<I8mljocu4hh45t>;
};
export type Iu5bstpont1pd = {
    "span": Array<{
        "staker_reward_pool": bigint;
        "staked": bigint;
        "dapp_reward_pool": bigint;
    }>;
    "first_era": number;
    "last_era": number;
};
export type Ibbe0vuef8idk = {
    "bonus_reward_pool": bigint;
    "total_vp_stake": bigint;
    "final_era": number;
};
export type I9qkqq3bm9meai = {
    "slots_per_tier": Anonymize<Icgljjb6j82uhn>;
    "reward_portion": Anonymize<Icgljjb6j82uhn>;
    "tier_thresholds": Anonymize<Iafqnechp3omqg>;
};
export type I401ur5btmdhug = {
    "dapps": Anonymize<Iep4uo61810hfs>;
    "rewards": Anonymize<Iafqnechp3omqg>;
    "period": number;
    "rank_rewards": Anonymize<Iafqnechp3omqg>;
};
export type I6ugqeqscrtvjd = {
    "era_reward_index": number;
    "dapp_tiers_index": number;
    "oldest_valid_era": number;
};
export type I3qklfjubrljqh = {
    "owner": SS58String;
    "issuer": SS58String;
    "admin": SS58String;
    "freezer": SS58String;
    "supply": bigint;
    "deposit": bigint;
    "min_balance": bigint;
    "is_sufficient": boolean;
    "accounts": number;
    "sufficients": number;
    "approvals": number;
    "status": Anonymize<I3sd59779ndgs3>;
};
export type Iag3f1hum3p4c8 = {
    "balance": bigint;
    "status": Anonymize<Icvjt1ogfma62c>;
    "reason": Enum<{
        "Consumer": undefined;
        "Sufficient": undefined;
        "DepositHeld": bigint;
        "DepositRefunded": undefined;
        "DepositFrom": Anonymize<I95l2k9b1re95f>;
    }>;
};
export type I96rqo4i9p11oo = [bigint, SS58String];
export type I6lsoh4c5um3u5 = [bigint, SS58String, SS58String];
export type I3p18dmhknth6v = {
    "total": bigint;
    "count": number;
    "limit_block": number;
};
export type I7jk416ehc2eh1 = {
    "buffer": Anonymize<Iafqnechp3omqg>;
    "head": number;
};
export type I2m57u1h2te06 = [SS58String, Anonymize<I4rgf5d3abfav5>];
export type Ifi4da1gej1fri = Array<Anonymize<Iep1lmt6q3s6r3>>;
export type I5kulbesqc1h1t = {
    "owner": SS58String;
    "deposit": bigint;
    "refcount": bigint;
    "determinism": Anonymize<I2dfliekq1ed7e>;
    "code_len": number;
};
export type I2dfliekq1ed7e = AnonymousEnum<{
    "Enforced": undefined;
    "Relaxed": undefined;
}>;
export type I36dvimehsh2tm = {
    "trie_id": Binary;
    "code_hash": FixedSizeBinary<32>;
    "storage_bytes": number;
    "storage_items": number;
    "storage_byte_deposit": bigint;
    "storage_item_deposit": bigint;
    "storage_base_deposit": bigint;
    "delegate_dependencies": Anonymize<I3geksg000c171>;
};
export type I8t4pajubp34g3 = {
    "insert_counter": number;
    "delete_counter": number;
};
export type Iedia33gem7v9i = AnonymousEnum<{
    "System": Anonymize<Iekve0i6djpd9f>;
    "Utility": Anonymize<I92vsouqf755oh>;
    "Identity": Anonymize<Iceqdqk5ub0l9g>;
    "Timestamp": Anonymize<I7d75gqfg6jh9c>;
    "Multisig": Anonymize<Icqnu02gicl6p1>;
    "Proxy": Anonymize<Ice0gn5d4d22bv>;
    "Scheduler": Anonymize<I4fsi56e8gn5tr>;
    "ParachainSystem": Anonymize<I5kev21p7u6ajb>;
    "ParachainInfo": undefined;
    "Balances": Anonymize<I9svldsp29mh87>;
    "Vesting": Anonymize<Icgf8vmtkbnu4u>;
    "Inflation": Anonymize<I85v1potgq51pp>;
    "DappStaking": Anonymize<Ib0qjtgokq6g7v>;
    "Assets": Anonymize<Ib3g8udrt51sl>;
    "Oracle": Anonymize<Ifl086npogc0of>;
    "OracleMembership": Anonymize<I6tsknu13e0euf>;
    "CollatorSelection": Anonymize<Ifqhg2ehumpe7u>;
    "Session": Anonymize<I77dda7hps0u37>;
    "XcmpQueue": Anonymize<Ib7tahn20bvsep>;
    "PolkadotXcm": Anonymize<I4up31a3q8cjhp>;
    "CumulusXcm": undefined;
    "XcAssetConfig": Anonymize<Ivptdul5886lq>;
    "XTokens": Anonymize<I96hq8r3ldthga>;
    "MessageQueue": Anonymize<Ic2uoe7jdksosp>;
    "EVM": Anonymize<I8s4v176jtv80g>;
    "Ethereum": Anonymize<Icu3fce0sripq4>;
    "DynamicEvmBaseFee": Anonymize<I21e00p8nqldhr>;
    "Contracts": Anonymize<I6jivj2j5qp8sa>;
    "Preimage": Anonymize<If81ks88t5mpk5>;
    "Sudo": Anonymize<I6su2fahl42451>;
    "CouncilMembership": Anonymize<I6tsknu13e0euf>;
    "TechnicalCommitteeMembership": Anonymize<I6tsknu13e0euf>;
    "CommunityCouncilMembership": Anonymize<I6tsknu13e0euf>;
    "Council": Anonymize<Ifclk240k6qfq4>;
    "TechnicalCommittee": Anonymize<Ifclk240k6qfq4>;
    "CommunityCouncil": Anonymize<Ifclk240k6qfq4>;
    "Democracy": Anonymize<I10dimmis6musr>;
    "Treasury": Anonymize<I2lbur1vp3trot>;
    "CommunityTreasury": Anonymize<I2lbur1vp3trot>;
    "CollectiveProxy": Anonymize<Ibrvh54g79pa9u>;
    "SafeMode": Anonymize<I48eehof2eias5>;
    "TxPause": Anonymize<Ieci88jft3cpv9>;
    "MultiBlockMigrations": Anonymize<I4oqb168b2d4er>;
}>;
export type I92vsouqf755oh = AnonymousEnum<{
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    "batch": Anonymize<I6354v7vk6isdi>;
    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     */
    "as_derivative": Anonymize<I212sfinbrq59j>;
    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    "batch_all": Anonymize<I6354v7vk6isdi>;
    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     */
    "dispatch_as": Anonymize<I3m33kbl64q02r>;
    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    "force_batch": Anonymize<I6354v7vk6isdi>;
    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     */
    "with_weight": Anonymize<Iac53udfpd9th9>;
}>;
export type I6354v7vk6isdi = {
    "calls": Array<TxCallData>;
};
export type I212sfinbrq59j = {
    "index": number;
    "call": TxCallData;
};
export type I3m33kbl64q02r = {
    "as_origin": Anonymize<Iekimmnjq021gh>;
    "call": TxCallData;
};
export type Iac53udfpd9th9 = {
    "call": TxCallData;
    "weight": Anonymize<I4q39t5hn830vp>;
};
export type Iceqdqk5ub0l9g = AnonymousEnum<{
    /**
     * Add a registrar to the system.
     *
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     *
     * - `account`: the account of the registrar.
     *
     * Emits `RegistrarAdded` if successful.
     */
    "add_registrar": Anonymize<Ic6cqd9g0t65v0>;
    /**
     * Set an account's identity information and reserve the appropriate deposit.
     *
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `info`: The identity information.
     *
     * Emits `IdentitySet` if successful.
     */
    "set_identity": Anonymize<I2kds5jji7slh8>;
    /**
     * Set the sub-accounts of the sender.
     *
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * - `subs`: The identity's (new) sub-accounts.
     */
    "set_subs": Anonymize<Ia9mkdf6l44shb>;
    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     *
     * Payment: All reserved balances on the account are returned.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     *
     * Emits `IdentityCleared` if successful.
     */
    "clear_identity": undefined;
    /**
     * Request a judgement from a registrar.
     *
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     *
     * ```nocompile
     * Registrars::<T>::get().get(reg_index).unwrap().fee
     * ```
     *
     * Emits `JudgementRequested` if successful.
     */
    "request_judgement": Anonymize<I9l2s4klu0831o>;
    /**
     * Cancel a previous request.
     *
     * Payment: A previously reserved deposit is returned on success.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     *
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     *
     * Emits `JudgementUnrequested` if successful.
     */
    "cancel_request": Anonymize<I2ctrt5nqb8o7c>;
    /**
     * Set the fee required for a judgement to be requested from a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     */
    "set_fee": Anonymize<I711qahikocb1c>;
    /**
     * Change the account associated with a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     */
    "set_account_id": Anonymize<I6o1er683vod1j>;
    /**
     * Set the field information for a registrar.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     *
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     */
    "set_fields": Anonymize<Id6gojh30v9ib2>;
    /**
     * Provide a judgement for an account's identity.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     *
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInformationProvider`] for that the judgement is
     * provided.
     *
     * Note: Judgements do not apply to a username.
     *
     * Emits `JudgementGiven` if successful.
     */
    "provide_judgement": Anonymize<Ide1bahhh47lj9>;
    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     *
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     *
     * The dispatch origin for this call must match `T::ForceOrigin`.
     *
     * - `target`: the account whose identity the judgement is upon. This must be an account
     * with a registered identity.
     *
     * Emits `IdentityKilled` if successful.
     */
    "kill_identity": Anonymize<Id9uqtigc0il3v>;
    /**
     * Add the given account to the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    "add_sub": Anonymize<Ic68lsi7chpv5k>;
    /**
     * Alter the associated name of the given sub-account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    "rename_sub": Anonymize<Ic68lsi7chpv5k>;
    /**
     * Remove the given account from the sender's subs.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    "remove_sub": Anonymize<Iek0boln8pgnko>;
    /**
     * Remove the sender as a sub-account.
     *
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     *
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     */
    "quit_sub": undefined;
    /**
     * Add an `AccountId` with permission to grant usernames with a given `suffix` appended.
     *
     * The authority can grant up to `allocation` usernames. To top up the allocation or
     * change the account used to grant usernames, this call can be used with the updated
     * parameters to overwrite the existing configuration.
     */
    "add_username_authority": Anonymize<I452bkd71b385t>;
    /**
     * Remove `authority` from the username authorities.
     */
    "remove_username_authority": Anonymize<Ie83f0p0ke1f4u>;
    /**
     * Set the username for `who`. Must be called by a username authority.
     *
     * If `use_allocation` is set, the authority must have a username allocation available to
     * spend. Otherwise, the authority will need to put up a deposit for registering the
     * username.
     *
     * Users can either pre-sign their usernames or
     * accept them later.
     *
     * Usernames must:
     * - Only contain lowercase ASCII characters or digits.
     * - When combined with the suffix of the issuing authority be _less than_ the
     * `MaxUsernameLength`.
     */
    "set_username_for": Anonymize<I93hi4ed10h5sc>;
    /**
     * Accept a given username that an `authority` granted. The call must include the full
     * username, as in `username.suffix`.
     */
    "accept_username": Anonymize<Ie5l999tf7t2te>;
    /**
     * Remove an expired username approval. The username was approved by an authority but never
     * accepted by the user and must now be beyond its expiration. The call must include the
     * full username, as in `username.suffix`.
     */
    "remove_expired_approval": Anonymize<Ie5l999tf7t2te>;
    /**
     * Set a given username as the primary. The username should include the suffix.
     */
    "set_primary_username": Anonymize<Ie5l999tf7t2te>;
    /**
     * Start the process of removing a username by placing it in the unbinding usernames map.
     * Once the grace period has passed, the username can be deleted by calling
     * [remove_username](crate::Call::remove_username).
     */
    "unbind_username": Anonymize<Ie5l999tf7t2te>;
    /**
     * Permanently delete a username which has been unbinding for longer than the grace period.
     * Caller is refunded the fee if the username expired and the removal was successful.
     */
    "remove_username": Anonymize<Ie5l999tf7t2te>;
    /**
     * Call with [ForceOrigin](crate::Config::ForceOrigin) privileges which deletes a username
     * and slashes any deposit associated with it.
     */
    "kill_username": Anonymize<Ie5l999tf7t2te>;
}>;
export type Ic6cqd9g0t65v0 = {
    "account": MultiAddress;
};
export type Ide1bahhh47lj9 = {
    "reg_index": number;
    "target": MultiAddress;
    "judgement": IdentityJudgement;
    "identity": FixedSizeBinary<32>;
};
export type Ic68lsi7chpv5k = {
    "sub": MultiAddress;
    "data": IdentityData;
};
export type Iek0boln8pgnko = {
    "sub": MultiAddress;
};
export type I452bkd71b385t = {
    "authority": MultiAddress;
    "suffix": Binary;
    "allocation": number;
};
export type Ie83f0p0ke1f4u = {
    "suffix": Binary;
    "authority": MultiAddress;
};
export type I93hi4ed10h5sc = {
    "who": MultiAddress;
    "username": Binary;
    "signature"?: Anonymize<I86cdjmsf3a81s>;
    "use_allocation": boolean;
};
export type Icqnu02gicl6p1 = AnonymousEnum<{
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    "as_multi_threshold_1": Anonymize<I5446n5co0ed1j>;
    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    "as_multi": Anonymize<I4i1j1ndqab7g4>;
    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    "approve_as_multi": Anonymize<Ideaemvoneh309>;
    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     */
    "cancel_as_multi": Anonymize<I3d9o9d7epp66v>;
}>;
export type I5446n5co0ed1j = {
    "other_signatories": Anonymize<Ia2lhg7l2hilo3>;
    "call": TxCallData;
};
export type I4i1j1ndqab7g4 = {
    "threshold": number;
    "other_signatories": Anonymize<Ia2lhg7l2hilo3>;
    "maybe_timepoint"?: Anonymize<I95jfd8j5cr5eh>;
    "call": TxCallData;
    "max_weight": Anonymize<I4q39t5hn830vp>;
};
export type Ice0gn5d4d22bv = AnonymousEnum<{
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    "proxy": Anonymize<I6hjsnil65jnij>;
    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     */
    "add_proxy": Anonymize<Ic6nou6182ifhl>;
    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     */
    "remove_proxy": Anonymize<Ic6nou6182ifhl>;
    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     */
    "remove_proxies": undefined;
    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     */
    "create_pure": Anonymize<I88pucb8kov85q>;
    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     */
    "kill_pure": Anonymize<I6pj68nqoamrv3>;
    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    "announce": Anonymize<I2eb501t8s6hsq>;
    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    "remove_announcement": Anonymize<I2eb501t8s6hsq>;
    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     */
    "reject_announcement": Anonymize<Ianmuoljk2sk1u>;
    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    "proxy_announced": Anonymize<I1j96bgkijv0f7>;
}>;
export type I6hjsnil65jnij = {
    "real": MultiAddress;
    "force_proxy_type"?: Anonymize<I7e29mp9tdeogl>;
    "call": TxCallData;
};
export type I7e29mp9tdeogl = (Anonymize<I1cil00f0vjusj>) | undefined;
export type Ic6nou6182ifhl = {
    "delegate": MultiAddress;
    "proxy_type": Anonymize<I1cil00f0vjusj>;
    "delay": number;
};
export type I88pucb8kov85q = {
    "proxy_type": Anonymize<I1cil00f0vjusj>;
    "delay": number;
    "index": number;
};
export type I6pj68nqoamrv3 = {
    "spawner": MultiAddress;
    "proxy_type": Anonymize<I1cil00f0vjusj>;
    "index": number;
    "height": number;
    "ext_index": number;
};
export type I1j96bgkijv0f7 = {
    "delegate": MultiAddress;
    "real": MultiAddress;
    "force_proxy_type"?: Anonymize<I7e29mp9tdeogl>;
    "call": TxCallData;
};
export type I4fsi56e8gn5tr = AnonymousEnum<{
    /**
     * Anonymously schedule a task.
     */
    "schedule": Anonymize<Ie70svc64j0nnt>;
    /**
     * Cancel an anonymously scheduled task.
     */
    "cancel": Anonymize<I5n4sebgkfr760>;
    /**
     * Schedule a named task.
     */
    "schedule_named": Anonymize<I23k0fcc4s93a8>;
    /**
     * Cancel a named scheduled task.
     */
    "cancel_named": Anonymize<Ifs1i5fk9cqvr6>;
    /**
     * Anonymously schedule a task after a delay.
     */
    "schedule_after": Anonymize<I6pvj8ig4if6s7>;
    /**
     * Schedule a named task after a delay.
     */
    "schedule_named_after": Anonymize<Ic5eombv5ft85j>;
    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     */
    "set_retry": Anonymize<Ieg3fd8p4pkt10>;
    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     */
    "set_retry_named": Anonymize<I8kg5ll427kfqq>;
    /**
     * Removes the retry configuration of a task.
     */
    "cancel_retry": Anonymize<I467333262q1l9>;
    /**
     * Cancel the retry configuration of a named task.
     */
    "cancel_retry_named": Anonymize<Ifs1i5fk9cqvr6>;
}>;
export type Ie70svc64j0nnt = {
    "when": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I23k0fcc4s93a8 = {
    "id": FixedSizeBinary<32>;
    "when": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I6pvj8ig4if6s7 = {
    "after": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type Ic5eombv5ft85j = {
    "id": FixedSizeBinary<32>;
    "after": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I85v1potgq51pp = AnonymousEnum<{
    /**
     * Used to force-set the inflation parameters.
     * The parameters must be valid, all parts summing up to one whole (100%), otherwise the call will fail.
     *
     * Must be called by `root` origin.
     *
     * Purpose of the call is testing & handling unforeseen circumstances.
     */
    "force_set_inflation_params": Anonymize<Icliq7k77rho5u>;
    /**
     * Used to force inflation recalculation.
     * This is done in the same way as it would be done in an appropriate block, but this call forces it.
     *
     * Must be called by `root` origin.
     *
     * Purpose of the call is testing & handling unforeseen circumstances.
     */
    "force_inflation_recalculation": Anonymize<I8b3c98srssokg>;
    /**
     * Re-adjust the existing inflation configuration using the current inflation parameters.
     *
     * It might seem similar to forcing the inflation recalculation, but it's not.
     * This function adjusts the existing configuration, respecting the `max_emission` value used to calculate the current inflation config.
     * (The 'force' approach uses the current total issuance)
     *
     * This call should be used in case inflation parameters have changed during the cycle, and the configuration should be adjusted now.
     *
     * NOTE:
     * The call will do the best possible approximation of what the calculated max emission was at the moment when last inflation recalculation was done.
     * But due to rounding losses, it's not possible to get the exact same value. As a consequence, repeated calls to this function
     * might result in changes to the configuration, even though the inflation parameters haven't changed.
     * However, since this function isn't supposed to be called often, and changes are minimal, this is acceptable.
     */
    "force_readjust_config": undefined;
}>;
export type Icliq7k77rho5u = {
    "params": Anonymize<I7tcevi26u67t9>;
};
export type I8b3c98srssokg = {
    "next_era": number;
};
export type Ib0qjtgokq6g7v = AnonymousEnum<{
    /**
     * Wrapper around _legacy-like_ `unbond_and_unstake`.
     *
     * Used to support legacy Ledger users so they can start the unlocking process for their funds.
     */
    "unbond_and_unstake": Anonymize<I4qmlavafr3140>;
    /**
     * Wrapper around _legacy-like_ `withdraw_unbonded`.
     *
     * Used to support legacy Ledger users so they can reclaim unlocked chunks back into
     * their _transferable_ free balance.
     */
    "withdraw_unbonded": undefined;
    /**
     * Used to enable or disable maintenance mode.
     * Can only be called by manager origin.
     */
    "maintenance_mode": Anonymize<I94dejtmu6d72i>;
    /**
     * Used to register a new contract for dApp staking.
     *
     * If successful, smart contract will be assigned a simple, unique numerical identifier.
     * Owner is set to be initial beneficiary & manager of the dApp.
     */
    "register": Anonymize<Iacbdote4b7l9k>;
    /**
     * Used to modify the reward beneficiary account for a dApp.
     *
     * Caller has to be dApp owner.
     * If set to `None`, rewards will be deposited to the dApp owner.
     * After this call, all existing & future rewards will be paid out to the beneficiary.
     */
    "set_dapp_reward_beneficiary": Anonymize<I9ed9v9gosmuvf>;
    /**
     * Used to change dApp owner.
     *
     * Can be called by dApp owner or dApp staking manager origin.
     * This is useful in two cases:
     * 1. when the dApp owner account is compromised, manager can change the owner to a new account
     * 2. if project wants to transfer ownership to a new account (DAO, multisig, etc.).
     */
    "set_dapp_owner": Anonymize<Ibeb69neo60gk0>;
    /**
     * Unregister dApp from dApp staking protocol, making it ineligible for future rewards.
     * This doesn't remove the dApp completely from the system just yet, but it can no longer be used for staking.
     *
     * Can be called by dApp staking manager origin.
     */
    "unregister": Anonymize<I1gnudop2p29el>;
    /**
     * Locks additional funds into dApp staking.
     *
     * In case caller account doesn't have sufficient balance to cover the specified amount, everything is locked.
     * After adjustment, lock amount must be greater than zero and in total must be equal or greater than the minimum locked amount.
     *
     * Locked amount can immediately be used for staking.
     */
    "lock": Anonymize<I3qt1hgg4djhgb>;
    /**
     * Attempts to start the unlocking process for the specified amount.
     *
     * Only the amount that isn't actively used for staking can be unlocked.
     * If the amount is greater than the available amount for unlocking, everything is unlocked.
     * If the remaining locked amount would take the account below the minimum locked amount, everything is unlocked.
     */
    "unlock": Anonymize<I3qt1hgg4djhgb>;
    /**
     * Claims all of fully unlocked chunks, removing the lock from them.
     */
    "claim_unlocked": undefined;
    "relock_unlocking": undefined;
    /**
     * Stake the specified amount on a smart contract.
     * The precise `amount` specified **must** be available for staking.
     * The total amount staked on a dApp must be greater than the minimum required value.
     *
     * Depending on the period type, appropriate stake amount will be updated. During `Voting` subperiod, `voting` stake amount is updated,
     * and same for `Build&Earn` subperiod.
     *
     * Staked amount is only eligible for rewards from the next era onwards.
     */
    "stake": Anonymize<I3sves7o9bnl87>;
    /**
     * Unstake the specified amount from a smart contract.
     * The `amount` specified **must** not exceed what's staked, otherwise the call will fail.
     *
     * If unstaking the specified `amount` would take staker below the minimum stake threshold, everything is unstaked.
     *
     * Depending on the period type, appropriate stake amount will be updated.
     * In case amount is unstaked during `Voting` subperiod, the `voting` amount is reduced.
     * In case amount is unstaked during `Build&Earn` subperiod, first the `build_and_earn` is reduced,
     * and any spillover is subtracted from the `voting` amount.
     */
    "unstake": Anonymize<I3sves7o9bnl87>;
    /**
     * Claims some staker rewards, if user has any.
     * In the case of a successful call, at least one era will be claimed, with the possibility of multiple claims happening.
     */
    "claim_staker_rewards": undefined;
    /**
     * Used to claim bonus reward for a smart contract, if eligible.
     */
    "claim_bonus_reward": Anonymize<I1gnudop2p29el>;
    /**
     * Used to claim dApp reward for the specified era.
     */
    "claim_dapp_reward": Anonymize<Ibo4omgp8fpt5t>;
    /**
     * Used to unstake funds from a contract that was unregistered after an account staked on it.
     * This is required if staker wants to re-stake these funds on another active contract during the ongoing period.
     */
    "unstake_from_unregistered": Anonymize<I1gnudop2p29el>;
    /**
     * Cleanup expired stake entries for the contract.
     *
     * Entry is considered to be expired if:
     * 1. It's from a past period & the account did not maintain an eligible bonus status, meaning there's no claimable bonus reward.
     * 2. It's from a period older than the oldest claimable period, regardless of whether the account had an eligible bonus status or not.
     */
    "cleanup_expired_entries": undefined;
    /**
     * Used to force a change of era or subperiod.
     * The effect isn't immediate but will happen on the next block.
     *
     * Used for testing purposes, when we want to force an era change, or a subperiod change.
     * Not intended to be used in production, except in case of unforeseen circumstances.
     *
     * Can only be called by the root origin.
     */
    "force": Anonymize<Id0smhn7t7eh6l>;
    /**
     * Claims some staker rewards for the specified account, if they have any.
     * In the case of a successful call, at least one era will be claimed, with the possibility of multiple claims happening.
     */
    "claim_staker_rewards_for": Anonymize<Icbccs0ug47ilf>;
    /**
     * Used to claim bonus reward for a smart contract on behalf of the specified account, if eligible.
     */
    "claim_bonus_reward_for": Anonymize<I88tgaqco9fme4>;
    /**
     * Transfers stake between two smart contracts, ensuring bonus status preservation if eligible.
     * Emits a `StakeMoved` event.
     */
    "move_stake": Anonymize<Id8elld05mas9j>;
    /**
     * Used to set static tier parameters, which are used to calculate tier configuration.
     * Tier configuration defines tier entry threshold values, number of slots, and reward portions.
     *
     * This is a delicate call and great care should be taken when changing these
     * values since it has a significant impact on the reward system.
     */
    "set_static_tier_params": Anonymize<Iceqdqbv3mc6o0>;
}>;
export type I4qmlavafr3140 = {
    "contract_id": Anonymize<Iav11gpk2hk471>;
    "value": bigint;
};
export type Iacbdote4b7l9k = {
    "owner": SS58String;
    "smart_contract": Anonymize<Iav11gpk2hk471>;
};
export type I1gnudop2p29el = {
    "smart_contract": Anonymize<Iav11gpk2hk471>;
};
export type I3sves7o9bnl87 = {
    "smart_contract": Anonymize<Iav11gpk2hk471>;
    "amount": bigint;
};
export type I88tgaqco9fme4 = {
    "account": SS58String;
    "smart_contract": Anonymize<Iav11gpk2hk471>;
};
export type Id8elld05mas9j = {
    "source_contract": Anonymize<Iav11gpk2hk471>;
    "destination_contract": Anonymize<Iav11gpk2hk471>;
    "amount": bigint;
};
export type Ib3g8udrt51sl = AnonymousEnum<{
    /**
     * Issue a new class of fungible assets from a public origin.
     *
     * This new asset class has no assets initially and its owner is the origin.
     *
     * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
     *
     * Funds of sender are reserved by `AssetDeposit`.
     *
     * Parameters:
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `admin`: The admin of this class of assets. The admin is the initial address of each
     * member of the asset class's admin team.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `Created` event when successful.
     *
     * Weight: `O(1)`
     */
    "create": Anonymize<Idutup0e9rh8so>;
    /**
     * Issue a new class of fungible assets from a privileged origin.
     *
     * This new asset class has no assets initially.
     *
     * The origin must conform to `ForceOrigin`.
     *
     * Unlike `create`, no funds are reserved.
     *
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `owner`: The owner of this class of assets. The owner has full superuser permissions
     * over this asset, but may later change and configure the permissions using
     * `transfer_ownership` and `set_team`.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `ForceCreated` event when successful.
     *
     * Weight: `O(1)`
     */
    "force_create": Anonymize<I6do0sq1390ag>;
    /**
     * Start the process of destroying a fungible asset class.
     *
     * `start_destroy` is the first in a series of extrinsics that should be called, to allow
     * destruction of an asset class.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     */
    "start_destroy": Anonymize<I4ov6e94l79mbg>;
    /**
     * Destroy all accounts associated with a given asset.
     *
     * `destroy_accounts` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedAccounts` event.
     */
    "destroy_accounts": Anonymize<I4ov6e94l79mbg>;
    /**
     * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
     *
     * `destroy_approvals` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedApprovals` event.
     */
    "destroy_approvals": Anonymize<I4ov6e94l79mbg>;
    /**
     * Complete destroying asset and unreserve currency.
     *
     * `finish_destroy` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
     * hand.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each successful call emits the `Event::Destroyed` event.
     */
    "finish_destroy": Anonymize<I4ov6e94l79mbg>;
    /**
     * Mint assets of a particular class.
     *
     * The origin must be Signed and the sender must be the Issuer of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount minted.
     * - `beneficiary`: The account to be credited with the minted assets.
     * - `amount`: The amount of the asset to be minted.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
     */
    "mint": Anonymize<Ieeuglrrm65jt2>;
    /**
     * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
     *
     * Origin must be Signed and the sender should be the Manager of the asset `id`.
     *
     * Bails with `NoAccount` if the `who` is already dead.
     *
     * - `id`: The identifier of the asset to have some amount burned.
     * - `who`: The account to be debited from.
     * - `amount`: The maximum amount by which `who`'s balance should be reduced.
     *
     * Emits `Burned` with the actual amount burned. If this takes the balance to below the
     * minimum for the asset, then the amount burned is increased to take it to zero.
     *
     * Weight: `O(1)`
     * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
     */
    "burn": Anonymize<I2ft0f2thgfe6s>;
    /**
     * Move some assets from the sender account to another.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     */
    "transfer": Anonymize<I6ucaoml0igais>;
    /**
     * Move some assets from the sender account to another, keeping the sender account alive.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     */
    "transfer_keep_alive": Anonymize<I6ucaoml0igais>;
    /**
     * Move some assets from one account to another.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `source`: The account to be debited.
     * - `dest`: The account to be credited.
     * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
     * `dest`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the `source` balance above zero but
     * below the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
     * `dest`.
     */
    "force_transfer": Anonymize<I1phnros9ogpsl>;
    /**
     * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
     * must already exist as an entry in `Account`s of the asset. If you want to freeze an
     * account that does not have an entry, use `touch_other` first.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     */
    "freeze": Anonymize<I5rkc9t64qoc30>;
    /**
     * Allow unprivileged transfers to and from an account again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be unfrozen.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     */
    "thaw": Anonymize<I5rkc9t64qoc30>;
    /**
     * Disallow further unprivileged transfers for the asset class.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     */
    "freeze_asset": Anonymize<I4ov6e94l79mbg>;
    /**
     * Allow unprivileged transfers for the asset again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be thawed.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     */
    "thaw_asset": Anonymize<I4ov6e94l79mbg>;
    /**
     * Change the Owner of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     */
    "transfer_ownership": Anonymize<I9645mveijv32q>;
    /**
     * Change the Issuer, Admin and Freezer of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     *
     * Emits `TeamChanged`.
     *
     * Weight: `O(1)`
     */
    "set_team": Anonymize<Idod2koqj2eu8c>;
    /**
     * Set the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Funds of sender are reserved according to the formula:
     * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
     * account any already reserved funds.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(1)`
     */
    "set_metadata": Anonymize<I87vll2k0a91o2>;
    /**
     * Clear the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Any deposit is freed for the asset owner.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     */
    "clear_metadata": Anonymize<I4ov6e94l79mbg>;
    /**
     * Force the metadata for an asset to some value.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is left alone.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
     */
    "force_set_metadata": Anonymize<Iekaug5vo6n1jh>;
    /**
     * Clear the metadata for an asset.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is returned.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     */
    "force_clear_metadata": Anonymize<I4ov6e94l79mbg>;
    /**
     * Alter the attributes of a given asset.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
     * value to account for the state bloat associated with its balance storage. If set to
     * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
     * an ED in the Balances pallet or whatever else is used to control user-account state
     * growth).
     * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
     * instructions.
     *
     * Emits `AssetStatusChanged` with the identity of the asset.
     *
     * Weight: `O(1)`
     */
    "force_asset_status": Anonymize<Ia8hsbfe3gjnab>;
    /**
     * Approve an amount of asset for transfer by a delegated third-party account.
     *
     * Origin must be Signed.
     *
     * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
     * for the purpose of holding the approval. If some non-zero amount of assets is already
     * approved from signing account to `delegate`, then it is topped up or unreserved to
     * meet the right value.
     *
     * NOTE: The signing account does not need to own `amount` of assets at the point of
     * making this call.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account to delegate permission to transfer asset.
     * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
     * already an approval in place, then this acts additively.
     *
     * Emits `ApprovedTransfer` on success.
     *
     * Weight: `O(1)`
     */
    "approve_transfer": Anonymize<Ibjm53301mul3h>;
    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be Signed and there must be an approval in place between signer and
     * `delegate`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     */
    "cancel_approval": Anonymize<I9ei5lgjti2qla>;
    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
     * account of the asset `id`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     */
    "force_cancel_approval": Anonymize<I54bd0s1iunkmg>;
    /**
     * Transfer some asset balance from a previously delegated account to some third-party
     * account.
     *
     * Origin must be Signed and there must be an approval in place by the `owner` to the
     * signer.
     *
     * If the entire amount approved for transfer is transferred, then any deposit previously
     * reserved by `approve_transfer` is unreserved.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The account which previously approved for a transfer of at least `amount` and
     * from which the asset balance will be withdrawn.
     * - `destination`: The account to which the asset balance of `amount` will be transferred.
     * - `amount`: The amount of assets to transfer.
     *
     * Emits `TransferredApproved` on success.
     *
     * Weight: `O(1)`
     */
    "transfer_approved": Anonymize<I3mmhckdribrl0>;
    /**
     * Create an asset account for non-provider assets.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
     * to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     *
     * Emits `Touched` event when successful.
     */
    "touch": Anonymize<I4ov6e94l79mbg>;
    /**
     * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
     * account.
     *
     * The origin must be Signed.
     *
     * - `id`: The identifier of the asset for which the caller would like the deposit
     * refunded.
     * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
     *
     * Emits `Refunded` event when successful.
     */
    "refund": Anonymize<Ib98qbv23c0tst>;
    /**
     * Sets the minimum balance of an asset.
     *
     * Only works if there aren't any accounts that are holding the asset or if
     * the new value of `min_balance` is less than the old one.
     *
     * Origin must be Signed and the sender has to be the Owner of the
     * asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `min_balance`: The new value of `min_balance`.
     *
     * Emits `AssetMinBalanceChanged` event when successful.
     */
    "set_min_balance": Anonymize<Iebdnbvufodnev>;
    /**
     * Create an asset account for `who`.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
     * must have sufficient funds for a deposit to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     * - `who`: The account to be created.
     *
     * Emits `Touched` event when successful.
     */
    "touch_other": Anonymize<I5rkc9t64qoc30>;
    /**
     * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
     *
     * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
     * order to burn a non-zero balance of the asset, the caller must be the account and should
     * use `refund`.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `who`: The account to refund.
     *
     * Emits `Refunded` event when successful.
     */
    "refund_other": Anonymize<I5rkc9t64qoc30>;
    /**
     * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the account's asset.
     * - `who`: The account to be unblocked.
     *
     * Emits `Blocked`.
     *
     * Weight: `O(1)`
     */
    "block": Anonymize<I5rkc9t64qoc30>;
    /**
     * Transfer the entire transferable balance from the caller asset account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any held, frozen, or minimum balance (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the asset account has, causing the sender asset account to be killed
     * (false), or transfer everything except at least the minimum balance, which will
     * guarantee to keep the sender asset account alive (true).
     */
    "transfer_all": Anonymize<Icfnagtb704sfq>;
}>;
export type Idutup0e9rh8so = {
    "id": bigint;
    "admin": MultiAddress;
    "min_balance": bigint;
};
export type I6do0sq1390ag = {
    "id": bigint;
    "owner": MultiAddress;
    "is_sufficient": boolean;
    "min_balance": bigint;
};
export type Ieeuglrrm65jt2 = {
    "id": bigint;
    "beneficiary": MultiAddress;
    "amount": bigint;
};
export type I2ft0f2thgfe6s = {
    "id": bigint;
    "who": MultiAddress;
    "amount": bigint;
};
export type I6ucaoml0igais = {
    "id": bigint;
    "target": MultiAddress;
    "amount": bigint;
};
export type I1phnros9ogpsl = {
    "id": bigint;
    "source": MultiAddress;
    "dest": MultiAddress;
    "amount": bigint;
};
export type I5rkc9t64qoc30 = {
    "id": bigint;
    "who": MultiAddress;
};
export type I9645mveijv32q = {
    "id": bigint;
    "owner": MultiAddress;
};
export type Idod2koqj2eu8c = {
    "id": bigint;
    "issuer": MultiAddress;
    "admin": MultiAddress;
    "freezer": MultiAddress;
};
export type Ia8hsbfe3gjnab = {
    "id": bigint;
    "owner": MultiAddress;
    "issuer": MultiAddress;
    "admin": MultiAddress;
    "freezer": MultiAddress;
    "min_balance": bigint;
    "is_sufficient": boolean;
    "is_frozen": boolean;
};
export type Ibjm53301mul3h = {
    "id": bigint;
    "delegate": MultiAddress;
    "amount": bigint;
};
export type I9ei5lgjti2qla = {
    "id": bigint;
    "delegate": MultiAddress;
};
export type I54bd0s1iunkmg = {
    "id": bigint;
    "owner": MultiAddress;
    "delegate": MultiAddress;
};
export type I3mmhckdribrl0 = {
    "id": bigint;
    "owner": MultiAddress;
    "destination": MultiAddress;
    "amount": bigint;
};
export type Icfnagtb704sfq = {
    "id": bigint;
    "dest": MultiAddress;
    "keep_alive": boolean;
};
export type Ifl086npogc0of = AnonymousEnum<{
    /**
     * Feed the external value.
     *
     * Require authorized operator.
     */
    "feed_values": Anonymize<Ia5sp8108pom8q>;
}>;
export type Ia5sp8108pom8q = {
    "values": Anonymize<I5ifetlpidfu5d>;
};
export type I6tsknu13e0euf = AnonymousEnum<{
    /**
     * Add a member `who` to the set.
     *
     * May only be called from `T::AddOrigin`.
     */
    "add_member": Anonymize<I59bngqm85b22v>;
    /**
     * Remove a member `who` from the set.
     *
     * May only be called from `T::RemoveOrigin`.
     */
    "remove_member": Anonymize<I59bngqm85b22v>;
    /**
     * Swap out one member `remove` for another `add`.
     *
     * May only be called from `T::SwapOrigin`.
     *
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    "swap_member": Anonymize<I4u4n2na1l5uo7>;
    /**
     * Change the membership to a new set, disregarding the existing membership. Be nice and
     * pass `members` pre-sorted.
     *
     * May only be called from `T::ResetOrigin`.
     */
    "reset_members": Anonymize<I3c63j6sh3evqn>;
    /**
     * Swap out the sending member for some other key `new`.
     *
     * May only be called from `Signed` origin of a current member.
     *
     * Prime membership is passed from the origin account to `new`, if extant.
     */
    "change_key": Anonymize<I8k3rnvpeeh4hv>;
    /**
     * Set the prime member. Must be a current member.
     *
     * May only be called from `T::PrimeOrigin`.
     */
    "set_prime": Anonymize<I59bngqm85b22v>;
    /**
     * Remove the prime member if it exists.
     *
     * May only be called from `T::PrimeOrigin`.
     */
    "clear_prime": undefined;
}>;
export type I59bngqm85b22v = {
    "who": MultiAddress;
};
export type I4u4n2na1l5uo7 = {
    "remove": MultiAddress;
    "add": MultiAddress;
};
export type I8k3rnvpeeh4hv = {
    "new": MultiAddress;
};
export type Ifqhg2ehumpe7u = AnonymousEnum<{
    /**
     * Set the list of invulnerable (fixed) collators.
     */
    "set_invulnerables": Anonymize<Ifccifqltb5obi>;
    /**
     * Set the ideal number of collators (not including the invulnerables).
     * If lowering this number, then the number of running collators could be higher than this figure.
     * Aside from that edge case, there should be no other way to have more collators than the desired number.
     */
    "set_desired_candidates": Anonymize<Iadtsfv699cq8b>;
    /**
     * Set the candidacy bond amount.
     */
    "set_candidacy_bond": Anonymize<Ialpmgmhr3gk5r>;
    /**
     * Register this account as a collator candidate. The account must (a) already have
     * registered session keys and (b) be able to reserve the `CandidacyBond`.
     *
     * This call is not available to `Invulnerable` collators.
     */
    "register_as_candidate": undefined;
    /**
     * Deregister `origin` as a collator candidate. Note that the collator can only leave on
     * session change. The `CandidacyBond` will start un-bonding process.
     *
     * This call will fail if the total number of candidates would drop below `MinCandidates`.
     *
     * This call is not available to `Invulnerable` collators.
     */
    "leave_intent": undefined;
    /**
     * Withdraw `CandidacyBond` after un-bonding period has finished.
     * This call will fail called during un-bonding or if there's no `CandidacyBound` reserved.
     */
    "withdraw_bond": undefined;
    /**
     * Set slash destination.
     * Use `Some` to deposit slashed balance into destination or `None` to burn it.
     */
    "set_slash_destination": Anonymize<I7q6elfrnn8uq9>;
    /**
     * Add an invulnerable collator.
     */
    "add_invulnerable": Anonymize<I4cbvqmqadhrea>;
    /**
     * Remove an invulnerable collator.
     */
    "remove_invulnerable": Anonymize<I4cbvqmqadhrea>;
}>;
export type Ifccifqltb5obi = {
    "new": Anonymize<Ia2lhg7l2hilo3>;
};
export type Iadtsfv699cq8b = {
    "max": number;
};
export type Ialpmgmhr3gk5r = {
    "bond": bigint;
};
export type I7q6elfrnn8uq9 = {
    "destination"?: Anonymize<Ihfphjolmsqq1>;
};
export type Ivptdul5886lq = AnonymousEnum<{
    /**
     * Register new asset location to asset Id mapping.
     *
     * This makes the asset eligible for XCM interaction.
     */
    "register_asset_location": Anonymize<I6j92ua76m1ueo>;
    /**
     * Change the amount of units we are charging per execution second
     * for a given AssetLocation.
     */
    "set_asset_units_per_second": Anonymize<Ifrvl64m5kq433>;
    /**
     * Change the xcm type mapping for a given asset Id.
     * The new asset type will inherit old `units per second` value.
     */
    "change_existing_asset_location": Anonymize<I3anl8n2fnr4bg>;
    /**
     * Removes asset from the set of supported payment assets.
     *
     * The asset can still be interacted with via XCM but it cannot be used to pay for execution time.
     */
    "remove_payment_asset": Anonymize<Ibmjtl75ptu606>;
    /**
     * Removes all information related to asset, removing it from XCM support.
     */
    "remove_asset": Anonymize<Ib9karr24cpmca>;
}>;
export type I3anl8n2fnr4bg = {
    "new_asset_location": XcmVersionedLocation;
    "asset_id": bigint;
};
export type I96hq8r3ldthga = AnonymousEnum<{
    /**
     * Transfer native currencies.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    "transfer": Anonymize<I17rade5afcmi9>;
    /**
     * Transfer `Asset`.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    "transfer_multiasset": Anonymize<Ifpfll8q52l7d8>;
    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     *
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    "transfer_with_fee": Anonymize<If7739d96jlocs>;
    /**
     * Transfer `Asset` specifying the fee and amount as separate.
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee` is the Asset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `Location` id.
     *
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    "transfer_multiasset_with_fee": Anonymize<Imdvokfbpi0mt>;
    /**
     * Transfer several currencies specifying the item to be used as fee
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    "transfer_multicurrencies": Anonymize<I4k9cid91h8bup>;
    /**
     * Transfer several `Asset` specifying the item to be used as fee
     *
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     *
     * `fee_item` is index of the Assets that we want to use for
     * payment
     *
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    "transfer_multiassets": Anonymize<Imgcatq9b2cl1>;
}>;
export type I17rade5afcmi9 = {
    "currency_id": bigint;
    "amount": bigint;
    "dest": XcmVersionedLocation;
    "dest_weight_limit": XcmV3WeightLimit;
};
export type If7739d96jlocs = {
    "currency_id": bigint;
    "amount": bigint;
    "fee": bigint;
    "dest": XcmVersionedLocation;
    "dest_weight_limit": XcmV3WeightLimit;
};
export type I4k9cid91h8bup = {
    "currencies": Array<Anonymize<I200n1ov5tbcvr>>;
    "fee_item": number;
    "dest": XcmVersionedLocation;
    "dest_weight_limit": XcmV3WeightLimit;
};
export type I21e00p8nqldhr = AnonymousEnum<{
    /**
     * `root-only` extrinsic to set the `base_fee_per_gas` value manually.
     * The specified value has to respect min & max limits configured in the runtime.
     */
    "set_base_fee_per_gas": Anonymize<I7vi74gbubc8u5>;
}>;
export type I6jivj2j5qp8sa = AnonymousEnum<{
    /**
     * Deprecated version if [`Self::call`] for use in an in-storage `Call`.
     */
    "call_old_weight": Anonymize<Ia2rnh5pfua40a>;
    /**
     * Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`.
     */
    "instantiate_with_code_old_weight": Anonymize<I3otc7e9a35k1k>;
    /**
     * Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`.
     */
    "instantiate_old_weight": Anonymize<I89ier5tb9ne0s>;
    /**
     * Upload new `code` without instantiating a contract from it.
     *
     * If the code does not already exist a deposit is reserved from the caller
     * and unreserved only when [`Self::remove_code`] is called. The size of the reserve
     * depends on the size of the supplied `code`.
     *
     * If the code already exists in storage it will still return `Ok` and upgrades
     * the in storage version to the current
     * [`InstructionWeights::version`](InstructionWeights).
     *
     * - `determinism`: If this is set to any other value but [`Determinism::Enforced`] then
     * the only way to use this code is to delegate call into it from an offchain execution.
     * Set to [`Determinism::Enforced`] if in doubt.
     *
     * # Note
     *
     * Anyone can instantiate a contract from any uploaded code and thus prevent its removal.
     * To avoid this situation a constructor could employ access control so that it can
     * only be instantiated by permissioned entities. The same is true when uploading
     * through [`Self::instantiate_with_code`].
     *
     * Use [`Determinism::Relaxed`] exclusively for non-deterministic code. If the uploaded
     * code is deterministic, specifying [`Determinism::Relaxed`] will be disregarded and
     * result in higher gas costs.
     */
    "upload_code": Anonymize<Im2f0numhevg3>;
    /**
     * Remove the code stored under `code_hash` and refund the deposit to its owner.
     *
     * A code can only be removed by its original uploader (its owner) and only if it is
     * not used by any contract.
     */
    "remove_code": Anonymize<Ib51vk42m1po4n>;
    /**
     * Privileged function that changes the code of an existing contract.
     *
     * This takes care of updating refcounts and all other necessary operations. Returns
     * an error if either the `code_hash` or `dest` do not exist.
     *
     * # Note
     *
     * This does **not** change the address of the contract in question. This means
     * that the contract address is no longer derived from its code hash after calling
     * this dispatchable.
     */
    "set_code": Anonymize<I2agkcpojhkk43>;
    /**
     * Makes a call to an account, optionally transferring some balance.
     *
     * # Parameters
     *
     * * `dest`: Address of the contract to call.
     * * `value`: The balance to transfer from the `origin` to `dest`.
     * * `gas_limit`: The gas limit enforced when executing the constructor.
     * * `storage_deposit_limit`: The maximum amount of balance that can be charged from the
     * caller to pay for the storage consumed.
     * * `data`: The input data to pass to the contract.
     *
     * * If the account is a smart-contract account, the associated code will be
     * executed and any value will be transferred.
     * * If the account is a regular account, any value will be transferred.
     * * If no account exists and the call value is not less than `existential_deposit`,
     * a regular account will be created and any value will be transferred.
     */
    "call": Anonymize<I32rvg545edabm>;
    /**
     * Instantiates a new contract from the supplied `code` optionally transferring
     * some balance.
     *
     * This dispatchable has the same effect as calling [`Self::upload_code`] +
     * [`Self::instantiate`]. Bundling them together provides efficiency gains. Please
     * also check the documentation of [`Self::upload_code`].
     *
     * # Parameters
     *
     * * `value`: The balance to transfer from the `origin` to the newly created contract.
     * * `gas_limit`: The gas limit enforced when executing the constructor.
     * * `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved
     * from the caller to pay for the storage consumed.
     * * `code`: The contract code to deploy in raw bytes.
     * * `data`: The input data to pass to the contract constructor.
     * * `salt`: Used for the address derivation. See [`Pallet::contract_address`].
     *
     * Instantiation is executed as follows:
     *
     * - The supplied `code` is deployed, and a `code_hash` is created for that code.
     * - If the `code_hash` already exists on the chain the underlying `code` will be shared.
     * - The destination address is computed based on the sender, code_hash and the salt.
     * - The smart-contract account is created at the computed address.
     * - The `value` is transferred to the new account.
     * - The `deploy` function is executed in the context of the newly-created account.
     */
    "instantiate_with_code": Anonymize<I83fv0vi59md7i>;
    /**
     * Instantiates a contract from a previously deployed wasm binary.
     *
     * This function is identical to [`Self::instantiate_with_code`] but without the
     * code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary
     * must be supplied.
     */
    "instantiate": Anonymize<I5tjjqcdd4tae0>;
    /**
     * When a migration is in progress, this dispatchable can be used to run migration steps.
     * Calls that contribute to advancing the migration have their fees waived, as it's helpful
     * for the chain. Note that while the migration is in progress, the pallet will also
     * leverage the `on_idle` hooks to run migration steps.
     */
    "migrate": Anonymize<I1894dm1lf1ae7>;
}>;
export type Ia2rnh5pfua40a = {
    "dest": MultiAddress;
    "value": bigint;
    "gas_limit": bigint;
    "storage_deposit_limit"?: Anonymize<I35p85j063s0il>;
    "data": Binary;
};
export type I3otc7e9a35k1k = {
    "value": bigint;
    "gas_limit": bigint;
    "storage_deposit_limit"?: Anonymize<I35p85j063s0il>;
    "code": Binary;
    "data": Binary;
    "salt": Binary;
};
export type I89ier5tb9ne0s = {
    "value": bigint;
    "gas_limit": bigint;
    "storage_deposit_limit"?: Anonymize<I35p85j063s0il>;
    "code_hash": FixedSizeBinary<32>;
    "data": Binary;
    "salt": Binary;
};
export type Im2f0numhevg3 = {
    "code": Binary;
    "storage_deposit_limit"?: Anonymize<I35p85j063s0il>;
    "determinism": Anonymize<I2dfliekq1ed7e>;
};
export type I2agkcpojhkk43 = {
    "dest": MultiAddress;
    "code_hash": FixedSizeBinary<32>;
};
export type I32rvg545edabm = {
    "dest": MultiAddress;
    "value": bigint;
    "gas_limit": Anonymize<I4q39t5hn830vp>;
    "storage_deposit_limit"?: Anonymize<I35p85j063s0il>;
    "data": Binary;
};
export type I83fv0vi59md7i = {
    "value": bigint;
    "gas_limit": Anonymize<I4q39t5hn830vp>;
    "storage_deposit_limit"?: Anonymize<I35p85j063s0il>;
    "code": Binary;
    "data": Binary;
    "salt": Binary;
};
export type I5tjjqcdd4tae0 = {
    "value": bigint;
    "gas_limit": Anonymize<I4q39t5hn830vp>;
    "storage_deposit_limit"?: Anonymize<I35p85j063s0il>;
    "code_hash": FixedSizeBinary<32>;
    "data": Binary;
    "salt": Binary;
};
export type I1894dm1lf1ae7 = {
    "weight_limit": Anonymize<I4q39t5hn830vp>;
};
export type I6su2fahl42451 = AnonymousEnum<{
    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     */
    "sudo": Anonymize<I5t8a8734unb9r>;
    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Signed_.
     */
    "sudo_unchecked_weight": Anonymize<Iac53udfpd9th9>;
    /**
     * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
     * key.
     */
    "set_key": Anonymize<I8k3rnvpeeh4hv>;
    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     *
     * The dispatch origin for this call must be _Signed_.
     */
    "sudo_as": Anonymize<I11daup0eudof7>;
    /**
     * Permanently removes the sudo key.
     *
     * **This cannot be un-done.**
     */
    "remove_key": undefined;
}>;
export type I5t8a8734unb9r = {
    "call": TxCallData;
};
export type I11daup0eudof7 = {
    "who": MultiAddress;
    "call": TxCallData;
};
export type Ifclk240k6qfq4 = AnonymousEnum<{
    /**
     * Set the collective's membership.
     *
     * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     * - `prime`: The prime member whose vote sets the default.
     * - `old_count`: The upper bound for the previous number of members in storage. Used for
     * weight estimation.
     *
     * The dispatch of this call must be `SetMembersOrigin`.
     *
     * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     * the weight estimations rely on it to estimate dispatchable weight.
     *
     * # WARNING:
     *
     * The `pallet-collective` can also be managed by logic outside of the pallet through the
     * implementation of the trait [`ChangeMembers`].
     * Any call to `set_members` must be careful that the member set doesn't get out of sync
     * with other logic managing the member set.
     *
     * ## Complexity:
     * - `O(MP + N)` where:
     * - `M` old-members-count (code- and governance-bounded)
     * - `N` new-members-count (code- and governance-bounded)
     * - `P` proposals-count (code-bounded)
     */
    "set_members": Anonymize<I38jfk5li8iang>;
    /**
     * Dispatch a proposal from a member using the `Member` origin.
     *
     * Origin must be a member of the collective.
     *
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     */
    "execute": Anonymize<Im27nlqnsqokc>;
    /**
     * Add a new proposal to either be voted on or executed directly.
     *
     * Requires the sender to be member.
     *
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     *
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - branching is influenced by `threshold` where:
     * - `P1` is proposal execution complexity (`threshold < 2`)
     * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     */
    "propose": Anonymize<I8lgulhtal9pjr>;
    /**
     * Add an aye or nay vote for the sender to the given proposal.
     *
     * Requires the sender to be a member.
     *
     * Transaction fees will be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * ## Complexity
     * - `O(M)` where `M` is members-count (code- and governance-bounded)
     */
    "vote": Anonymize<I2dtrijkm5601t>;
    /**
     * Disapprove a proposal, close, and remove it from the system, regardless of its current
     * state.
     *
     * Must be called by the Root origin.
     *
     * Parameters:
     * * `proposal_hash`: The hash of the proposal that should be disapproved.
     *
     * ## Complexity
     * O(P) where P is the number of max proposals
     */
    "disapprove_proposal": Anonymize<I2ev73t79f46tb>;
    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     *
     * May be called by any signed account in order to finish voting and close the proposal.
     *
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     *
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     *
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     *
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     *
     * ## Complexity
     * - `O(B + M + P1 + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - `P1` is the complexity of `proposal` preimage.
     * - `P2` is proposal-count (code-bounded)
     */
    "close": Anonymize<Ib2obgji960euh>;
    /**
     * Disapprove the proposal and burn the cost held for storing this proposal.
     *
     * Parameters:
     * - `origin`: must be the `KillOrigin`.
     * - `proposal_hash`: The hash of the proposal that should be killed.
     *
     * Emits `Killed` and `ProposalCostBurned` if any cost was held for a given proposal.
     */
    "kill": Anonymize<I2ev73t79f46tb>;
    /**
     * Release the cost held for storing a proposal once the given proposal is completed.
     *
     * If there is no associated cost for the given proposal, this call will have no effect.
     *
     * Parameters:
     * - `origin`: must be `Signed` or `Root`.
     * - `proposal_hash`: The hash of the proposal.
     *
     * Emits `ProposalCostReleased` if any cost held for a given proposal.
     */
    "release_proposal_cost": Anonymize<I2ev73t79f46tb>;
}>;
export type I38jfk5li8iang = {
    "new_members": Anonymize<Ia2lhg7l2hilo3>;
    "prime"?: Anonymize<Ihfphjolmsqq1>;
    "old_count": number;
};
export type Im27nlqnsqokc = {
    "proposal": TxCallData;
    "length_bound": number;
};
export type I8lgulhtal9pjr = {
    "threshold": number;
    "proposal": TxCallData;
    "length_bound": number;
};
export type I10dimmis6musr = AnonymousEnum<{
    /**
     * Propose a sensitive action to be taken.
     *
     * The dispatch origin of this call must be _Signed_ and the sender must
     * have funds to cover the deposit.
     *
     * - `proposal_hash`: The hash of the proposal preimage.
     * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
     *
     * Emits `Proposed`.
     */
    "propose": Anonymize<I1moso5oagpiea>;
    /**
     * Signals agreement with a particular proposal.
     *
     * The dispatch origin of this call must be _Signed_ and the sender
     * must have funds to cover the deposit, equal to the original deposit.
     *
     * - `proposal`: The index of the proposal to second.
     */
    "second": Anonymize<Ibeb4n9vpjefp3>;
    /**
     * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `ref_index`: The index of the referendum to vote for.
     * - `vote`: The vote configuration.
     */
    "vote": Anonymize<Id7murq9s9fg6h>;
    /**
     * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
     * referendum.
     *
     * The dispatch origin of this call must be `CancellationOrigin`.
     *
     * -`ref_index`: The index of the referendum to cancel.
     *
     * Weight: `O(1)`.
     */
    "emergency_cancel": Anonymize<Ied9mja4bq7va8>;
    /**
     * Schedule a referendum to be tabled once it is legal to schedule an external
     * referendum.
     *
     * The dispatch origin of this call must be `ExternalOrigin`.
     *
     * - `proposal_hash`: The preimage hash of the proposal.
     */
    "external_propose": Anonymize<I4f7jul8ljs54r>;
    /**
     * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     * an external referendum.
     *
     * The dispatch of this call must be `ExternalMajorityOrigin`.
     *
     * - `proposal_hash`: The preimage hash of the proposal.
     *
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     *
     * Weight: `O(1)`
     */
    "external_propose_majority": Anonymize<I4f7jul8ljs54r>;
    /**
     * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     * schedule an external referendum.
     *
     * The dispatch of this call must be `ExternalDefaultOrigin`.
     *
     * - `proposal_hash`: The preimage hash of the proposal.
     *
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     *
     * Weight: `O(1)`
     */
    "external_propose_default": Anonymize<I4f7jul8ljs54r>;
    /**
     * Schedule the currently externally-proposed majority-carries referendum to be tabled
     * immediately. If there is no externally-proposed referendum currently, or if there is one
     * but it is not a majority-carries referendum then it fails.
     *
     * The dispatch of this call must be `FastTrackOrigin`.
     *
     * - `proposal_hash`: The hash of the current external proposal.
     * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
     * Must be always greater than zero.
     * For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
     * - `delay`: The number of block after voting has ended in approval and this should be
     * enacted. This doesn't have a minimum amount.
     *
     * Emits `Started`.
     *
     * Weight: `O(1)`
     */
    "fast_track": Anonymize<I5agg650597e49>;
    /**
     * Veto and blacklist the external proposal hash.
     *
     * The dispatch origin of this call must be `VetoOrigin`.
     *
     * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
     *
     * Emits `Vetoed`.
     *
     * Weight: `O(V + log(V))` where V is number of `existing vetoers`
     */
    "veto_external": Anonymize<I2ev73t79f46tb>;
    /**
     * Remove a referendum.
     *
     * The dispatch origin of this call must be _Root_.
     *
     * - `ref_index`: The index of the referendum to cancel.
     *
     * # Weight: `O(1)`.
     */
    "cancel_referendum": Anonymize<Ied9mja4bq7va8>;
    /**
     * Delegate the voting power (with some given conviction) of the sending account.
     *
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     *
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     * - be delegating already; or
     * - have no voting activity (if there is, then it will need to be removed/consolidated
     * through `reap_vote` or `unvote`).
     *
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     * account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     * be more than the account's current balance.
     *
     * Emits `Delegated`.
     *
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     * voted on. Weight is charged as if maximum votes.
     */
    "delegate": Anonymize<Ibot4i7a9t6oo8>;
    /**
     * Undelegate the voting power of the sending account.
     *
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued.
     *
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     *
     * Emits `Undelegated`.
     *
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     * voted on. Weight is charged as if maximum votes.
     */
    "undelegate": undefined;
    /**
     * Clears all public proposals.
     *
     * The dispatch origin of this call must be _Root_.
     *
     * Weight: `O(1)`.
     */
    "clear_public_proposals": undefined;
    /**
     * Unlock tokens that have an expired lock.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account to remove the lock on.
     *
     * Weight: `O(R)` with R number of vote of target.
     */
    "unlock": Anonymize<Id9uqtigc0il3v>;
    /**
     * Remove a vote for a referendum.
     *
     * If:
     * - the referendum was cancelled, or
     * - the referendum is ongoing, or
     * - the referendum has ended such that
     * - the vote of the account was in opposition to the result; or
     * - there was no conviction to the account's vote; or
     * - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     *
     * If, however, the referendum has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     *
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for referendum `index`.
     *
     * - `index`: The index of referendum of the vote to be removed.
     *
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     */
    "remove_vote": Anonymize<I666bl2fqjkejo>;
    /**
     * Remove a vote for a referendum.
     *
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the referendum was cancelled, because the voter lost the referendum or
     * because the conviction period is over.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for
     * referendum `index`.
     * - `index`: The index of referendum of the vote to be removed.
     *
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     */
    "remove_other_vote": Anonymize<I3hsuol7rtl0bj>;
    /**
     * Permanently place a proposal into the blacklist. This prevents it from ever being
     * proposed again.
     *
     * If called on a queued public or external proposal, then this will result in it being
     * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
     * then it will be cancelled.
     *
     * The dispatch origin of this call must be `BlacklistOrigin`.
     *
     * - `proposal_hash`: The proposal hash to blacklist permanently.
     * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
     * cancelled.
     *
     * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
     * reasonable value).
     */
    "blacklist": Anonymize<I3v9h9f3mpm1l8>;
    /**
     * Remove a proposal.
     *
     * The dispatch origin of this call must be `CancelProposalOrigin`.
     *
     * - `prop_index`: The index of the proposal to cancel.
     *
     * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
     */
    "cancel_proposal": Anonymize<I9mnj4k4u8ls2c>;
    /**
     * Set or clear a metadata of a proposal or a referendum.
     *
     * Parameters:
     * - `origin`: Must correspond to the `MetadataOwner`.
     * - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
     * threshold.
     * - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
     * threshold.
     * - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
     * threshold.
     * - `Signed` by a creator for a public proposal.
     * - `Signed` to clear a metadata for a finished referendum.
     * - `Root` to set a metadata for an ongoing referendum.
     * - `owner`: an identifier of a metadata owner.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     */
    "set_metadata": Anonymize<I2kt2u1flctk2q>;
}>;
export type I1moso5oagpiea = {
    "proposal": PreimagesBounded;
    "value": bigint;
};
export type Ibeb4n9vpjefp3 = {
    "proposal": number;
};
export type Id7murq9s9fg6h = {
    "ref_index": number;
    "vote": Anonymize<Ia9hdots6g53fs>;
};
export type I4f7jul8ljs54r = {
    "proposal": PreimagesBounded;
};
export type I5agg650597e49 = {
    "proposal_hash": FixedSizeBinary<32>;
    "voting_period": number;
    "delay": number;
};
export type Ibot4i7a9t6oo8 = {
    "to": MultiAddress;
    "conviction": VotingConviction;
    "balance": bigint;
};
export type I3hsuol7rtl0bj = {
    "target": MultiAddress;
    "index": number;
};
export type I3v9h9f3mpm1l8 = {
    "proposal_hash": FixedSizeBinary<32>;
    "maybe_ref_index"?: Anonymize<I4arjljr6dpflb>;
};
export type I2kt2u1flctk2q = {
    "owner": Anonymize<I2itl2k1j2q8nf>;
    "maybe_hash"?: Anonymize<I4s6vifaf8k998>;
};
export type I2lbur1vp3trot = AnonymousEnum<{
    /**
     * Put forward a suggestion for spending.
     *
     * ## Dispatch Origin
     *
     * Must be signed.
     *
     * ## Details
     * A deposit proportional to the value is reserved and slashed if the proposal is rejected.
     * It is returned once the proposal is awarded.
     *
     * ### Complexity
     * - O(1)
     *
     * ## Events
     *
     * Emits [`Event::Proposed`] if successful.
     */
    "propose_spend": Anonymize<Iffcutbjvs7mcv>;
    /**
     * Reject a proposed spend.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     * The original deposit will be slashed.
     *
     * ### Complexity
     * - O(1)
     *
     * ## Events
     *
     * Emits [`Event::Rejected`] if successful.
     */
    "reject_proposal": Anonymize<Icm9m0qeemu66d>;
    /**
     * Approve a proposal.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::ApproveOrigin`].
     *
     * ## Details
     *
     * At a later time, the proposal will be allocated to the beneficiary and the original
     * deposit will be returned.
     *
     * ### Complexity
     * - O(1).
     *
     * ## Events
     *
     * No events are emitted from this dispatch.
     */
    "approve_proposal": Anonymize<Icm9m0qeemu66d>;
}>;
export type Iffcutbjvs7mcv = {
    "value": bigint;
    "beneficiary": MultiAddress;
};
export type Ibrvh54g79pa9u = AnonymousEnum<{
    /**
     * Executes the call on a behalf of an aliased account.
     *
     * The `origin` of the call is supposed to be a _collective_ (but can be anything) which can dispatch `call` on behalf of the aliased account.
     * It's essentially a proxy call that can be made by arbitrary origin type.
     */
    "execute_call": Anonymize<I5t8a8734unb9r>;
}>;
export type I48eehof2eias5 = AnonymousEnum<{
    /**
     * Enter safe-mode permissionlessly for [`Config::EnterDuration`] blocks.
     *
     * Reserves [`Config::EnterDepositAmount`] from the caller's account.
     * Emits an [`Event::Entered`] event on success.
     * Errors with [`Error::Entered`] if the safe-mode is already entered.
     * Errors with [`Error::NotConfigured`] if the deposit amount is `None`.
     */
    "enter": undefined;
    /**
     * Enter safe-mode by force for a per-origin configured number of blocks.
     *
     * Emits an [`Event::Entered`] event on success.
     * Errors with [`Error::Entered`] if the safe-mode is already entered.
     *
     * Can only be called by the [`Config::ForceEnterOrigin`] origin.
     */
    "force_enter": undefined;
    /**
     * Extend the safe-mode permissionlessly for [`Config::ExtendDuration`] blocks.
     *
     * This accumulates on top of the current remaining duration.
     * Reserves [`Config::ExtendDepositAmount`] from the caller's account.
     * Emits an [`Event::Extended`] event on success.
     * Errors with [`Error::Exited`] if the safe-mode is entered.
     * Errors with [`Error::NotConfigured`] if the deposit amount is `None`.
     *
     * This may be called by any signed origin with [`Config::ExtendDepositAmount`] free
     * currency to reserve. This call can be disabled for all origins by configuring
     * [`Config::ExtendDepositAmount`] to `None`.
     */
    "extend": undefined;
    /**
     * Extend the safe-mode by force for a per-origin configured number of blocks.
     *
     * Emits an [`Event::Extended`] event on success.
     * Errors with [`Error::Exited`] if the safe-mode is inactive.
     *
     * Can only be called by the [`Config::ForceExtendOrigin`] origin.
     */
    "force_extend": undefined;
    /**
     * Exit safe-mode by force.
     *
     * Emits an [`Event::Exited`] with [`ExitReason::Force`] event on success.
     * Errors with [`Error::Exited`] if the safe-mode is inactive.
     *
     * Note: `safe-mode` will be automatically deactivated by [`Pallet::on_initialize`] hook
     * after the block height is greater than the [`EnteredUntil`] storage item.
     * Emits an [`Event::Exited`] with [`ExitReason::Timeout`] event when deactivated in the
     * hook.
     */
    "force_exit": undefined;
    /**
     * Slash a deposit for an account that entered or extended safe-mode at a given
     * historical block.
     *
     * This can only be called while safe-mode is entered.
     *
     * Emits a [`Event::DepositSlashed`] event on success.
     * Errors with [`Error::Entered`] if safe-mode is entered.
     *
     * Can only be called by the [`Config::ForceDepositOrigin`] origin.
     */
    "force_slash_deposit": Anonymize<I1ssp78ejl639m>;
    /**
     * Permissionlessly release a deposit for an account that entered safe-mode at a
     * given historical block.
     *
     * The call can be completely disabled by setting [`Config::ReleaseDelay`] to `None`.
     * This cannot be called while safe-mode is entered and not until
     * [`Config::ReleaseDelay`] blocks have passed since safe-mode was entered.
     *
     * Emits a [`Event::DepositReleased`] event on success.
     * Errors with [`Error::Entered`] if the safe-mode is entered.
     * Errors with [`Error::CannotReleaseYet`] if [`Config::ReleaseDelay`] block have not
     * passed since safe-mode was entered. Errors with [`Error::NoDeposit`] if the payee has no
     * reserved currency at the block specified.
     */
    "release_deposit": Anonymize<I1ssp78ejl639m>;
    /**
     * Force to release a deposit for an account that entered safe-mode at a given
     * historical block.
     *
     * This can be called while safe-mode is still entered.
     *
     * Emits a [`Event::DepositReleased`] event on success.
     * Errors with [`Error::Entered`] if safe-mode is entered.
     * Errors with [`Error::NoDeposit`] if the payee has no reserved currency at the
     * specified block.
     *
     * Can only be called by the [`Config::ForceDepositOrigin`] origin.
     */
    "force_release_deposit": Anonymize<I1ssp78ejl639m>;
}>;
export type I1ssp78ejl639m = {
    "account": SS58String;
    "block": number;
};
export type Ifvqn3ldat80ai = [SS58String, undefined];
export type I99bb69usss9gs = {
    "index": number;
    "threshold": number;
    "ayes": Anonymize<Ia2lhg7l2hilo3>;
    "nays": Anonymize<Ia2lhg7l2hilo3>;
    "end": number;
};
export type I6mhebgj62g585 = Array<[number, PreimagesBounded, SS58String]>;
export type I3vhcedhm4hpvm = [Anonymize<Ia2lhg7l2hilo3>, bigint];
export type I526daka7j7b17 = AnonymousEnum<{
    "Ongoing": {
        "end": number;
        "proposal": PreimagesBounded;
        "threshold": Anonymize<Ivbp9821csvot>;
        "delay": number;
        "tally": {
            "ayes": bigint;
            "nays": bigint;
            "turnout": bigint;
        };
    };
    "Finished": {
        "approved": boolean;
        "end": number;
    };
}>;
export type Ifanv2kvm586s4 = AnonymousEnum<{
    "Direct": {
        "votes": Array<[number, Anonymize<Ia9hdots6g53fs>]>;
        "delegations": Anonymize<I538qha8r4j3ii>;
        "prior": Anonymize<I4ojmnsk1dchql>;
    };
    "Delegating": Anonymize<I251o9sbu5566f>;
}>;
export type I5rsgtofmn5lli = [PreimagesBounded, Anonymize<Ivbp9821csvot>];
export type Idned7t7knml6b = [number, Anonymize<Ia2lhg7l2hilo3>];
export type Ijc5n210o8bbf = {
    "limits": {
        "event_topics": number;
        "memory_pages": number;
        "subject_len": number;
        "payload_len": number;
        "runtime_memory": number;
        "validator_runtime_memory": number;
        "event_ref_time": bigint;
    };
    "instruction_weights": number;
};
export type Iedigu6rpmlqgi = ResultPayload<Anonymize<Ibliqel4v19lul>, Anonymize<I5nrjkj9qumobs>>;
export type I55hda2igh2kpe = ResultPayload<Anonymize<I7ag5k7bmmgq3j>, Anonymize<Ia0b5t2n4b7jh8>>;
export type Ib5fuj3h6uddcc = ResultPayload<Anonymize<Ie3rl25flint9v>, Anonymize<Ia0b5t2n4b7jh8>>;
export type I6pj5ltvn0n3ld = {
    "gas_consumed": Anonymize<I4q39t5hn830vp>;
    "gas_required": Anonymize<I4q39t5hn830vp>;
    "storage_deposit": Anonymize<If7bmpttbdmqu4>;
    "debug_message": Binary;
    "result": ResultPayload<Anonymize<I620n7irgfspm4>, Anonymize<Ia0b5t2n4b7jh8>>;
    "events"?: Anonymize<I223vbc9blic3b>;
};
export type If7bmpttbdmqu4 = AnonymousEnum<{
    "Refund": bigint;
    "Charge": bigint;
}>;
export type I620n7irgfspm4 = {
    "flags": number;
    "data": Binary;
};
export type I223vbc9blic3b = (Anonymize<Ic6m8qjo445mpd>) | undefined;
export type I9sijb8gfrns29 = AnonymousEnum<{
    "Upload": Binary;
    "Existing": FixedSizeBinary<32>;
}>;
export type I9cuhvnfjpga8u = {
    "gas_consumed": Anonymize<I4q39t5hn830vp>;
    "gas_required": Anonymize<I4q39t5hn830vp>;
    "storage_deposit": Anonymize<If7bmpttbdmqu4>;
    "debug_message": Binary;
    "result": ResultPayload<{
        "result": Anonymize<I620n7irgfspm4>;
        "account_id": SS58String;
    }, Anonymize<Ia0b5t2n4b7jh8>>;
    "events"?: Anonymize<I223vbc9blic3b>;
};
export type Idmj5j6lk1d68c = ResultPayload<{
    "code_hash": FixedSizeBinary<32>;
    "deposit": bigint;
}, Anonymize<Ia0b5t2n4b7jh8>>;
export type I9u22scd4ksrjm = ResultPayload<Anonymize<Iabpgqcjikia83>, Enum<{
    "DoesntExist": undefined;
    "KeyDecodingFailed": undefined;
    "MigrationInProgress": undefined;
}>>;
export type I60mpf7i0nq9h4 = ResultPayload<{
    "execution_result": ResultPayload<Anonymize<Ia1u1r3n74r13c>, {
        "post_info": Anonymize<Ia1u1r3n74r13c>;
        "error": Anonymize<Ia0b5t2n4b7jh8>;
    }>;
    "emitted_events": Anonymize<Ic4rifdpi305mq>;
    "local_xcm"?: Anonymize<Ieqgqma27vbupd>;
    "forwarded_xcms": Anonymize<Ialhmrpub9sefe>;
}, Anonymize<I55ku9c5gk50hb>>;
export type Ic4rifdpi305mq = Array<Anonymize<I654d265vs2sj5>>;
export type Icvhoqf7i84h1r = ResultPayload<{
    "execution_result": Anonymize<I6uq5gb4s805s7>;
    "emitted_events": Anonymize<Ic4rifdpi305mq>;
    "forwarded_xcms": Anonymize<Ialhmrpub9sefe>;
}, Anonymize<I55ku9c5gk50hb>>;
export type Icujp6hmv35vbn = ResultPayload<boolean, Enum<{
    "VersionedAssetConversionFailed": undefined;
    "VersionedLocationConversionFailed": undefined;
}>>;
export type Ianrnufrkcg3s6 = Array<{
    "phase": Phase;
    "event": Anonymize<I9983s9bd0q4a9>;
    "topics": Anonymize<Ic5m5lp1oioo8r>;
}>;
export type I9983s9bd0q4a9 = AnonymousEnum<{
    "System": Anonymize<I2gm7se5flc7ar>;
    "Indices": Anonymize<I2pejk6do5vg4t>;
    "Balances": Anonymize<Iao8h4hv7atnq3>;
    "TransactionPayment": TransactionPaymentEvent;
    "Staking": Anonymize<I8n4qjnlkvth8n>;
    "Offences": OffencesEvent;
    "Session": Anonymize<I4co4bgsti676q>;
    "Grandpa": GrandpaEvent;
    "Treasury": Anonymize<Ia1b9fjuj0ob0b>;
    "ConvictionVoting": Anonymize<I7tvgbf73o5td4>;
    "Referenda": Anonymize<Idfraa3b4eu018>;
    "FellowshipCollective": Anonymize<Ifuucdgpuglunu>;
    "FellowshipReferenda": Anonymize<I28aoa43r171jt>;
    "Whitelist": Anonymize<Id9j7v231p0r61>;
    "Parameters": Anonymize<Ibcr438tpvplp3>;
    "Claims": CommonClaimsEvent;
    "Utility": Anonymize<I10elebe47lp9c>;
    "Society": Anonymize<Ifhcq78pr9md4e>;
    "Recovery": RecoveryEvent;
    "Vesting": VestingEvent;
    "Scheduler": Anonymize<I8mslp7cfek5ao>;
    "Proxy": Anonymize<I28r5oiog7a0kn>;
    "Multisig": Anonymize<Ictlgm7j743enp>;
    "Preimage": PreimageEvent;
    "Bounties": BountiesEvent;
    "ChildBounties": ChildBountiesEvent;
    "ElectionProviderMultiPhase": ElectionProviderMultiPhaseEvent;
    "Nis": Anonymize<I9dmlhfape78ke>;
    "NisCounterpartBalances": Anonymize<Iao8h4hv7atnq3>;
    "VoterList": BagsListEvent;
    "NominationPools": Anonymize<Id0dkgikq71n9h>;
    "FastUnstake": Anonymize<Ifd1igod07sq6l>;
    "DelegatedStaking": Anonymize<I1nq1se98idofq>;
    "ParaInclusion": Anonymize<If7iaaqrjurpqf>;
    "Paras": ParachainsParasEvent;
    "Hrmp": ParachainsHrmpEvent;
    "ParasDisputes": ParachainsDisputesEvent;
    "OnDemandAssignmentProvider": Anonymize<I8vt07l5vp6sb8>;
    "Registrar": CommonParasRegistrarEvent;
    "Slots": CommonSlotsEvent;
    "Auctions": CommonAuctionsEvent;
    "Crowdloan": Anonymize<Ifquqf9uphs1lr>;
    "Coretime": PolkadotRuntimeParachainsCoretimeEvent;
    "XcmPallet": Anonymize<Id2l439q7pe8kr>;
    "MessageQueue": Anonymize<I13vul90391uuv>;
    "AssetRate": Anonymize<I1dcjapt414ijf>;
}>;
export type I2gm7se5flc7ar = AnonymousEnum<{
    /**
     * An extrinsic completed successfully.
     */
    "ExtrinsicSuccess": Anonymize<Ia82mnkmeo2rhc>;
    /**
     * An extrinsic failed.
     */
    "ExtrinsicFailed": Anonymize<I3nmm2neb03d3i>;
    /**
     * `:code` was updated.
     */
    "CodeUpdated": undefined;
    /**
     * A new account was created.
     */
    "NewAccount": Anonymize<Icbccs0ug47ilf>;
    /**
     * An account was reaped.
     */
    "KilledAccount": Anonymize<Icbccs0ug47ilf>;
    /**
     * On on-chain remark happened.
     */
    "Remarked": Anonymize<I855j4i3kr8ko1>;
    /**
     * An upgrade was authorized.
     */
    "UpgradeAuthorized": Anonymize<Ibgl04rn6nbfm6>;
    /**
     * An invalid authorized upgrade was rejected while trying to apply it.
     */
    "RejectedInvalidAuthorizedUpgrade": Anonymize<Ieqnfrpre3o3vf>;
}>;
export type I3nmm2neb03d3i = {
    "dispatch_error": Anonymize<I45cjvlvdsjc1>;
    "dispatch_info": Anonymize<Ic9s8f85vjtncc>;
};
export type I45cjvlvdsjc1 = AnonymousEnum<{
    "Other": undefined;
    "CannotLookup": undefined;
    "BadOrigin": undefined;
    "Module": Enum<{
        "System": Anonymize<I5o0s7c8q1cc9b>;
        "Babe": Anonymize<Ib6q602k6o213a>;
        "Timestamp": undefined;
        "Indices": Anonymize<Icq1825fru3di2>;
        "Balances": Anonymize<Idj13i7adlomht>;
        "TransactionPayment": undefined;
        "Authorship": undefined;
        "Staking": Anonymize<Ileu8a8k5fbnr>;
        "Offences": undefined;
        "Historical": undefined;
        "Session": Anonymize<I1e07dgbaqd1sq>;
        "Grandpa": Anonymize<I7q8i0pp1gkas6>;
        "AuthorityDiscovery": undefined;
        "Treasury": Anonymize<I36uss0m9fpcsf>;
        "ConvictionVoting": Anonymize<Idfa8k8ikssbsf>;
        "Referenda": Anonymize<I84u4ul208g742>;
        "FellowshipCollective": Anonymize<Ib69hbq04ogo7t>;
        "FellowshipReferenda": Anonymize<I84u4ul208g742>;
        "Origins": undefined;
        "Whitelist": Anonymize<I15nctscutpbeh>;
        "Parameters": undefined;
        "Claims": Anonymize<Ijh2jbbqvb176>;
        "Utility": Anonymize<I8dt2g2hcrgh36>;
        "Society": Anonymize<I6n8dkudb3ed0r>;
        "Recovery": Anonymize<I29mqdjoga49c9>;
        "Vesting": Anonymize<Icof2acl69lq3c>;
        "Scheduler": Anonymize<If7oa8fprnilo5>;
        "Proxy": Anonymize<Iuvt54ei4cehc>;
        "Multisig": Anonymize<Ia76qmhhg4jvb9>;
        "Preimage": Anonymize<I4cfhml1prt4lu>;
        "Bounties": Anonymize<Ibfvjqqblobf53>;
        "ChildBounties": Anonymize<I4u5ou5u3tthff>;
        "ElectionProviderMultiPhase": Anonymize<Idb84kfjd998sl>;
        "Nis": Anonymize<I3lqplv82e2f8f>;
        "NisCounterpartBalances": Anonymize<Idj13i7adlomht>;
        "VoterList": Anonymize<Ic35l5bgiij29p>;
        "NominationPools": Anonymize<Iuudu4kursojc>;
        "FastUnstake": Anonymize<Iau9bur8dc3bec>;
        "DelegatedStaking": Anonymize<Iaogv3iimefnis>;
        "ParachainsOrigin": undefined;
        "Configuration": Anonymize<In1jctfv299lm>;
        "ParasShared": undefined;
        "ParaInclusion": Anonymize<I4rrcn97hglfls>;
        "ParaInherent": Anonymize<I2g8k20rpkqcs4>;
        "ParaScheduler": undefined;
        "Paras": Anonymize<Ieo97unb4d08rl>;
        "Initializer": undefined;
        "Dmp": undefined;
        "Hrmp": Anonymize<Ibns95nfmm92df>;
        "ParaSessionInfo": undefined;
        "ParasDisputes": Anonymize<Iakburbqot4g58>;
        "ParasSlashing": Anonymize<I1v70p1j0r2q1j>;
        "OnDemandAssignmentProvider": Anonymize<I48hdahgqa1mcd>;
        "CoretimeAssignmentProvider": Anonymize<I2mjnb5vgujeqj>;
        "Registrar": Anonymize<I97vkspnd0b8bh>;
        "Slots": Anonymize<Iers095sa65pbg>;
        "Auctions": Anonymize<I4kgo47o2v3701>;
        "Crowdloan": Anonymize<I9o6l1c4r4qc3s>;
        "Coretime": Anonymize<Ifju0orssp9h7o>;
        "XcmPallet": Anonymize<I6dl09bpoqheqk>;
        "MessageQueue": Anonymize<I5iupade5ag2dp>;
        "AssetRate": Anonymize<I3qgd61cgli6cp>;
        "Beefy": Anonymize<Iflve6qd33ah68>;
        "Mmr": undefined;
        "BeefyMmrLeaf": undefined;
    }>;
    "ConsumerRemaining": undefined;
    "NoProviders": undefined;
    "TooManyConsumers": undefined;
    "Token": TokenError;
    "Arithmetic": ArithmeticError;
    "Transactional": TransactionalError;
    "Exhausted": undefined;
    "Corruption": undefined;
    "Unavailable": undefined;
    "RootNotAllowed": undefined;
    "Trie": Anonymize<Idh4cj79bvroj8>;
}>;
export type I6n8dkudb3ed0r = AnonymousEnum<{
    /**
     * User is not a member.
     */
    "NotMember": undefined;
    /**
     * User is already a member.
     */
    "AlreadyMember": undefined;
    /**
     * User is suspended.
     */
    "Suspended": undefined;
    /**
     * User is not suspended.
     */
    "NotSuspended": undefined;
    /**
     * Nothing to payout.
     */
    "NoPayout": undefined;
    /**
     * Society already founded.
     */
    "AlreadyFounded": undefined;
    /**
     * Not enough in pot to accept candidate.
     */
    "InsufficientPot": undefined;
    /**
     * Member is already vouching or banned from vouching again.
     */
    "AlreadyVouching": undefined;
    /**
     * Member is not vouching.
     */
    "NotVouchingOnBidder": undefined;
    /**
     * Cannot remove the head of the chain.
     */
    "Head": undefined;
    /**
     * Cannot remove the founder.
     */
    "Founder": undefined;
    /**
     * User has already made a bid.
     */
    "AlreadyBid": undefined;
    /**
     * User is already a candidate.
     */
    "AlreadyCandidate": undefined;
    /**
     * User is not a candidate.
     */
    "NotCandidate": undefined;
    /**
     * Too many members in the society.
     */
    "MaxMembers": undefined;
    /**
     * The caller is not the founder.
     */
    "NotFounder": undefined;
    /**
     * The caller is not the head.
     */
    "NotHead": undefined;
    /**
     * The membership cannot be claimed as the candidate was not clearly approved.
     */
    "NotApproved": undefined;
    /**
     * The candidate cannot be kicked as the candidate was not clearly rejected.
     */
    "NotRejected": undefined;
    /**
     * The candidacy cannot be dropped as the candidate was clearly approved.
     */
    "Approved": undefined;
    /**
     * The candidacy cannot be bestowed as the candidate was clearly rejected.
     */
    "Rejected": undefined;
    /**
     * The candidacy cannot be concluded as the voting is still in progress.
     */
    "InProgress": undefined;
    /**
     * The candidacy cannot be pruned until a full additional intake period has passed.
     */
    "TooEarly": undefined;
    /**
     * The skeptic already voted.
     */
    "Voted": undefined;
    /**
     * The skeptic need not vote on candidates from expired rounds.
     */
    "Expired": undefined;
    /**
     * User is not a bidder.
     */
    "NotBidder": undefined;
    /**
     * There is no defender currently.
     */
    "NoDefender": undefined;
    /**
     * Group doesn't exist.
     */
    "NotGroup": undefined;
    /**
     * The member is already elevated to this rank.
     */
    "AlreadyElevated": undefined;
    /**
     * The skeptic has already been punished for this offence.
     */
    "AlreadyPunished": undefined;
    /**
     * Funds are insufficient to pay off society debts.
     */
    "InsufficientFunds": undefined;
    /**
     * The candidate/defender has no stale votes to remove.
     */
    "NoVotes": undefined;
}>;
export type I29mqdjoga49c9 = AnonymousEnum<{
    /**
     * User is not allowed to make a call on behalf of this account
     */
    "NotAllowed": undefined;
    /**
     * Threshold must be greater than zero
     */
    "ZeroThreshold": undefined;
    /**
     * Friends list must be greater than zero and threshold
     */
    "NotEnoughFriends": undefined;
    /**
     * Friends list must be less than max friends
     */
    "MaxFriends": undefined;
    /**
     * Friends list must be sorted and free of duplicates
     */
    "NotSorted": undefined;
    /**
     * This account is not set up for recovery
     */
    "NotRecoverable": undefined;
    /**
     * This account is already set up for recovery
     */
    "AlreadyRecoverable": undefined;
    /**
     * A recovery process has already started for this account
     */
    "AlreadyStarted": undefined;
    /**
     * A recovery process has not started for this rescuer
     */
    "NotStarted": undefined;
    /**
     * This account is not a friend who can vouch
     */
    "NotFriend": undefined;
    /**
     * The friend must wait until the delay period to vouch for this recovery
     */
    "DelayPeriod": undefined;
    /**
     * This user has already vouched for this recovery
     */
    "AlreadyVouched": undefined;
    /**
     * The threshold for recovering this account has not been met
     */
    "Threshold": undefined;
    /**
     * There are still active recovery attempts that need to be closed
     */
    "StillActive": undefined;
    /**
     * This account is already set up for recovery
     */
    "AlreadyProxy": undefined;
    /**
     * Some internal state is broken.
     */
    "BadState": undefined;
}>;
export type I3lqplv82e2f8f = AnonymousEnum<{
    /**
     * The duration of the bid is less than one.
     */
    "DurationTooSmall": undefined;
    /**
     * The duration is the bid is greater than the number of queues.
     */
    "DurationTooBig": undefined;
    /**
     * The amount of the bid is less than the minimum allowed.
     */
    "AmountTooSmall": undefined;
    /**
     * The queue for the bid's duration is full and the amount bid is too low to get in
     * through replacing an existing bid.
     */
    "BidTooLow": undefined;
    /**
     * Receipt index is unknown.
     */
    "UnknownReceipt": undefined;
    /**
     * Not the owner of the receipt.
     */
    "NotOwner": undefined;
    /**
     * Bond not yet at expiry date.
     */
    "NotExpired": undefined;
    /**
     * The given bid for retraction is not found.
     */
    "UnknownBid": undefined;
    /**
     * The portion supplied is beyond the value of the receipt.
     */
    "PortionTooBig": undefined;
    /**
     * Not enough funds are held to pay out.
     */
    "Unfunded": undefined;
    /**
     * There are enough funds for what is required.
     */
    "AlreadyFunded": undefined;
    /**
     * The thaw throttle has been reached for this period.
     */
    "Throttled": undefined;
    /**
     * The operation would result in a receipt worth an insignificant value.
     */
    "MakesDust": undefined;
    /**
     * The receipt is already communal.
     */
    "AlreadyCommunal": undefined;
    /**
     * The receipt is already private.
     */
    "AlreadyPrivate": undefined;
}>;
export type Ieqnfrpre3o3vf = {
    "code_hash": FixedSizeBinary<32>;
    "error": Anonymize<I45cjvlvdsjc1>;
};
export type Id9j7v231p0r61 = AnonymousEnum<{
    "CallWhitelisted": Anonymize<I1adbcfi5uc62r>;
    "WhitelistedCallRemoved": Anonymize<I1adbcfi5uc62r>;
    "WhitelistedCallDispatched": Anonymize<Ibcso5pjjfm79c>;
}>;
export type Ibcso5pjjfm79c = {
    "call_hash": FixedSizeBinary<32>;
    "result": Anonymize<Ia6jvgaum2t2gb>;
};
export type Ia6jvgaum2t2gb = ResultPayload<Anonymize<Ia1u1r3n74r13c>, {
    "post_info": Anonymize<Ia1u1r3n74r13c>;
    "error": Anonymize<I45cjvlvdsjc1>;
}>;
export type Ibcr438tpvplp3 = AnonymousEnum<{
    /**
     * A Parameter was set.
     *
     * Is also emitted when the value was not changed.
     */
    "Updated": Anonymize<I6nr1tkv231n8k>;
}>;
export type I6nr1tkv231n8k = {
    /**
     * The key that was updated.
     */
    "key": Anonymize<I5ps9qbqlvun7q>;
    /**
     * The old value before this call.
     */
    "old_value"?: (Anonymize<Iddckvbdfdasmv>) | undefined;
    /**
     * The new value after this call.
     */
    "new_value"?: (Anonymize<Iddckvbdfdasmv>) | undefined;
};
export type I5ps9qbqlvun7q = AnonymousEnum<{
    "Inflation": Enum<{
        "MinInflation": undefined;
        "MaxInflation": undefined;
        "IdealStake": undefined;
        "Falloff": undefined;
        "UseAuctionSlots": undefined;
    }>;
    "Treasury": Enum<{
        "BurnPortion": undefined;
        "BurnDestination": undefined;
    }>;
}>;
export type Iddckvbdfdasmv = AnonymousEnum<{
    "Inflation": Enum<{
        "MinInflation": bigint;
        "MaxInflation": bigint;
        "IdealStake": bigint;
        "Falloff": bigint;
        "UseAuctionSlots": boolean;
    }>;
    "Treasury": Enum<{
        "BurnPortion": number;
        "BurnDestination"?: Anonymize<Ihfphjolmsqq1>;
    }>;
}>;
export type I10elebe47lp9c = AnonymousEnum<{
    /**
     * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
     * well as the error.
     */
    "BatchInterrupted": Anonymize<Ip7g5ah0m1veh>;
    /**
     * Batch of dispatches completed fully with no error.
     */
    "BatchCompleted": undefined;
    /**
     * Batch of dispatches completed but has errors.
     */
    "BatchCompletedWithErrors": undefined;
    /**
     * A single item within a Batch of dispatches has completed with no error.
     */
    "ItemCompleted": undefined;
    /**
     * A single item within a Batch of dispatches has completed with error.
     */
    "ItemFailed": Anonymize<Ifdv6lqa5i8jrl>;
    /**
     * A call was dispatched.
     */
    "DispatchedAs": Anonymize<I3hkqim5kcum9o>;
    /**
     * Main call was dispatched.
     */
    "IfElseMainSuccess": undefined;
    /**
     * The fallback call was dispatched.
     */
    "IfElseFallbackCalled": Anonymize<I5al7n386dk6ks>;
}>;
export type Ip7g5ah0m1veh = {
    "index": number;
    "error": Anonymize<I45cjvlvdsjc1>;
};
export type Ifdv6lqa5i8jrl = {
    "error": Anonymize<I45cjvlvdsjc1>;
};
export type I3hkqim5kcum9o = {
    "result": Anonymize<Ibl6461c27hboe>;
};
export type Ibl6461c27hboe = ResultPayload<undefined, Anonymize<I45cjvlvdsjc1>>;
export type I5al7n386dk6ks = {
    "main_error": Anonymize<I45cjvlvdsjc1>;
};
export type Ifhcq78pr9md4e = AnonymousEnum<{
    /**
     * The society is founded by the given identity.
     */
    "Founded": Anonymize<I8ircspqpe79k7>;
    /**
     * A membership bid just happened. The given account is the candidate's ID and their offer
     * is the second.
     */
    "Bid": Anonymize<I1vlt8l6nvnen6>;
    /**
     * A membership bid just happened by vouching. The given account is the candidate's ID and
     * their offer is the second. The vouching party is the third.
     */
    "Vouch": Anonymize<I72vf0j9juc1df>;
    /**
     * A candidate was dropped (due to an excess of bids in the system).
     */
    "AutoUnbid": Anonymize<I4b66js88p45m8>;
    /**
     * A candidate was dropped (by their request).
     */
    "Unbid": Anonymize<I4b66js88p45m8>;
    /**
     * A candidate was dropped (by request of who vouched for them).
     */
    "Unvouch": Anonymize<I4b66js88p45m8>;
    /**
     * A group of candidates have been inducted. The batch's primary is the first value, the
     * batch in full is the second.
     */
    "Inducted": Anonymize<Ie0phfcvllr4od>;
    /**
     * A suspended member has been judged.
     */
    "SuspendedMemberJudgement": Anonymize<I476ep66p6ddg1>;
    /**
     * A candidate has been suspended
     */
    "CandidateSuspended": Anonymize<I4b66js88p45m8>;
    /**
     * A member has been suspended
     */
    "MemberSuspended": Anonymize<Ie3gphha4ejh40>;
    /**
     * A member has been challenged
     */
    "Challenged": Anonymize<Ie3gphha4ejh40>;
    /**
     * A vote has been placed
     */
    "Vote": Anonymize<If0btdsid69rrm>;
    /**
     * A vote has been placed for a defending member
     */
    "DefenderVote": Anonymize<Ictusacdcqj61u>;
    /**
     * A new set of \[params\] has been set for the group.
     */
    "NewParams": Anonymize<Ibsolu3c3q1lb4>;
    /**
     * Society is unfounded.
     */
    "Unfounded": Anonymize<I8ircspqpe79k7>;
    /**
     * Some funds were deposited into the society account.
     */
    "Deposit": Anonymize<Ie5v6njpckr05b>;
    /**
     * A \[member\] got elevated to \[rank\].
     */
    "Elevated": Anonymize<Ib116djgo9u4uo>;
}>;
export type I8ircspqpe79k7 = {
    "founder": SS58String;
};
export type I1vlt8l6nvnen6 = {
    "candidate_id": SS58String;
    "offer": bigint;
};
export type I72vf0j9juc1df = {
    "candidate_id": SS58String;
    "offer": bigint;
    "vouching": SS58String;
};
export type Ie0phfcvllr4od = {
    "primary": SS58String;
    "candidates": Anonymize<Ia2lhg7l2hilo3>;
};
export type I476ep66p6ddg1 = {
    "who": SS58String;
    "judged": boolean;
};
export type Ie3gphha4ejh40 = {
    "member": SS58String;
};
export type If0btdsid69rrm = {
    "candidate": SS58String;
    "voter": SS58String;
    "vote": boolean;
};
export type Ictusacdcqj61u = {
    "voter": SS58String;
    "vote": boolean;
};
export type Ibsolu3c3q1lb4 = {
    "params": Anonymize<I9hkvi4k3kh916>;
};
export type I9hkvi4k3kh916 = {
    "max_members": number;
    "max_intake": number;
    "max_strikes": number;
    "candidate_deposit": bigint;
};
export type Ib116djgo9u4uo = {
    "member": SS58String;
    "rank": number;
};
export type RecoveryEvent = Enum<{
    /**
     * A recovery process has been set up for an account.
     */
    "RecoveryCreated": Anonymize<Icbccs0ug47ilf>;
    /**
     * A recovery process has been initiated for lost account by rescuer account.
     */
    "RecoveryInitiated": Anonymize<I9vkkue6cq74et>;
    /**
     * A recovery process for lost account by rescuer account has been vouched for by sender.
     */
    "RecoveryVouched": Anonymize<Ibu56t5h1q49i4>;
    /**
     * A recovery process for lost account by rescuer account has been closed.
     */
    "RecoveryClosed": Anonymize<I9vkkue6cq74et>;
    /**
     * Lost account has been successfully recovered by rescuer account.
     */
    "AccountRecovered": Anonymize<I9vkkue6cq74et>;
    /**
     * A recovery process has been removed for an account.
     */
    "RecoveryRemoved": Anonymize<I1dmtl5t34b9g>;
}>;
export declare const RecoveryEvent: GetEnum<RecoveryEvent>;
export type I9vkkue6cq74et = {
    "lost_account": SS58String;
    "rescuer_account": SS58String;
};
export type Ibu56t5h1q49i4 = {
    "lost_account": SS58String;
    "rescuer_account": SS58String;
    "sender": SS58String;
};
export type I1dmtl5t34b9g = {
    "lost_account": SS58String;
};
export type I8mslp7cfek5ao = AnonymousEnum<{
    /**
     * Scheduled some task.
     */
    "Scheduled": Anonymize<I5n4sebgkfr760>;
    /**
     * Canceled some task.
     */
    "Canceled": Anonymize<I5n4sebgkfr760>;
    /**
     * Dispatched some task.
     */
    "Dispatched": Anonymize<Ic2rsjlctljl78>;
    /**
     * Set a retry configuration for some task.
     */
    "RetrySet": Anonymize<Ia3c82eadg79bj>;
    /**
     * Cancel a retry configuration for some task.
     */
    "RetryCancelled": Anonymize<Ienusoeb625ftq>;
    /**
     * The call for the provided hash was not found so the task has been aborted.
     */
    "CallUnavailable": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task was unable to be renewed since the agenda is full at that block.
     */
    "PeriodicFailed": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task was unable to be retried since the agenda is full at that block or there
     * was not enough weight to reschedule it.
     */
    "RetryFailed": Anonymize<Ienusoeb625ftq>;
    /**
     * The given task can never be executed since it is overweight.
     */
    "PermanentlyOverweight": Anonymize<Ienusoeb625ftq>;
    /**
     * Agenda is incomplete from `when`.
     */
    "AgendaIncomplete": Anonymize<Ibtsa3docbr9el>;
}>;
export type Ic2rsjlctljl78 = {
    "task": Anonymize<I9jd27rnpm8ttv>;
    "id"?: Anonymize<I4s6vifaf8k998>;
    "result": Anonymize<Ibl6461c27hboe>;
};
export type I28r5oiog7a0kn = AnonymousEnum<{
    /**
     * A proxy was executed correctly, with the given.
     */
    "ProxyExecuted": Anonymize<I3hkqim5kcum9o>;
    /**
     * A pure account has been created by new proxy with given
     * disambiguation index and proxy type.
     */
    "PureCreated": Anonymize<Iub732oamcqd>;
    /**
     * An announcement was placed to make a call in the future.
     */
    "Announced": Anonymize<I2ur0oeqg495j8>;
    /**
     * A proxy was added.
     */
    "ProxyAdded": Anonymize<Ibddqkipr41dmk>;
    /**
     * A proxy was removed.
     */
    "ProxyRemoved": Anonymize<Ibddqkipr41dmk>;
    /**
     * A deposit stored for proxies or announcements was poked / updated.
     */
    "DepositPoked": Anonymize<I1bhd210c3phjj>;
}>;
export type Iub732oamcqd = {
    "pure": SS58String;
    "who": SS58String;
    "proxy_type": Anonymize<Inpglg3f6qcjg>;
    "disambiguation_index": number;
};
export type Inpglg3f6qcjg = AnonymousEnum<{
    "Any": undefined;
    "NonTransfer": undefined;
    "Governance": undefined;
    "Staking": undefined;
    "CancelProxy": undefined;
    "Auction": undefined;
    "Society": undefined;
    "NominationPools": undefined;
    "Spokesperson": undefined;
    "ParaRegistration": undefined;
}>;
export type Ibddqkipr41dmk = {
    "delegator": SS58String;
    "delegatee": SS58String;
    "proxy_type": Anonymize<Inpglg3f6qcjg>;
    "delay": number;
};
export type Ictlgm7j743enp = AnonymousEnum<{
    /**
     * A new multisig operation has begun.
     */
    "NewMultisig": Anonymize<Iep27ialq4a7o7>;
    /**
     * A multisig operation has been approved by someone.
     */
    "MultisigApproval": Anonymize<Iasu5jvoqr43mv>;
    /**
     * A multisig operation has been executed.
     */
    "MultisigExecuted": Anonymize<I32k85km2e8hhj>;
    /**
     * A multisig operation has been cancelled.
     */
    "MultisigCancelled": Anonymize<I5qolde99acmd1>;
    /**
     * The deposit for a multisig operation has been updated/poked.
     */
    "DepositPoked": Anonymize<I8gtde5abn1g9a>;
}>;
export type I32k85km2e8hhj = {
    "approving": SS58String;
    "timepoint": Anonymize<Itvprrpb0nm3o>;
    "multisig": SS58String;
    "call_hash": FixedSizeBinary<32>;
    "result": Anonymize<Ibl6461c27hboe>;
};
export type I9dmlhfape78ke = AnonymousEnum<{
    /**
     * A bid was successfully placed.
     */
    "BidPlaced": Anonymize<Ie2vmgag6qiue4>;
    /**
     * A bid was successfully removed (before being accepted).
     */
    "BidRetracted": Anonymize<Ie2vmgag6qiue4>;
    /**
     * A bid was dropped from a queue because of another, more substantial, bid was present.
     */
    "BidDropped": Anonymize<Ie2vmgag6qiue4>;
    /**
     * A bid was accepted. The balance may not be released until expiry.
     */
    "Issued": Anonymize<I1kpuet4lkcdpf>;
    /**
     * An receipt has been (at least partially) thawed.
     */
    "Thawed": Anonymize<I5tr1gp2t9i6oh>;
    /**
     * An automatic funding of the deficit was made.
     */
    "Funded": Anonymize<I7ls1r4u61csif>;
    /**
     * A receipt was transferred.
     */
    "Transferred": Anonymize<I3gjgtso69eopr>;
}>;
export type Ie2vmgag6qiue4 = {
    "who": SS58String;
    "amount": bigint;
    "duration": number;
};
export type I1kpuet4lkcdpf = {
    /**
     * The identity of the receipt.
     */
    "index": number;
    /**
     * The block number at which the receipt may be thawed.
     */
    "expiry": number;
    /**
     * The owner of the receipt.
     */
    "who": SS58String;
    /**
     * The proportion of the effective total issuance which the receipt represents.
     */
    "proportion": bigint;
    /**
     * The amount of funds which were debited from the owner.
     */
    "amount": bigint;
};
export type I5tr1gp2t9i6oh = {
    /**
     * The identity of the receipt.
     */
    "index": number;
    /**
     * The owner.
     */
    "who": SS58String;
    /**
     * The proportion of the effective total issuance by which the owner was debited.
     */
    "proportion": bigint;
    /**
     * The amount by which the owner was credited.
     */
    "amount": bigint;
    /**
     * If `true` then the receipt is done.
     */
    "dropped": boolean;
};
export type I7ls1r4u61csif = {
    "deficit": bigint;
};
export type I3gjgtso69eopr = {
    "from": SS58String;
    "to": SS58String;
    "index": number;
};
export type Ifd1igod07sq6l = AnonymousEnum<{
    /**
     * A staker was unstaked.
     */
    "Unstaked": Anonymize<Idqp67nsfe4563>;
    /**
     * A staker was slashed for requesting fast-unstake whilst being exposed.
     */
    "Slashed": Anonymize<Ifk8eme5o7mukf>;
    /**
     * A batch was partially checked for the given eras, but the process did not finish.
     */
    "BatchChecked": Anonymize<Ic0he9tlf9ll0u>;
    /**
     * A batch of a given size was terminated.
     *
     * This is always follows by a number of `Unstaked` or `Slashed` events, marking the end
     * of the batch. A new batch will be created upon next block.
     */
    "BatchFinished": Anonymize<I54umskavgc9du>;
    /**
     * An internal error happened. Operations will be paused now.
     */
    "InternalError": undefined;
}>;
export type Idqp67nsfe4563 = {
    "stash": SS58String;
    "result": Anonymize<Ibl6461c27hboe>;
};
export type Ifquqf9uphs1lr = AnonymousEnum<{
    /**
     * Create a new crowdloaning campaign.
     */
    "Created": Anonymize<I37r4bdai8o9mp>;
    /**
     * Contributed to a crowd sale.
     */
    "Contributed": Anonymize<I8ve4g3egaln6a>;
    /**
     * Withdrew full balance of a contributor.
     */
    "Withdrew": Anonymize<I8ve4g3egaln6a>;
    /**
     * The loans in a fund have been partially dissolved, i.e. there are some left
     * over child keys that still need to be killed.
     */
    "PartiallyRefunded": Anonymize<I37r4bdai8o9mp>;
    /**
     * All loans in a fund have been refunded.
     */
    "AllRefunded": Anonymize<I37r4bdai8o9mp>;
    /**
     * Fund is dissolved.
     */
    "Dissolved": Anonymize<I37r4bdai8o9mp>;
    /**
     * The result of trying to submit a new bid to the Slots pallet.
     */
    "HandleBidResult": Anonymize<I88ku48p2ijoqj>;
    /**
     * The configuration to a crowdloan has been edited.
     */
    "Edited": Anonymize<I37r4bdai8o9mp>;
    /**
     * A memo has been updated.
     */
    "MemoUpdated": Anonymize<If4hvqaeoqq5us>;
    /**
     * A parachain has been moved to `NewRaise`
     */
    "AddedToNewRaise": Anonymize<I37r4bdai8o9mp>;
}>;
export type I88ku48p2ijoqj = {
    "para_id": number;
    "result": Anonymize<Ibl6461c27hboe>;
};
export type I5c0hhabdqr8mi = Array<{
    "id": Enum<{
        "Staking": Anonymize<Icbapambb5rug3>;
        "Preimage": PreimagePalletHoldReason;
        "Nis": Enum<{
            "NftReceipt": undefined;
        }>;
        "DelegatedStaking": Anonymize<Ib6ve2drlnapui>;
        "XcmPallet": Anonymize<Ideiof6273rsoe>;
    }>;
    "amount": bigint;
}>;
export type I8tjf5aetgs947 = AnonymousEnum<{
    "Ongoing": {
        "track": number;
        "origin": Anonymize<I8ciua774oe5di>;
        "proposal": PreimagesBounded;
        "enactment": TraitsScheduleDispatchTime;
        "submitted": number;
        "submission_deposit": Anonymize<Id5fm4p8lj5qgi>;
        "decision_deposit"?: Anonymize<Ibd24caul84kv2>;
        "deciding"?: Anonymize<Ibcbcndfmk0jd9>;
        "tally": Anonymize<Ifsk7cbmtit1jd>;
        "in_queue": boolean;
        "alarm"?: Anonymize<I3aj03qk2o5mdm>;
    };
    "Approved": Anonymize<Ini94eljn5lj8>;
    "Rejected": Anonymize<Ini94eljn5lj8>;
    "Cancelled": Anonymize<Ini94eljn5lj8>;
    "TimedOut": Anonymize<Ini94eljn5lj8>;
    "Killed": number;
}>;
export type I8ciua774oe5di = AnonymousEnum<{
    "system": DispatchRawOrigin;
    "Origins": Enum<{
        "StakingAdmin": undefined;
        "Treasurer": undefined;
        "FellowshipAdmin": undefined;
        "GeneralAdmin": undefined;
        "AuctionAdmin": undefined;
        "LeaseAdmin": undefined;
        "ReferendumCanceller": undefined;
        "ReferendumKiller": undefined;
        "SmallTipper": undefined;
        "BigTipper": undefined;
        "SmallSpender": undefined;
        "MediumSpender": undefined;
        "BigSpender": undefined;
        "WhitelistedCaller": undefined;
        "FellowshipInitiates": undefined;
        "Fellows": undefined;
        "FellowshipExperts": undefined;
        "FellowshipMasters": undefined;
        "Fellowship1Dan": undefined;
        "Fellowship2Dan": undefined;
        "Fellowship3Dan": undefined;
        "Fellowship4Dan": undefined;
        "Fellowship5Dan": undefined;
        "Fellowship6Dan": undefined;
        "Fellowship7Dan": undefined;
        "Fellowship8Dan": undefined;
        "Fellowship9Dan": undefined;
        "WishForChange": undefined;
    }>;
    "ParachainsOrigin": ParachainsOrigin;
    "XcmPallet": Anonymize<Icvilmd7qu30i4>;
}>;
export type Iadn4epums2uhi = AnonymousEnum<{
    "Ongoing": {
        "track": number;
        "origin": Anonymize<I8ciua774oe5di>;
        "proposal": PreimagesBounded;
        "enactment": TraitsScheduleDispatchTime;
        "submitted": number;
        "submission_deposit": Anonymize<Id5fm4p8lj5qgi>;
        "decision_deposit"?: Anonymize<Ibd24caul84kv2>;
        "deciding"?: Anonymize<Ibcbcndfmk0jd9>;
        "tally": Anonymize<I6d634btv7misu>;
        "in_queue": boolean;
        "alarm"?: Anonymize<I3aj03qk2o5mdm>;
    };
    "Approved": Anonymize<Ini94eljn5lj8>;
    "Rejected": Anonymize<Ini94eljn5lj8>;
    "Cancelled": Anonymize<Ini94eljn5lj8>;
    "TimedOut": Anonymize<Ini94eljn5lj8>;
    "Killed": number;
}>;
export type Iam8qhv8b3jn4n = {
    "rank": number;
    "strikes": number;
    "vouching"?: (Enum<{
        "Vouching": undefined;
        "Banned": undefined;
    }>) | undefined;
    "index": number;
};
export type I1659sf24o6ga8 = {
    "paid": bigint;
    "payouts": Anonymize<If9jidduiuq7vv>;
};
export type Iehiasr6uoqbq = Array<{
    "who": SS58String;
    "kind": Anonymize<Iand3m1ru4ke2b>;
    "value": bigint;
}>;
export type Iand3m1ru4ke2b = AnonymousEnum<{
    "Deposit": bigint;
    "Vouch": Anonymize<I95l2k9b1re95f>;
}>;
export type I8adv0j4q3uu5d = {
    "round": number;
    "kind": Anonymize<Iand3m1ru4ke2b>;
    "bid": bigint;
    "tally": Anonymize<Ic4n54m09tc5na>;
    "skeptic_struck": boolean;
};
export type Ic4n54m09tc5na = {
    "approvals": number;
    "rejections": number;
};
export type I7d29ossbog0d3 = {
    "approve": boolean;
    "weight": number;
};
export type I7mgf69gvksvu2 = {
    "who": SS58String;
    "bid": bigint;
    "round": number;
};
export type I3sfg6klg56vmk = [SS58String, SS58String, Anonymize<Ic4n54m09tc5na>];
export type Ibprd8oi8phm62 = {
    "delay_period": number;
    "deposit": bigint;
    "friends": Anonymize<Ia2lhg7l2hilo3>;
    "threshold": number;
};
export type Idlqqo993i780l = {
    "created": number;
    "deposit": bigint;
    "friends": Anonymize<Ia2lhg7l2hilo3>;
};
export type Ic24had6sj5r04 = Array<({
    "maybe_id"?: Anonymize<I4s6vifaf8k998>;
    "priority": number;
    "call": PreimagesBounded;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "origin": Anonymize<I8ciua774oe5di>;
}) | undefined>;
export type I4pnnts4ec8rh0 = [Array<{
    "delegate": SS58String;
    "proxy_type": Anonymize<Inpglg3f6qcjg>;
    "delay": number;
}>, bigint];
export type I84stt310eb6c3 = {
    "who": SS58String;
    "deposit": bigint;
    "raw_solution": Anonymize<I6s33laenmuupn>;
    "call_fee": bigint;
};
export type I6s33laenmuupn = {
    "solution": {
        "votes1": Anonymize<Iep4uo61810hfs>;
        "votes2": Anonymize<Ickjq69hlul8c3>;
        "votes3": Anonymize<Icf645ln9bi1bj>;
        "votes4": Anonymize<I8nospv7k5s457>;
        "votes5": Anonymize<Iig9pofg77rah>;
        "votes6": Anonymize<Irttjt9tghoc0>;
        "votes7": Anonymize<I3o5epjr2va0dl>;
        "votes8": Anonymize<I1gfnebceebqb5>;
        "votes9": Anonymize<Ibo38fh2dhj4it>;
        "votes10": Anonymize<Id4gvspmdh8h9l>;
        "votes11": Anonymize<I5be3ho5m1r68a>;
        "votes12": Anonymize<I7s2sh7cpuv56r>;
        "votes13": Anonymize<I5fq8855gfhmlo>;
        "votes14": Anonymize<I4mvok713k4g7o>;
        "votes15": Anonymize<I90tu9lmjmhfhd>;
        "votes16": Anonymize<I3cqaev9m4hn9m>;
        "votes17": Array<[number, FixedSizeArray<16, Anonymize<I5g2vv0ckl2m8b>>, number]>;
        "votes18": Array<[number, FixedSizeArray<17, Anonymize<I5g2vv0ckl2m8b>>, number]>;
        "votes19": Array<[number, FixedSizeArray<18, Anonymize<I5g2vv0ckl2m8b>>, number]>;
        "votes20": Array<[number, FixedSizeArray<19, Anonymize<I5g2vv0ckl2m8b>>, number]>;
        "votes21": Array<[number, FixedSizeArray<20, Anonymize<I5g2vv0ckl2m8b>>, number]>;
        "votes22": Array<[number, FixedSizeArray<21, Anonymize<I5g2vv0ckl2m8b>>, number]>;
        "votes23": Array<[number, FixedSizeArray<22, Anonymize<I5g2vv0ckl2m8b>>, number]>;
        "votes24": Array<[number, FixedSizeArray<23, Anonymize<I5g2vv0ckl2m8b>>, number]>;
    };
    "score": Anonymize<I8s6n43okuj2b1>;
    "round": number;
};
export type I2cqtnj49ogo81 = Array<Anonymize<Id5fm4p8lj5qgi>>;
export type I7btpfdeli5ea8 = {
    "proportion_owed": bigint;
    "index": number;
    "thawed": bigint;
    "last_period": number;
    "receipts_on_hold": bigint;
};
export type Ic79q40j9qptgh = {
    "proportion": bigint;
    "owner"?: Anonymize<I92hdo1clkbp4g>;
    "expiry": number;
};
export type Ifisb4g8kpcvts = AnonymousEnum<{
    /**
     * Propose a referendum on a privileged action.
     *
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     * available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     *
     * Emits `Submitted`.
     */
    "submit": Anonymize<Idnv6pbfffoouj>;
    /**
     * Post the Decision Deposit for a referendum.
     *
     * - `origin`: must be `Signed` and the account must have funds available for the
     * referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     * posted.
     *
     * Emits `DecisionDepositPlaced`.
     */
    "place_decision_deposit": Anonymize<I666bl2fqjkejo>;
    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     * refunded.
     *
     * Emits `DecisionDepositRefunded`.
     */
    "refund_decision_deposit": Anonymize<I666bl2fqjkejo>;
    /**
     * Cancel an ongoing referendum.
     *
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Cancelled`.
     */
    "cancel": Anonymize<I666bl2fqjkejo>;
    /**
     * Cancel an ongoing referendum and slash the deposits.
     *
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     *
     * Emits `Killed` and `DepositSlashed`.
     */
    "kill": Anonymize<I666bl2fqjkejo>;
    /**
     * Advance a referendum onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     */
    "nudge_referendum": Anonymize<I666bl2fqjkejo>;
    /**
     * Advance a track onto its next logical state. Only used internally.
     *
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     *
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     */
    "one_fewer_deciding": Anonymize<Icbio0e1f0034b>;
    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     *
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     * refunded.
     *
     * Emits `SubmissionDepositRefunded`.
     */
    "refund_submission_deposit": Anonymize<I666bl2fqjkejo>;
    /**
     * Set or clear metadata of a referendum.
     *
     * Parameters:
     * - `origin`: Must be `Signed` by a creator of a referendum or by anyone to clear a
     * metadata of a finished referendum.
     * - `index`:  The index of a referendum to set or clear metadata for.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     */
    "set_metadata": Anonymize<I8c0vkqjjipnuj>;
}>;
export type Idnv6pbfffoouj = {
    "proposal_origin": Anonymize<I8ciua774oe5di>;
    "proposal": PreimagesBounded;
    "enactment_moment": TraitsScheduleDispatchTime;
};
export type I5bt1lc4doakmu = AnonymousEnum<{
    /**
     * Introduce a new member.
     *
     * - `origin`: Must be the `AddOrigin`.
     * - `who`: Account of non-member which will become a member.
     *
     * Weight: `O(1)`
     */
    "add_member": Anonymize<I59bngqm85b22v>;
    /**
     * Increment the rank of an existing member by one.
     *
     * - `origin`: Must be the `PromoteOrigin`.
     * - `who`: Account of existing member.
     *
     * Weight: `O(1)`
     */
    "promote_member": Anonymize<I59bngqm85b22v>;
    /**
     * Decrement the rank of an existing member by one. If the member is already at rank zero,
     * then they are removed entirely.
     *
     * - `origin`: Must be the `DemoteOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     *
     * Weight: `O(1)`, less if the member's index is highest in its rank.
     */
    "demote_member": Anonymize<I59bngqm85b22v>;
    /**
     * Remove the member entirely.
     *
     * - `origin`: Must be the `RemoveOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     * - `min_rank`: The rank of the member or greater.
     *
     * Weight: `O(min_rank)`.
     */
    "remove_member": Anonymize<I3amdclkdfaipk>;
    /**
     * Add an aye or nay vote for the sender to the given proposal.
     *
     * - `origin`: Must be `Signed` by a member account.
     * - `poll`: Index of a poll which is ongoing.
     * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
     *
     * Transaction fees are be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     *
     * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
     */
    "vote": Anonymize<I8bvk21lpmah75>;
    /**
     * Remove votes from the given poll. It must have ended.
     *
     * - `origin`: Must be `Signed` by any account.
     * - `poll_index`: Index of a poll which is completed and for which votes continue to
     * exist.
     * - `max`: Maximum number of vote items from remove in this call.
     *
     * Transaction fees are waived if the operation is successful.
     *
     * Weight `O(max)` (less if there are fewer items to remove than `max`).
     */
    "cleanup_poll": Anonymize<I449n3riv6jbum>;
    /**
     * Exchanges a member with a new account and the same existing rank.
     *
     * - `origin`: Must be the `ExchangeOrigin`.
     * - `who`: Account of existing member of rank greater than zero to be exchanged.
     * - `new_who`: New Account of existing member of rank greater than zero to exchanged to.
     */
    "exchange_member": Anonymize<I9a7qiue67urvk>;
}>;
export type I3amdclkdfaipk = {
    "who": MultiAddress;
    "min_rank": number;
};
export type I9a7qiue67urvk = {
    "who": MultiAddress;
    "new_who": MultiAddress;
};
export type I8hj3jsqg5v6qd = AnonymousEnum<{
    "whitelist_call": Anonymize<I1adbcfi5uc62r>;
    "remove_whitelisted_call": Anonymize<I1adbcfi5uc62r>;
    "dispatch_whitelisted_call": Anonymize<Ibf6ucefn8fh49>;
    "dispatch_whitelisted_call_with_preimage": Anonymize<I1f8iuvqma6ghn>;
}>;
export type I1f8iuvqma6ghn = {
    "call": TxCallData;
};
export type I6c87qqdfiha0s = AnonymousEnum<{
    /**
     * Set the value of a parameter.
     *
     * The dispatch origin of this call must be `AdminOrigin` for the given `key`. Values be
     * deleted by setting them to `None`.
     */
    "set_parameter": Anonymize<I65ea24ohl89b2>;
}>;
export type I65ea24ohl89b2 = {
    "key_value": Enum<{
        "Inflation": Enum<{
            "MinInflation": Anonymize<Ia023ofm66k1pj>;
            "MaxInflation": Anonymize<Ia023ofm66k1pj>;
            "IdealStake": Anonymize<Ia023ofm66k1pj>;
            "Falloff": Anonymize<Ia023ofm66k1pj>;
            "UseAuctionSlots": FixedSizeArray<1, Anonymize<I8ie0dco0kcuq5>>;
        }>;
        "Treasury": Enum<{
            "BurnPortion": Anonymize<Idqsmalvqe2q98>;
            "BurnDestination": FixedSizeArray<1, (Anonymize<Ihfphjolmsqq1>) | undefined>;
        }>;
    }>;
};
export type Iecjrd3q0e1ldt = AnonymousEnum<{
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    "batch": Anonymize<Ia39eg8v97icpc>;
    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     */
    "as_derivative": Anonymize<Iata2r8pmdmcpp>;
    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    "batch_all": Anonymize<Ia39eg8v97icpc>;
    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     */
    "dispatch_as": Anonymize<I3bmordmnlc8st>;
    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     */
    "force_batch": Anonymize<Ia39eg8v97icpc>;
    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     */
    "with_weight": Anonymize<Ib0mc6ks0sai31>;
    /**
     * Dispatch a fallback call in the event the main call fails to execute.
     * May be called from any origin except `None`.
     *
     * This function first attempts to dispatch the `main` call.
     * If the `main` call fails, the `fallback` is attemted.
     * if the fallback is successfully dispatched, the weights of both calls
     * are accumulated and an event containing the main call error is deposited.
     *
     * In the event of a fallback failure the whole call fails
     * with the weights returned.
     *
     * - `main`: The main call to be dispatched. This is the primary action to execute.
     * - `fallback`: The fallback call to be dispatched in case the `main` call fails.
     *
     * ## Dispatch Logic
     * - If the origin is `root`, both the main and fallback calls are executed without
     * applying any origin filters.
     * - If the origin is not `root`, the origin filter is applied to both the `main` and
     * `fallback` calls.
     *
     * ## Use Case
     * - Some use cases might involve submitting a `batch` type call in either main, fallback
     * or both.
     */
    "if_else": Anonymize<Iaf48os65cauaf>;
    /**
     * Dispatches a function call with a provided origin.
     *
     * Almost the same as [`Pallet::dispatch_as`] but forwards any error of the inner call.
     *
     * The dispatch origin for this call must be _Root_.
     */
    "dispatch_as_fallible": Anonymize<I3bmordmnlc8st>;
}>;
export type Ia39eg8v97icpc = {
    "calls": Array<TxCallData>;
};
export type Iata2r8pmdmcpp = {
    "index": number;
    "call": TxCallData;
};
export type I3bmordmnlc8st = {
    "as_origin": Anonymize<I8ciua774oe5di>;
    "call": TxCallData;
};
export type Ib0mc6ks0sai31 = {
    "call": TxCallData;
    "weight": Anonymize<I4q39t5hn830vp>;
};
export type Iaf48os65cauaf = {
    "main": TxCallData;
    "fallback": TxCallData;
};
export type Iaup05df56f0nc = AnonymousEnum<{
    /**
     * A user outside of the society can make a bid for entry.
     *
     * Payment: The group's Candidate Deposit will be reserved for making a bid. It is returned
     * when the bid becomes a member, or if the bid calls `unbid`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `value`: A one time payment the bid would like to receive when joining the society.
     */
    "bid": Anonymize<Ie5v6njpckr05b>;
    /**
     * A bidder can remove their bid for entry into society.
     * By doing so, they will have their candidate deposit returned or
     * they will unvouch their voucher.
     *
     * Payment: The bid deposit is unreserved if the user made a bid.
     *
     * The dispatch origin for this call must be _Signed_ and a bidder.
     */
    "unbid": undefined;
    /**
     * As a member, vouch for someone to join society by placing a bid on their behalf.
     *
     * There is no deposit required to vouch for a new bid, but a member can only vouch for
     * one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by
     * the suspension judgement origin, the member will be banned from vouching again.
     *
     * As a vouching member, you can claim a tip if the candidate is accepted. This tip will
     * be paid as a portion of the reward the member will receive for joining the society.
     *
     * The dispatch origin for this call must be _Signed_ and a member.
     *
     * Parameters:
     * - `who`: The user who you would like to vouch for.
     * - `value`: The total reward to be paid between you and the candidate if they become
     * a member in the society.
     * - `tip`: Your cut of the total `value` payout when the candidate is inducted into
     * the society. Tips larger than `value` will be saturated upon payout.
     */
    "vouch": Anonymize<Ibvkbvbkttt0k5>;
    /**
     * As a vouching member, unvouch a bid. This only works while vouched user is
     * only a bidder (and not a candidate).
     *
     * The dispatch origin for this call must be _Signed_ and a vouching member.
     *
     * Parameters:
     * - `pos`: Position in the `Bids` vector of the bid who should be unvouched.
     */
    "unvouch": undefined;
    /**
     * As a member, vote on a candidate.
     *
     * The dispatch origin for this call must be _Signed_ and a member.
     *
     * Parameters:
     * - `candidate`: The candidate that the member would like to bid on.
     * - `approve`: A boolean which says if the candidate should be approved (`true`) or
     * rejected (`false`).
     */
    "vote": Anonymize<I8i12uisk6j7l>;
    /**
     * As a member, vote on the defender.
     *
     * The dispatch origin for this call must be _Signed_ and a member.
     *
     * Parameters:
     * - `approve`: A boolean which says if the candidate should be
     * approved (`true`) or rejected (`false`).
     */
    "defender_vote": Anonymize<I26anifrfnljoi>;
    /**
     * Transfer the first matured payout for the sender and remove it from the records.
     *
     * NOTE: This extrinsic needs to be called multiple times to claim multiple matured
     * payouts.
     *
     * Payment: The member will receive a payment equal to their first matured
     * payout to their free balance.
     *
     * The dispatch origin for this call must be _Signed_ and a member with
     * payouts remaining.
     */
    "payout": undefined;
    /**
     * Repay the payment previously given to the member with the signed origin, remove any
     * pending payments, and elevate them from rank 0 to rank 1.
     */
    "waive_repay": Anonymize<I3qt1hgg4djhgb>;
    /**
     * Found the society.
     *
     * This is done as a discrete action in order to allow for the
     * pallet to be included into a running chain and can only be done once.
     *
     * The dispatch origin for this call must be from the _FounderSetOrigin_.
     *
     * Parameters:
     * - `founder` - The first member and head of the newly founded society.
     * - `max_members` - The initial max number of members for the society.
     * - `max_intake` - The maximum number of candidates per intake period.
     * - `max_strikes`: The maximum number of strikes a member may get before they become
     * suspended and may only be reinstated by the founder.
     * - `candidate_deposit`: The deposit required to make a bid for membership of the group.
     * - `rules` - The rules of this society concerning membership.
     *
     * Complexity: O(1)
     */
    "found_society": Anonymize<I6a6f85pb71ums>;
    /**
     * Dissolve the society and remove all members.
     *
     * The dispatch origin for this call must be Signed, and the signing account must be both
     * the `Founder` and the `Head`. This implies that it may only be done when there is one
     * member.
     */
    "dissolve": undefined;
    /**
     * Allow suspension judgement origin to make judgement on a suspended member.
     *
     * If a suspended member is forgiven, we simply add them back as a member, not affecting
     * any of the existing storage items for that member.
     *
     * If a suspended member is rejected, remove all associated storage items, including
     * their payouts, and remove any vouched bids they currently have.
     *
     * The dispatch origin for this call must be Signed from the Founder.
     *
     * Parameters:
     * - `who` - The suspended member to be judged.
     * - `forgive` - A boolean representing whether the suspension judgement origin forgives
     * (`true`) or rejects (`false`) a suspended member.
     */
    "judge_suspended_member": Anonymize<I96p6guspeq6t>;
    /**
     * Change the maximum number of members in society and the maximum number of new candidates
     * in a single intake period.
     *
     * The dispatch origin for this call must be Signed by the Founder.
     *
     * Parameters:
     * - `max_members` - The maximum number of members for the society. This must be no less
     * than the current number of members.
     * - `max_intake` - The maximum number of candidates per intake period.
     * - `max_strikes`: The maximum number of strikes a member may get before they become
     * suspended and may only be reinstated by the founder.
     * - `candidate_deposit`: The deposit required to make a bid for membership of the group.
     */
    "set_parameters": Anonymize<I9hkvi4k3kh916>;
    /**
     * Punish the skeptic with a strike if they did not vote on a candidate. Callable by the
     * candidate.
     */
    "punish_skeptic": undefined;
    /**
     * Transform an approved candidate into a member. Callable only by the
     * the candidate, and only after the period for voting has ended.
     */
    "claim_membership": undefined;
    /**
     * Transform an approved candidate into a member. Callable only by the Signed origin of the
     * Founder, only after the period for voting has ended and only when the candidate is not
     * clearly rejected.
     */
    "bestow_membership": Anonymize<I4b66js88p45m8>;
    /**
     * Remove the candidate's application from the society. Callable only by the Signed origin
     * of the Founder, only after the period for voting has ended, and only when they do not
     * have a clear approval.
     *
     * Any bid deposit is lost and voucher is banned.
     */
    "kick_candidate": Anonymize<I4b66js88p45m8>;
    /**
     * Remove the candidate's application from the society. Callable only by the candidate.
     *
     * Any bid deposit is lost and voucher is banned.
     */
    "resign_candidacy": undefined;
    /**
     * Remove a `candidate`'s failed application from the society. Callable by any
     * signed origin but only at the end of the subsequent round and only for
     * a candidate with more rejections than approvals.
     *
     * The bid deposit is lost and the voucher is banned.
     */
    "drop_candidate": Anonymize<I4b66js88p45m8>;
    /**
     * Remove up to `max` stale votes for the given `candidate`.
     *
     * May be called by any Signed origin, but only after the candidate's candidacy is ended.
     */
    "cleanup_candidacy": Anonymize<Ieh40op1lafir9>;
    /**
     * Remove up to `max` stale votes for the defender in the given `challenge_round`.
     *
     * May be called by any Signed origin, but only after the challenge round is ended.
     */
    "cleanup_challenge": Anonymize<Icjp7f9u9fno72>;
}>;
export type Ibvkbvbkttt0k5 = {
    "who": MultiAddress;
    "value": bigint;
    "tip": bigint;
};
export type I8i12uisk6j7l = {
    "candidate": MultiAddress;
    "approve": boolean;
};
export type I26anifrfnljoi = {
    "approve": boolean;
};
export type I6a6f85pb71ums = {
    "founder": MultiAddress;
    "max_members": number;
    "max_intake": number;
    "max_strikes": number;
    "candidate_deposit": bigint;
    "rules": Binary;
};
export type I96p6guspeq6t = {
    "who": MultiAddress;
    "forgive": boolean;
};
export type Ieh40op1lafir9 = {
    "candidate": SS58String;
    "max": number;
};
export type Icjp7f9u9fno72 = {
    "challenge_round": number;
    "max": number;
};
export type Ibqcvgebph9nnp = AnonymousEnum<{
    /**
     * Send a call through a recovered account.
     *
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     *
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    "as_recovered": Anonymize<Iet8cc3uq0ut5i>;
    /**
     * Allow ROOT to bypass the recovery process and set a rescuer account
     * for a lost account directly.
     *
     * The dispatch origin for this call must be _ROOT_.
     *
     * Parameters:
     * - `lost`: The "lost account" to be recovered.
     * - `rescuer`: The "rescuer account" which can call as the lost account.
     */
    "set_recovered": Anonymize<I7pqmhr25d3dqq>;
    /**
     * Create a recovery configuration for your account. This makes your account recoverable.
     *
     * Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance
     * will be reserved for storing the recovery configuration. This deposit is returned
     * in full when the user calls `remove_recovery`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `friends`: A list of friends you trust to vouch for recovery attempts. Should be
     * ordered and contain no duplicate values.
     * - `threshold`: The number of friends that must vouch for a recovery attempt before the
     * account can be recovered. Should be less than or equal to the length of the list of
     * friends.
     * - `delay_period`: The number of blocks after a recovery attempt is initialized that
     * needs to pass before the account can be recovered.
     */
    "create_recovery": Anonymize<I6s6ihmfj6j5qq>;
    /**
     * Initiate the process for recovering a recoverable account.
     *
     * Payment: `RecoveryDeposit` balance will be reserved for initiating the
     * recovery process. This deposit will always be repatriated to the account
     * trying to be recovered. See `close_recovery`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `account`: The lost account that you want to recover. This account needs to be
     * recoverable (i.e. have a recovery configuration).
     */
    "initiate_recovery": Anonymize<Ic6cqd9g0t65v0>;
    /**
     * Allow a "friend" of a recoverable account to vouch for an active recovery
     * process for that account.
     *
     * The dispatch origin for this call must be _Signed_ and must be a "friend"
     * for the recoverable account.
     *
     * Parameters:
     * - `lost`: The lost account that you want to recover.
     * - `rescuer`: The account trying to rescue the lost account that you want to vouch for.
     *
     * The combination of these two parameters must point to an active recovery
     * process.
     */
    "vouch_recovery": Anonymize<I7pqmhr25d3dqq>;
    /**
     * Allow a successful rescuer to claim their recovered account.
     *
     * The dispatch origin for this call must be _Signed_ and must be a "rescuer"
     * who has successfully completed the account recovery process: collected
     * `threshold` or more vouches, waited `delay_period` blocks since initiation.
     *
     * Parameters:
     * - `account`: The lost account that you want to claim has been successfully recovered by
     * you.
     */
    "claim_recovery": Anonymize<Ic6cqd9g0t65v0>;
    /**
     * As the controller of a recoverable account, close an active recovery
     * process for your account.
     *
     * Payment: By calling this function, the recoverable account will receive
     * the recovery deposit `RecoveryDeposit` placed by the rescuer.
     *
     * The dispatch origin for this call must be _Signed_ and must be a
     * recoverable account with an active recovery process for it.
     *
     * Parameters:
     * - `rescuer`: The account trying to rescue this recoverable account.
     */
    "close_recovery": Anonymize<I7ka1pdlbuevh2>;
    /**
     * Remove the recovery process for your account. Recovered accounts are still accessible.
     *
     * NOTE: The user must make sure to call `close_recovery` on all active
     * recovery attempts before calling this function else it will fail.
     *
     * Payment: By calling this function the recoverable account will unreserve
     * their recovery configuration deposit.
     * (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)
     *
     * The dispatch origin for this call must be _Signed_ and must be a
     * recoverable account (i.e. has a recovery configuration).
     */
    "remove_recovery": undefined;
    /**
     * Cancel the ability to use `as_recovered` for `account`.
     *
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     *
     * Parameters:
     * - `account`: The recovered account you are able to call on-behalf-of.
     */
    "cancel_recovered": Anonymize<Ic6cqd9g0t65v0>;
}>;
export type Iet8cc3uq0ut5i = {
    "account": MultiAddress;
    "call": TxCallData;
};
export type I7pqmhr25d3dqq = {
    "lost": MultiAddress;
    "rescuer": MultiAddress;
};
export type I6s6ihmfj6j5qq = {
    "friends": Anonymize<Ia2lhg7l2hilo3>;
    "threshold": number;
    "delay_period": number;
};
export type I7ka1pdlbuevh2 = {
    "rescuer": MultiAddress;
};
export type I9nlpr123rdmjq = AnonymousEnum<{
    /**
     * Anonymously schedule a task.
     */
    "schedule": Anonymize<I41dke7umc2tcn>;
    /**
     * Cancel an anonymously scheduled task.
     */
    "cancel": Anonymize<I5n4sebgkfr760>;
    /**
     * Schedule a named task.
     */
    "schedule_named": Anonymize<I9ocsim46lmpp9>;
    /**
     * Cancel a named scheduled task.
     */
    "cancel_named": Anonymize<Ifs1i5fk9cqvr6>;
    /**
     * Anonymously schedule a task after a delay.
     */
    "schedule_after": Anonymize<I23jtcr82a2te1>;
    /**
     * Schedule a named task after a delay.
     */
    "schedule_named_after": Anonymize<I7g9k5thdojl92>;
    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     */
    "set_retry": Anonymize<Ieg3fd8p4pkt10>;
    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     */
    "set_retry_named": Anonymize<I8kg5ll427kfqq>;
    /**
     * Removes the retry configuration of a task.
     */
    "cancel_retry": Anonymize<I467333262q1l9>;
    /**
     * Cancel the retry configuration of a named task.
     */
    "cancel_retry_named": Anonymize<Ifs1i5fk9cqvr6>;
}>;
export type I41dke7umc2tcn = {
    "when": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I9ocsim46lmpp9 = {
    "id": FixedSizeBinary<32>;
    "when": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I23jtcr82a2te1 = {
    "after": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type I7g9k5thdojl92 = {
    "id": FixedSizeBinary<32>;
    "after": number;
    "maybe_periodic"?: Anonymize<Iep7au1720bm0e>;
    "priority": number;
    "call": TxCallData;
};
export type Iail45lhvep9rb = AnonymousEnum<{
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    "proxy": Anonymize<I46rnvi8s2gn3o>;
    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     */
    "add_proxy": Anonymize<I81psug9dsrjik>;
    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     */
    "remove_proxy": Anonymize<I81psug9dsrjik>;
    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     */
    "remove_proxies": undefined;
    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     */
    "create_pure": Anonymize<Ifd1qham1gpgjc>;
    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     */
    "kill_pure": Anonymize<I68ehmckmhc2ki>;
    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    "announce": Anonymize<I2eb501t8s6hsq>;
    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    "remove_announcement": Anonymize<I2eb501t8s6hsq>;
    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     */
    "reject_announcement": Anonymize<Ianmuoljk2sk1u>;
    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    "proxy_announced": Anonymize<I9f4ab8nblot9r>;
    /**
     * Poke / Adjust deposits made for proxies and announcements based on current values.
     * This can be used by accounts to possibly lower their locked amount.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * The transaction fee is waived if the deposit amount has changed.
     *
     * Emits `DepositPoked` if successful.
     */
    "poke_deposit": undefined;
}>;
export type I46rnvi8s2gn3o = {
    "real": MultiAddress;
    "force_proxy_type"?: Anonymize<I4sv79c6siq7sq>;
    "call": TxCallData;
};
export type I4sv79c6siq7sq = (Anonymize<Inpglg3f6qcjg>) | undefined;
export type I81psug9dsrjik = {
    "delegate": MultiAddress;
    "proxy_type": Anonymize<Inpglg3f6qcjg>;
    "delay": number;
};
export type Ifd1qham1gpgjc = {
    "proxy_type": Anonymize<Inpglg3f6qcjg>;
    "delay": number;
    "index": number;
};
export type I68ehmckmhc2ki = {
    "spawner": MultiAddress;
    "proxy_type": Anonymize<Inpglg3f6qcjg>;
    "index": number;
    "height": number;
    "ext_index": number;
};
export type I9f4ab8nblot9r = {
    "delegate": MultiAddress;
    "real": MultiAddress;
    "force_proxy_type"?: Anonymize<I4sv79c6siq7sq>;
    "call": TxCallData;
};
export type Ibhq1hnjds11b8 = AnonymousEnum<{
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     */
    "as_multi_threshold_1": Anonymize<Icbko6q5mf2r6m>;
    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    "as_multi": Anonymize<I95bsrongsvmjm>;
    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     */
    "approve_as_multi": Anonymize<Ideaemvoneh309>;
    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     */
    "cancel_as_multi": Anonymize<I3d9o9d7epp66v>;
    /**
     * Poke the deposit reserved for an existing multisig operation.
     *
     * The dispatch origin for this call must be _Signed_ and must be the original depositor of
     * the multisig operation.
     *
     * The transaction fee is waived if the deposit amount has changed.
     *
     * - `threshold`: The total number of approvals needed for this multisig.
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multisig.
     * - `call_hash`: The hash of the call this deposit is reserved for.
     *
     * Emits `DepositPoked` if successful.
     */
    "poke_deposit": Anonymize<I6lqh1vgb4mcja>;
}>;
export type Icbko6q5mf2r6m = {
    "other_signatories": Anonymize<Ia2lhg7l2hilo3>;
    "call": TxCallData;
};
export type I95bsrongsvmjm = {
    "threshold": number;
    "other_signatories": Anonymize<Ia2lhg7l2hilo3>;
    "maybe_timepoint"?: Anonymize<I95jfd8j5cr5eh>;
    "call": TxCallData;
    "max_weight": Anonymize<I4q39t5hn830vp>;
};
export type I5dqci5rl3kg3m = AnonymousEnum<{
    /**
     * Submit a solution for the unsigned phase.
     *
     * The dispatch origin fo this call must be __none__.
     *
     * This submission is checked on the fly. Moreover, this unsigned solution is only
     * validated when submitted to the pool from the **local** node. Effectively, this means
     * that only active validators can submit this transaction when authoring a block (similar
     * to an inherent).
     *
     * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     * panic if the solution submitted by the validator is invalid in any way, effectively
     * putting their authoring reward at risk.
     *
     * No deposit or reward is associated with this submission.
     */
    "submit_unsigned": Anonymize<Ic50i89t5eabvg>;
    /**
     * Set a new value for `MinimumUntrustedScore`.
     *
     * Dispatch origin must be aligned with `T::ForceOrigin`.
     *
     * This check can be turned off by setting the value to `None`.
     */
    "set_minimum_untrusted_score": Anonymize<I80q14um2s2ckg>;
    /**
     * Set a solution in the queue, to be handed out to the client of this pallet in the next
     * call to `ElectionProvider::elect`.
     *
     * This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
     *
     * The solution is not checked for any feasibility and is assumed to be trustworthy, as any
     * feasibility check itself can in principle cause the election process to fail (due to
     * memory/weight constrains).
     */
    "set_emergency_election_result": Anonymize<I5qs1t1erfi7u8>;
    /**
     * Submit a solution for the signed phase.
     *
     * The dispatch origin fo this call must be __signed__.
     *
     * The solution is potentially queued, based on the claimed score and processed at the end
     * of the signed phase.
     *
     * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     * might be rewarded, slashed, or get all or a part of the deposit back.
     */
    "submit": Anonymize<I2ou0mtsgm3l71>;
    /**
     * Trigger the governance fallback.
     *
     * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
     * calling [`Call::set_emergency_election_result`].
     */
    "governance_fallback": Anonymize<Ifsme8miqq9006>;
}>;
export type Ic50i89t5eabvg = {
    "raw_solution": Anonymize<I6s33laenmuupn>;
    "witness": Anonymize<Iasd2iat48n080>;
};
export type I2ou0mtsgm3l71 = {
    "raw_solution": Anonymize<I6s33laenmuupn>;
};
export type Iaq5q67idam8ll = AnonymousEnum<{
    /**
     * Place a bid.
     *
     * Origin must be Signed, and account must have at least `amount` in free balance.
     *
     * - `amount`: The amount of the bid; these funds will be reserved, and if/when
     * consolidated, removed. Must be at least `MinBid`.
     * - `duration`: The number of periods before which the newly consolidated bid may be
     * thawed. Must be greater than 1 and no more than `QueueCount`.
     *
     * Complexities:
     * - `Queues[duration].len()` (just take max).
     */
    "place_bid": Anonymize<Icckjru8f8flpj>;
    /**
     * Retract a previously placed bid.
     *
     * Origin must be Signed, and the account should have previously issued a still-active bid
     * of `amount` for `duration`.
     *
     * - `amount`: The amount of the previous bid.
     * - `duration`: The duration of the previous bid.
     */
    "retract_bid": Anonymize<Icckjru8f8flpj>;
    /**
     * Ensure we have sufficient funding for all potential payouts.
     *
     * - `origin`: Must be accepted by `FundOrigin`.
     */
    "fund_deficit": undefined;
    /**
     * Reduce or remove an outstanding receipt, placing the according proportion of funds into
     * the account of the owner.
     *
     * - `origin`: Must be Signed and the account must be the owner of the receipt `index` as
     * well as any fungible counterpart.
     * - `index`: The index of the receipt.
     * - `portion`: If `Some`, then only the given portion of the receipt should be thawed. If
     * `None`, then all of it should be.
     */
    "thaw_private": Anonymize<Iba38lgbjrs7je>;
    /**
     * Reduce or remove an outstanding receipt, placing the according proportion of funds into
     * the account of the owner.
     *
     * - `origin`: Must be Signed and the account must be the owner of the fungible counterpart
     * for receipt `index`.
     * - `index`: The index of the receipt.
     */
    "thaw_communal": Anonymize<I666bl2fqjkejo>;
    /**
     * Make a private receipt communal and create fungible counterparts for its owner.
     */
    "communify": Anonymize<I666bl2fqjkejo>;
    /**
     * Make a communal receipt private and burn fungible counterparts from its owner.
     */
    "privatize": Anonymize<I666bl2fqjkejo>;
}>;
export type Icckjru8f8flpj = {
    "amount": bigint;
    "duration": number;
};
export type Iba38lgbjrs7je = {
    "index": number;
    "maybe_proportion"?: Anonymize<I35p85j063s0il>;
};
export type I9ftc6joheck1g = ResultPayload<Anonymize<Ibl6461c27hboe>, Anonymize<I5nrjkj9qumobs>>;
export type I766dsrsdk5kal = AnonymousEnum<{
    "System": Anonymize<Iekve0i6djpd9f>;
    "Babe": Anonymize<I1jeo0dpbkma5g>;
    "Timestamp": Anonymize<I7d75gqfg6jh9c>;
    "Indices": Anonymize<I67ac6i6ihmvpt>;
    "Balances": Anonymize<I9svldsp29mh87>;
    "Staking": Anonymize<Icm294co91mkfj>;
    "Session": Anonymize<Iceajactc9a8pc>;
    "Grandpa": Anonymize<I5u9ggmn8umfqm>;
    "Treasury": Anonymize<I6jnp85onk3m8j>;
    "ConvictionVoting": Anonymize<Ie5kd08tutk56t>;
    "Referenda": Anonymize<Ifisb4g8kpcvts>;
    "FellowshipCollective": Anonymize<I5bt1lc4doakmu>;
    "FellowshipReferenda": Anonymize<Ifisb4g8kpcvts>;
    "Whitelist": Anonymize<I8hj3jsqg5v6qd>;
    "Parameters": Anonymize<I6c87qqdfiha0s>;
    "Claims": Anonymize<Id0dj18ct09hlp>;
    "Utility": Anonymize<Iecjrd3q0e1ldt>;
    "Society": Anonymize<Iaup05df56f0nc>;
    "Recovery": Anonymize<Ibqcvgebph9nnp>;
    "Vesting": Anonymize<Icgf8vmtkbnu4u>;
    "Scheduler": Anonymize<I9nlpr123rdmjq>;
    "Proxy": Anonymize<Iail45lhvep9rb>;
    "Multisig": Anonymize<Ibhq1hnjds11b8>;
    "Preimage": Anonymize<If81ks88t5mpk5>;
    "Bounties": Anonymize<I1nnef4ljub6d0>;
    "ChildBounties": Anonymize<I1b6drdhvt5hl9>;
    "ElectionProviderMultiPhase": Anonymize<I5dqci5rl3kg3m>;
    "Nis": Anonymize<Iaq5q67idam8ll>;
    "NisCounterpartBalances": Anonymize<I9svldsp29mh87>;
    "VoterList": Anonymize<Ifvfo1l0vu2o7e>;
    "NominationPools": Anonymize<I57mljkkr28m9p>;
    "FastUnstake": Anonymize<I44snhj1gahvrd>;
    "Configuration": Anonymize<I3ah0kpgrv4i88>;
    "ParasShared": undefined;
    "ParaInclusion": undefined;
    "ParaInherent": Anonymize<I1nu19212e8egv>;
    "Paras": Anonymize<Ie2dden5k4kk7t>;
    "Initializer": Anonymize<Ieggtnkc96vvt7>;
    "Hrmp": Anonymize<I45adic8nko129>;
    "ParasDisputes": Anonymize<Ifkh1ep7g9h3rv>;
    "ParasSlashing": Anonymize<I7a6dbilbccifr>;
    "OnDemandAssignmentProvider": Anonymize<I1qq9dc763kccf>;
    "Registrar": Anonymize<Icclqj5sge2nc7>;
    "Slots": Anonymize<Iafhis924j14hg>;
    "Auctions": Anonymize<I4a8qeimc5p3qn>;
    "Crowdloan": Anonymize<Iaj4q75nu5v2i2>;
    "Coretime": Anonymize<Ifr31g56am9igr>;
    "XcmPallet": Anonymize<I6k1inef986368>;
    "MessageQueue": Anonymize<I3lic4llm6egbr>;
    "AssetRate": Anonymize<If582h5gr5gh6f>;
    "Beefy": Anonymize<Idmcmrk34p8gic>;
}>;
export type If7f1qergdnk31 = ResultPayload<{
    "execution_result": Anonymize<Ia6jvgaum2t2gb>;
    "emitted_events": Anonymize<Iej7j3ev8prh50>;
    "local_xcm"?: Anonymize<Ieqgqma27vbupd>;
    "forwarded_xcms": Anonymize<Ialhmrpub9sefe>;
}, Anonymize<I55ku9c5gk50hb>>;
export type Iej7j3ev8prh50 = Array<Anonymize<I9983s9bd0q4a9>>;
export type Iblcpl72aj79s1 = ResultPayload<{
    "execution_result": Anonymize<I6uq5gb4s805s7>;
    "emitted_events": Anonymize<Iej7j3ev8prh50>;
    "forwarded_xcms": Anonymize<Ialhmrpub9sefe>;
}, Anonymize<I55ku9c5gk50hb>>;
export {};
